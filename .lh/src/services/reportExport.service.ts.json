{
    "sourceFile": "src/services/reportExport.service.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 7,
            "patches": [
                {
                    "date": 1753118436059,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1753118639781,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,50 @@\n+import { PrismaClient } from '@prisma/client';\r\n+import { Parser } from 'json2csv';\r\n+import PDFDocument from 'pdfkit';\r\n+const getStream = (await import('get-stream')).default;\r\n+\r\n+\r\n+const prisma = new PrismaClient();\r\n+\r\n+export const generateCSVBuffer = async (filters: any) => {\r\n+  const data = await fetchFilteredData(filters);\r\n+\r\n+  const fields = Object.keys(data[0] || {});\r\n+  const parser = new Parser({ fields });\r\n+  const csv = parser.parse(data);\r\n+\r\n+  return Buffer.from(csv);\r\n+};\r\n+\r\n+export const generatePDFBuffer = async (filters: any) => {\r\n+  const data = await fetchFilteredData(filters);\r\n+  const doc = new PDFDocument();\r\n+\r\n+  doc.fontSize(18).text('Gym Report', { align: 'center' }).moveDown();\r\n+\r\n+  data.forEach((entry, index) => {\r\n+    doc.fontSize(12).text(`${index + 1}. ${JSON.stringify(entry)}`);\r\n+  });\r\n+\r\n+  doc.end();\r\n+  return await getStream.buffer(doc); // Convert PDF stream to buffer\r\n+};\r\n+\r\n+const fetchFilteredData = async (filters: any) => {\r\n+  const { startDate, endDate, clubId, membershipType } = filters;\r\n+\r\n+  return await prisma.member.findMany({\r\n+    where: {\r\n+      clubId: clubId || undefined,\r\n+      membershipType: membershipType || undefined,\r\n+      createdAt: {\r\n+        gte: startDate ? new Date(startDate) : undefined,\r\n+        lte: endDate ? new Date(endDate) : undefined,\r\n+      },\r\n+    },\r\n+    include: {\r\n+      club: true,\r\n+      membership: true,\r\n+    },\r\n+  });\r\n+};\r\n"
                },
                {
                    "date": 1753118669637,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -26,11 +26,14 @@\n     doc.fontSize(12).text(`${index + 1}. ${JSON.stringify(entry)}`);\r\n   });\r\n \r\n   doc.end();\r\n-  return await getStream.buffer(doc); // Convert PDF stream to buffer\r\n+\r\n+  const getStream = (await import('get-stream')).default; // ✅ Dynamic import\r\n+  return await getStream.buffer(doc);\r\n };\r\n \r\n+\r\n const fetchFilteredData = async (filters: any) => {\r\n   const { startDate, endDate, clubId, membershipType } = filters;\r\n \r\n   return await prisma.member.findMany({\r\n"
                },
                {
                    "date": 1753118709464,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,10 +1,8 @@\n import { PrismaClient } from '@prisma/client';\r\n import { Parser } from 'json2csv';\r\n import PDFDocument from 'pdfkit';\r\n-const getStream = (await import('get-stream')).default;\r\n \r\n-\r\n const prisma = new PrismaClient();\r\n \r\n export const generateCSVBuffer = async (filters: any) => {\r\n   const data = await fetchFilteredData(filters);\r\n@@ -27,13 +25,13 @@\n   });\r\n \r\n   doc.end();\r\n \r\n-  const getStream = (await import('get-stream')).default; // ✅ Dynamic import\r\n+  // ✅ Dynamic import inside function scope\r\n+  const getStream = (await import('get-stream')).default;\r\n   return await getStream.buffer(doc);\r\n };\r\n \r\n-\r\n const fetchFilteredData = async (filters: any) => {\r\n   const { startDate, endDate, clubId, membershipType } = filters;\r\n \r\n   return await prisma.member.findMany({\r\n"
                },
                {
                    "date": 1753119446483,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,8 +6,12 @@\n \r\n export const generateCSVBuffer = async (filters: any) => {\r\n   const data = await fetchFilteredData(filters);\r\n \r\n+  if (!data.length) {\r\n+    return Buffer.from('No data found for selected filters.');\r\n+  }\r\n+\r\n   const fields = Object.keys(data[0] || {});\r\n   const parser = new Parser({ fields });\r\n   const csv = parser.parse(data);\r\n \r\n@@ -19,15 +23,19 @@\n   const doc = new PDFDocument();\r\n \r\n   doc.fontSize(18).text('Gym Report', { align: 'center' }).moveDown();\r\n \r\n-  data.forEach((entry, index) => {\r\n-    doc.fontSize(12).text(`${index + 1}. ${JSON.stringify(entry)}`);\r\n-  });\r\n+  if (!data.length) {\r\n+    doc.fontSize(14).text('No data found for selected filters.', { align: 'center' });\r\n+  } else {\r\n+    data.forEach((entry, index) => {\r\n+      doc.fontSize(12).text(`${index + 1}. ${JSON.stringify(entry)}`);\r\n+    });\r\n+  }\r\n \r\n   doc.end();\r\n \r\n-  // ✅ Dynamic import inside function scope\r\n+  // ✅ Move dynamic import *inside* the function\r\n   const getStream = (await import('get-stream')).default;\r\n   return await getStream.buffer(doc);\r\n };\r\n \r\n@@ -48,53 +56,4 @@\n       membership: true,\r\n     },\r\n   });\r\n };\r\n-import { PrismaClient } from '@prisma/client';\r\n-import { Parser } from 'json2csv';\r\n-import PDFDocument from 'pdfkit';\r\n-import getStream from 'get-stream';\r\n-\r\n-const prisma = new PrismaClient();\r\n-\r\n-export const generateCSVBuffer = async (filters: any) => {\r\n-  const data = await fetchFilteredData(filters);\r\n-\r\n-  const fields = Object.keys(data[0] || {});\r\n-  const parser = new Parser({ fields });\r\n-  const csv = parser.parse(data);\r\n-\r\n-  return Buffer.from(csv);\r\n-};\r\n-\r\n-export const generatePDFBuffer = async (filters: any) => {\r\n-  const data = await fetchFilteredData(filters);\r\n-  const doc = new PDFDocument();\r\n-\r\n-  doc.fontSize(18).text('Gym Report', { align: 'center' }).moveDown();\r\n-\r\n-  data.forEach((entry, index) => {\r\n-    doc.fontSize(12).text(`${index + 1}. ${JSON.stringify(entry)}`);\r\n-  });\r\n-\r\n-  doc.end();\r\n-  return await getStream.buffer(doc); // Convert PDF stream to buffer\r\n-};\r\n-\r\n-const fetchFilteredData = async (filters: any) => {\r\n-  const { startDate, endDate, clubId, membershipType } = filters;\r\n-\r\n-  return await prisma.member.findMany({\r\n-    where: {\r\n-      clubId: clubId || undefined,\r\n-      membershipType: membershipType || undefined,\r\n-      createdAt: {\r\n-        gte: startDate ? new Date(startDate) : undefined,\r\n-        lte: endDate ? new Date(endDate) : undefined,\r\n-      },\r\n-    },\r\n-    include: {\r\n-      club: true,\r\n-      membership: true,\r\n-    },\r\n-  });\r\n-};\r\n"
                },
                {
                    "date": 1753119543071,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -33,11 +33,30 @@\n   }\r\n \r\n   doc.end();\r\n \r\n-  // ✅ Move dynamic import *inside* the function\r\n-  const getStream = (await import('get-stream')).default;\r\n-  return await getStream.buffer(doc);\r\n+  // ✅ Correct way to handle ES module import\r\n+  try {\r\n+    const { default: getStream } = await import('get-stream');\r\n+    return await getStream.buffer(doc);\r\n+  } catch (error) {\r\n+    // Fallback method if get-stream fails\r\n+    return new Promise<Buffer>((resolve, reject) => {\r\n+      const chunks: Buffer[] = [];\r\n+      \r\n+      doc.on('data', (chunk: Buffer) => {\r\n+        chunks.push(chunk);\r\n+      });\r\n+      \r\n+      doc.on('end', () => {\r\n+        resolve(Buffer.concat(chunks));\r\n+      });\r\n+      \r\n+      doc.on('error', (err) => {\r\n+        reject(err);\r\n+      });\r\n+    });\r\n+  }\r\n };\r\n \r\n const fetchFilteredData = async (filters: any) => {\r\n   const { startDate, endDate, clubId, membershipType } = filters;\r\n@@ -55,5 +74,5 @@\n       club: true,\r\n       membership: true,\r\n     },\r\n   });\r\n-};\r\n+};\n\\ No newline at end of file\n"
                },
                {
                    "date": 1753120664946,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,78 +1,137 @@\n-import { PrismaClient } from '@prisma/client';\r\n-import { Parser } from 'json2csv';\r\n-import PDFDocument from 'pdfkit';\r\n+// src/features/settings/components/DeviceStatusPanel.tsx (Styled for Theme Consistency)\r\n+import { useEffect, useState } from 'react';\r\n+import { fetchDeviceStatuses, triggerRemoteUpdate } from '../api/settings.api';\r\n \r\n-const prisma = new PrismaClient();\r\n+interface Device {\r\n+  id: string;\r\n+  gymName: string;\r\n+  softwareVersion: string;\r\n+  bleStatus: 'active' | 'inactive';\r\n+  lastCheckIn: string;\r\n+  updateStatus: 'Up-to-date' | 'Outdated' | 'Failed';\r\n+}\r\n \r\n-export const generateCSVBuffer = async (filters: any) => {\r\n-  const data = await fetchFilteredData(filters);\r\n+export default function DeviceStatusPanel() {\r\n+  const [devices, setDevices] = useState<Device[]>([]);\r\n+  const [loading, setLoading] = useState(true); // Added loading state\r\n+  const [error, setError] = useState<string | null>(null); // Added error state\r\n+  const [updatingDeviceId, setUpdatingDeviceId] = useState<string | null>(null); // State to track which device is updating\r\n \r\n-  if (!data.length) {\r\n-    return Buffer.from('No data found for selected filters.');\r\n-  }\r\n+  useEffect(() => {\r\n+    const load = async () => {\r\n+      setLoading(true);\r\n+      setError(null);\r\n+      try {\r\n+        const res = await fetchDeviceStatuses();\r\n+        setDevices(res.data);\r\n+      } catch (err: any) {\r\n+        console.error('Failed to fetch device statuses:', err);\r\n+        setError(err.message || 'Failed to load device statuses. Please try again.');\r\n+      } finally {\r\n+        setLoading(false);\r\n+      }\r\n+    };\r\n+    load();\r\n+  }, []);\r\n \r\n-  const fields = Object.keys(data[0] || {});\r\n-  const parser = new Parser({ fields });\r\n-  const csv = parser.parse(data);\r\n+  const handleForceUpdate = async (id: string) => {\r\n+    const confirmed = window.confirm('Are you sure you want to trigger an update for this device? It will restart shortly.'); // Keeping original confirm\r\n+    if (!confirmed) return;\r\n \r\n-  return Buffer.from(csv);\r\n-};\r\n+    setUpdatingDeviceId(id); // Set the device ID being updated\r\n+    setError(null); // Clear previous errors\r\n+    try {\r\n+      await triggerRemoteUpdate(id);\r\n+      alert('Update triggered successfully! Device will restart shortly.'); // Keeping original alert\r\n+      // Optionally, re-fetch statuses after a delay to see the update status change\r\n+      setTimeout(() => {\r\n+        // This is a simplified approach. In a real app, you might poll or use websockets.\r\n+        // For now, just a delayed re-load.\r\n+        const res = fetchDeviceStatuses();\r\n+        setDevices(res.data);\r\n+      }, 5000); // Wait 5 seconds before attempting to refresh status\r\n+    } catch (err: any) {\r\n+      console.error('Error triggering update:', err);\r\n+      setError(err.message || 'Failed to trigger update. Please try again.');\r\n+    } finally {\r\n+      setUpdatingDeviceId(null); // Clear the updating state\r\n+    }\r\n+  };\r\n \r\n-export const generatePDFBuffer = async (filters: any) => {\r\n-  const data = await fetchFilteredData(filters);\r\n-  const doc = new PDFDocument();\r\n+  return (\r\n\\ No newline at end of file\n+    <div className=\"bg-white rounded-xl shadow-lg p-6 border border-beige space-y-6\"> {/* Themed container */}\r\n+      <h2 className=\"text-2xl font-bold text-navy pb-3 border-b border-beige\">Gatekeeper Device Status</h2> {/* Themed title */}\r\n \r\n-  doc.fontSize(18).text('Gym Report', { align: 'center' }).moveDown();\r\n+      {loading ? (\r\n+        <p className=\"text-center text-navy/70 text-base py-4 animate-pulse\">Loading device statuses...</p>\r\n+      ) : error ? (\r\n+        <p className=\"text-center text-jet text-base p-4 rounded-md bg-beige border border-beige\">\r\n+          Error: {error}\r\n+        </p>\r\n+      ) : devices.length === 0 ? (\r\n+        <p className=\"text-center text-jet/50 italic py-4\">No devices found.</p>\r\n+      ) : (\r\n+        <div className=\"overflow-x-auto rounded-lg shadow-md border border-beige\"> {/* Themed table container */}\r\n+          <table className=\"min-w-full divide-y divide-beige text-sm\"> {/* Themed table */}\r\n+            <thead className=\"bg-beige\"> {/* Themed table header */}\r\n+              <tr>\r\n+                <th className=\"px-4 py-3 text-left font-semibold text-navy uppercase tracking-wider\">Device ID</th>\r\n+                <th className=\"px-4 py-3 text-left font-semibold text-navy uppercase tracking-wider\">Gym</th>\r\n+                <th className=\"px-4 py-3 text-left font-semibold text-navy uppercase tracking-wider\">Version</th>\r\n+                <th className=\"px-4 py-3 text-left font-semibold text-navy uppercase tracking-wider\">BLE</th>\r\n+                <th className=\"px-4 py-3 text-left font-semibold text-navy uppercase tracking-wider\">Last Check-in</th>\r\n+                <th className=\"px-4 py-3 text-left font-semibold text-navy uppercase tracking-wider\">Update Status</th>\r\n+                <th className=\"px-4 py-3 text-left font-semibold text-navy uppercase tracking-wider\">Action</th>\r\n+              </tr>\r\n+            </thead>\r\n+            <tbody className=\"divide-y divide-beige\"> {/* Themed row divider */}\r\n+              {devices.map((device) => (\r\n+                <tr key={device.id} className=\"even:bg-cream odd:bg-white\"> {/* Alternating row colors */}\r\n+                  <td className=\"px-4 py-3 whitespace-nowrap text-jet font-medium\">{device.id}</td>\r\n+                  <td className=\"px-4 py-3 whitespace-nowrap text-jet\">{device.gymName}</td>\r\n+                  <td className=\"px-4 py-3 whitespace-nowrap text-jet\">{device.softwareVersion}</td>\r\n+                  <td className=\"px-4 py-3 whitespace-nowrap text-jet\">\r\n+                    <span\r\n+                      className={`inline-block w-2.5 h-2.5 rounded-full mr-2 ${\r\n+                        device.bleStatus === 'active' ? 'bg-navy' : 'bg-jet' // Themed status indicator\r\n+                      }`}\r\n+                    />\r\n+                    {device.bleStatus}\r\n+                  </td>\r\n+                  <td className=\"px-4 py-3 whitespace-nowrap text-jet\">\r\n+                    {new Date(device.lastCheckIn).toLocaleString()}\r\n+                  </td>\r\n+                  <td className=\"px-4 py-3 whitespace-nowrap\">\r\n+                    <span className={`font-semibold ${\r\n+                      device.updateStatus === 'Up-to-date' ? 'text-navy' : // Themed up-to-date\r\n+                      device.updateStatus === 'Outdated' ? 'text-jet' : // Themed outdated\r\n+                      'text-beige' // Themed failed/other\r\n+                    }`}>\r\n+                      {device.updateStatus}\r\n+                    </span>\r\n+                  </td>\r\n+                  <td className=\"px-4 py-3 whitespace-nowrap\">\r\n+                    <button\r\n+                      onClick={() => handleForceUpdate(device.id)}\r\n+                      className=\"text-navy hover:text-jet transition-colors duration-200 font-medium disabled:text-jet/50 disabled:cursor-not-allowed\" /* Themed button */\r\n+                      disabled={updatingDeviceId === device.id} // Disable button if this device is updating\r\n+                    >\r\n+                      {updatingDeviceId === device.id ? 'Updating...' : 'Force Update'}\r\n+                    </button>\r\n+                  </td>\r\n+                </tr>\r\n+              ))}\r\n+            </tbody>\r\n+          </table>\r\n+        </div>\r\n+      )}\r\n \r\n-  if (!data.length) {\r\n-    doc.fontSize(14).text('No data found for selected filters.', { align: 'center' });\r\n-  } else {\r\n-    data.forEach((entry, index) => {\r\n-      doc.fontSize(12).text(`${index + 1}. ${JSON.stringify(entry)}`);\r\n-    });\r\n-  }\r\n-\r\n-  doc.end();\r\n-\r\n-  // ✅ Correct way to handle ES module import\r\n-  try {\r\n-    const { default: getStream } = await import('get-stream');\r\n-    return await getStream.buffer(doc);\r\n-  } catch (error) {\r\n-    // Fallback method if get-stream fails\r\n-    return new Promise<Buffer>((resolve, reject) => {\r\n-      const chunks: Buffer[] = [];\r\n-      \r\n-      doc.on('data', (chunk: Buffer) => {\r\n-        chunks.push(chunk);\r\n-      });\r\n-      \r\n-      doc.on('end', () => {\r\n-        resolve(Buffer.concat(chunks));\r\n-      });\r\n-      \r\n-      doc.on('error', (err) => {\r\n-        reject(err);\r\n-      });\r\n-    });\r\n-  }\r\n-};\r\n-\r\n-const fetchFilteredData = async (filters: any) => {\r\n-  const { startDate, endDate, clubId, membershipType } = filters;\r\n-\r\n-  return await prisma.member.findMany({\r\n-    where: {\r\n-      clubId: clubId || undefined,\r\n-      membershipType: membershipType || undefined,\r\n-      createdAt: {\r\n-        gte: startDate ? new Date(startDate) : undefined,\r\n-        lte: endDate ? new Date(endDate) : undefined,\r\n-      },\r\n-    },\r\n-    include: {\r\n-      club: true,\r\n-      membership: true,\r\n-    },\r\n-  });\r\n-};\n+      {/* Error message for submission */}\r\n+      {error && !loading && ( // Show error if not loading\r\n+        <p className=\"text-center text-jet text-base p-3 rounded-md bg-beige border border-beige\">\r\n+          {error}\r\n+        </p>\r\n+      )}\r\n+    </div>\r\n+  );\r\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1753121168301,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,137 +1,78 @@\n-// src/features/settings/components/DeviceStatusPanel.tsx (Styled for Theme Consistency)\r\n-import { useEffect, useState } from 'react';\r\n-import { fetchDeviceStatuses, triggerRemoteUpdate } from '../api/settings.api';\r\n+import { PrismaClient } from '@prisma/client';\r\n+import { Parser } from 'json2csv';\r\n+import PDFDocument from 'pdfkit';\r\n \r\n-interface Device {\r\n-  id: string;\r\n-  gymName: string;\r\n-  softwareVersion: string;\r\n-  bleStatus: 'active' | 'inactive';\r\n-  lastCheckIn: string;\r\n-  updateStatus: 'Up-to-date' | 'Outdated' | 'Failed';\r\n-}\r\n+const prisma = new PrismaClient();\r\n \r\n-export default function DeviceStatusPanel() {\r\n-  const [devices, setDevices] = useState<Device[]>([]);\r\n-  const [loading, setLoading] = useState(true); // Added loading state\r\n-  const [error, setError] = useState<string | null>(null); // Added error state\r\n-  const [updatingDeviceId, setUpdatingDeviceId] = useState<string | null>(null); // State to track which device is updating\r\n+export const generateCSVBuffer = async (filters: any) => {\r\n+  const data = await fetchFilteredData(filters);\r\n \r\n-  useEffect(() => {\r\n-    const load = async () => {\r\n-      setLoading(true);\r\n-      setError(null);\r\n-      try {\r\n-        const res = await fetchDeviceStatuses();\r\n-        setDevices(res.data);\r\n-      } catch (err: any) {\r\n-        console.error('Failed to fetch device statuses:', err);\r\n-        setError(err.message || 'Failed to load device statuses. Please try again.');\r\n-      } finally {\r\n-        setLoading(false);\r\n-      }\r\n-    };\r\n-    load();\r\n-  }, []);\r\n+  if (!data.length) {\r\n+    return Buffer.from('No data found for selected filters.');\r\n+  }\r\n \r\n-  const handleForceUpdate = async (id: string) => {\r\n-    const confirmed = window.confirm('Are you sure you want to trigger an update for this device? It will restart shortly.'); // Keeping original confirm\r\n-    if (!confirmed) return;\r\n+  const fields = Object.keys(data[0] || {});\r\n+  const parser = new Parser({ fields });\r\n+  const csv = parser.parse(data);\r\n \r\n-    setUpdatingDeviceId(id); // Set the device ID being updated\r\n-    setError(null); // Clear previous errors\r\n-    try {\r\n-      await triggerRemoteUpdate(id);\r\n-      alert('Update triggered successfully! Device will restart shortly.'); // Keeping original alert\r\n-      // Optionally, re-fetch statuses after a delay to see the update status change\r\n-      setTimeout(() => {\r\n-        // This is a simplified approach. In a real app, you might poll or use websockets.\r\n-        // For now, just a delayed re-load.\r\n-        const res = fetchDeviceStatuses();\r\n-        setDevices(res.data);\r\n-      }, 5000); // Wait 5 seconds before attempting to refresh status\r\n-    } catch (err: any) {\r\n-      console.error('Error triggering update:', err);\r\n-      setError(err.message || 'Failed to trigger update. Please try again.');\r\n-    } finally {\r\n-      setUpdatingDeviceId(null); // Clear the updating state\r\n-    }\r\n-  };\r\n+  return Buffer.from(csv);\r\n+};\r\n \r\n-  return (\r\n-    <div className=\"bg-white rounded-xl shadow-lg p-6 border border-beige space-y-6\"> {/* Themed container */}\r\n-      <h2 className=\"text-2xl font-bold text-navy pb-3 border-b border-beige\">Gatekeeper Device Status</h2> {/* Themed title */}\r\n+export const generatePDFBuffer = async (filters: any) => {\r\n+  const data = await fetchFilteredData(filters);\r\n+  const doc = new PDFDocument();\r\n \r\n-      {loading ? (\r\n-        <p className=\"text-center text-navy/70 text-base py-4 animate-pulse\">Loading device statuses...</p>\r\n-      ) : error ? (\r\n-        <p className=\"text-center text-jet text-base p-4 rounded-md bg-beige border border-beige\">\r\n-          Error: {error}\r\n-        </p>\r\n-      ) : devices.length === 0 ? (\r\n-        <p className=\"text-center text-jet/50 italic py-4\">No devices found.</p>\r\n-      ) : (\r\n-        <div className=\"overflow-x-auto rounded-lg shadow-md border border-beige\"> {/* Themed table container */}\r\n-          <table className=\"min-w-full divide-y divide-beige text-sm\"> {/* Themed table */}\r\n-            <thead className=\"bg-beige\"> {/* Themed table header */}\r\n-              <tr>\r\n-                <th className=\"px-4 py-3 text-left font-semibold text-navy uppercase tracking-wider\">Device ID</th>\r\n-                <th className=\"px-4 py-3 text-left font-semibold text-navy uppercase tracking-wider\">Gym</th>\r\n-                <th className=\"px-4 py-3 text-left font-semibold text-navy uppercase tracking-wider\">Version</th>\r\n-                <th className=\"px-4 py-3 text-left font-semibold text-navy uppercase tracking-wider\">BLE</th>\r\n-                <th className=\"px-4 py-3 text-left font-semibold text-navy uppercase tracking-wider\">Last Check-in</th>\r\n-                <th className=\"px-4 py-3 text-left font-semibold text-navy uppercase tracking-wider\">Update Status</th>\r\n-                <th className=\"px-4 py-3 text-left font-semibold text-navy uppercase tracking-wider\">Action</th>\r\n-              </tr>\r\n-            </thead>\r\n-            <tbody className=\"divide-y divide-beige\"> {/* Themed row divider */}\r\n-              {devices.map((device) => (\r\n-                <tr key={device.id} className=\"even:bg-cream odd:bg-white\"> {/* Alternating row colors */}\r\n-                  <td className=\"px-4 py-3 whitespace-nowrap text-jet font-medium\">{device.id}</td>\r\n-                  <td className=\"px-4 py-3 whitespace-nowrap text-jet\">{device.gymName}</td>\r\n-                  <td className=\"px-4 py-3 whitespace-nowrap text-jet\">{device.softwareVersion}</td>\r\n-                  <td className=\"px-4 py-3 whitespace-nowrap text-jet\">\r\n-                    <span\r\n-                      className={`inline-block w-2.5 h-2.5 rounded-full mr-2 ${\r\n-                        device.bleStatus === 'active' ? 'bg-navy' : 'bg-jet' // Themed status indicator\r\n-                      }`}\r\n-                    />\r\n-                    {device.bleStatus}\r\n-                  </td>\r\n-                  <td className=\"px-4 py-3 whitespace-nowrap text-jet\">\r\n-                    {new Date(device.lastCheckIn).toLocaleString()}\r\n-                  </td>\r\n-                  <td className=\"px-4 py-3 whitespace-nowrap\">\r\n-                    <span className={`font-semibold ${\r\n-                      device.updateStatus === 'Up-to-date' ? 'text-navy' : // Themed up-to-date\r\n-                      device.updateStatus === 'Outdated' ? 'text-jet' : // Themed outdated\r\n-                      'text-beige' // Themed failed/other\r\n-                    }`}>\r\n-                      {device.updateStatus}\r\n-                    </span>\r\n-                  </td>\r\n-                  <td className=\"px-4 py-3 whitespace-nowrap\">\r\n-                    <button\r\n-                      onClick={() => handleForceUpdate(device.id)}\r\n-                      className=\"text-navy hover:text-jet transition-colors duration-200 font-medium disabled:text-jet/50 disabled:cursor-not-allowed\" /* Themed button */\r\n-                      disabled={updatingDeviceId === device.id} // Disable button if this device is updating\r\n-                    >\r\n-                      {updatingDeviceId === device.id ? 'Updating...' : 'Force Update'}\r\n-                    </button>\r\n\\ No newline at end of file\n-                  </td>\r\n-                </tr>\r\n-              ))}\r\n-            </tbody>\r\n-          </table>\r\n-        </div>\r\n-      )}\r\n+  doc.fontSize(18).text('Gym Report', { align: 'center' }).moveDown();\r\n \r\n-      {/* Error message for submission */}\r\n-      {error && !loading && ( // Show error if not loading\r\n-        <p className=\"text-center text-jet text-base p-3 rounded-md bg-beige border border-beige\">\r\n-          {error}\r\n-        </p>\r\n-      )}\r\n-    </div>\r\n-  );\r\n-}\n+  if (!data.length) {\r\n+    doc.fontSize(14).text('No data found for selected filters.', { align: 'center' });\r\n+  } else {\r\n+    data.forEach((entry, index) => {\r\n+      doc.fontSize(12).text(`${index + 1}. ${JSON.stringify(entry)}`);\r\n+    });\r\n+  }\r\n+\r\n+  doc.end();\r\n+\r\n+  // ✅ Correct way to handle ES module import\r\n+  try {\r\n+    const { default: getStream } = await import('get-stream');\r\n+    return await getStream.buffer(doc);\r\n+  } catch (error) {\r\n+    // Fallback method if get-stream fails\r\n+    return new Promise<Buffer>((resolve, reject) => {\r\n+      const chunks: Buffer[] = [];\r\n+      \r\n+      doc.on('data', (chunk: Buffer) => {\r\n+        chunks.push(chunk);\r\n+      });\r\n+      \r\n+      doc.on('end', () => {\r\n+        resolve(Buffer.concat(chunks));\r\n+      });\r\n+      \r\n+      doc.on('error', (err) => {\r\n+        reject(err);\r\n+      });\r\n+    });\r\n+  }\r\n+};\r\n+\r\n+const fetchFilteredData = async (filters: any) => {\r\n+  const { startDate, endDate, clubId, membershipType } = filters;\r\n+\r\n+  return await prisma.member.findMany({\r\n+    where: {\r\n+      clubId: clubId || undefined,\r\n+      membershipType: membershipType || undefined,\r\n+      createdAt: {\r\n+        gte: startDate ? new Date(startDate) : undefined,\r\n+        lte: endDate ? new Date(endDate) : undefined,\r\n+      },\r\n+    },\r\n+    include: {\r\n+      club: true,\r\n+      membership: true,\r\n+    },\r\n+  });\r\n+};\n\\ No newline at end of file\n"
                }
            ],
            "date": 1753118436059,
            "name": "Commit-0",
            "content": "import { PrismaClient } from '@prisma/client';\r\nimport { Parser } from 'json2csv';\r\nimport PDFDocument from 'pdfkit';\r\nimport getStream from 'get-stream';\r\n\r\nconst prisma = new PrismaClient();\r\n\r\nexport const generateCSVBuffer = async (filters: any) => {\r\n  const data = await fetchFilteredData(filters);\r\n\r\n  const fields = Object.keys(data[0] || {});\r\n  const parser = new Parser({ fields });\r\n  const csv = parser.parse(data);\r\n\r\n  return Buffer.from(csv);\r\n};\r\n\r\nexport const generatePDFBuffer = async (filters: any) => {\r\n  const data = await fetchFilteredData(filters);\r\n  const doc = new PDFDocument();\r\n\r\n  doc.fontSize(18).text('Gym Report', { align: 'center' }).moveDown();\r\n\r\n  data.forEach((entry, index) => {\r\n    doc.fontSize(12).text(`${index + 1}. ${JSON.stringify(entry)}`);\r\n  });\r\n\r\n  doc.end();\r\n  return await getStream.buffer(doc); // Convert PDF stream to buffer\r\n};\r\n\r\nconst fetchFilteredData = async (filters: any) => {\r\n  const { startDate, endDate, clubId, membershipType } = filters;\r\n\r\n  return await prisma.member.findMany({\r\n    where: {\r\n      clubId: clubId || undefined,\r\n      membershipType: membershipType || undefined,\r\n      createdAt: {\r\n        gte: startDate ? new Date(startDate) : undefined,\r\n        lte: endDate ? new Date(endDate) : undefined,\r\n      },\r\n    },\r\n    include: {\r\n      club: true,\r\n      membership: true,\r\n    },\r\n  });\r\n};\r\n"
        }
    ]
}