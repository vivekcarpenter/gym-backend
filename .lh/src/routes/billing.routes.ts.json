{
    "sourceFile": "src/routes/billing.routes.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 48,
            "patches": [
                {
                    "date": 1752358300670,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1752359693987,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,4 +1,5 @@\n+//src/routes/billing.routes.ts\r\n import express from 'express';\r\n import { PrismaClient } from '@prisma/client';\r\n import { Request, Response } from 'express';\r\n \r\n@@ -9,19 +10,22 @@\n   try {\r\n     const { memberId } = req.params;\r\n     const { cardNumber, expiry, cvc } = req.body;\r\n \r\n-    // ðŸ”§ fake parsing for local storage (replace with Stripe integration later)\r\n     const last4 = cardNumber.slice(-4);\r\n-    const [expMonth, expYear] = expiry.split('/');\r\n+    const [expMonthStr, expYearStr] = expiry.split('/');\r\n \r\n+    const brand = 'visa'; // placeholder â€” you'd detect brand in real Stripe integration\r\n+    const stripePaymentMethodId = `fake_${Math.random().toString(36).substring(2, 10)}`; // mock ID\r\n+\r\n     const method = await prisma.paymentMethod.create({\r\n       data: {\r\n         memberId,\r\n-        cardBrand: 'visa',\r\n+        stripePaymentMethodId,\r\n+        cardBrand: brand,\r\n         last4,\r\n-        expMonth: parseInt(expMonth),\r\n-        expYear: parseInt(`20${expYear}`),\r\n+        expMonth: parseInt(expMonthStr),\r\n+        expYear: parseInt('20' + expYearStr), // e.g., 25 -> 2025\r\n       },\r\n     });\r\n \r\n     res.status(201).json(method);\r\n"
                },
                {
                    "date": 1752360136398,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -33,4 +33,6 @@\n     console.error('Save Payment Method Error:', err);\r\n     res.status(500).json({ error: 'Failed to save payment method' });\r\n   }\r\n });\r\n+\r\n+export default router; \r\n"
                },
                {
                    "date": 1752360435084,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -34,5 +34,33 @@\n     res.status(500).json({ error: 'Failed to save payment method' });\r\n   }\r\n });\r\n \r\n+router.get('/:memberId', async (req: Request, res: Response) => {\r\n+  const { memberId } = req.params;\r\n+\r\n+  try {\r\n+    const member = await prisma.member.findUnique({\r\n+      where: { id: memberId },\r\n+      include: {\r\n+        paymentMethod: true,\r\n+        // If you add invoice model later, include it here too\r\n+        // invoices: true,\r\n+      },\r\n+    });\r\n+\r\n+    if (!member) {\r\n+      return res.status(404).json({ error: 'Member not found' });\r\n+    }\r\n+\r\n+    res.json({\r\n+      paymentMethod: member.paymentMethod,\r\n+      invoices: [], // Temporary â€” until invoices are added\r\n+    });\r\n+  } catch (err) {\r\n+    console.error('Fetch billing error:', err);\r\n+    res.status(500).json({ error: 'Failed to fetch billing data' });\r\n+  }\r\n+});\r\n+\r\n+\r\n export default router; \r\n"
                },
                {
                    "date": 1752373112927,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -62,5 +62,22 @@\n   }\r\n });\r\n \r\n \r\n+router.get('/:memberId', async (req, res) => {\r\n+  const { memberId } = req.params;\r\n+\r\n+  try {\r\n+    const [paymentMethod, invoices] = await Promise.all([\r\n+      prisma.paymentMethod.findUnique({ where: { memberId } }),\r\n+      prisma.invoice.findMany({ where: { memberId }, orderBy: { issuedAt: 'desc' } }),\r\n+    ]);\r\n+\r\n+    res.json({ paymentMethod, invoices });\r\n+  } catch (err) {\r\n+    console.error('Billing fetch error:', err);\r\n+    res.status(500).json({ error: 'Failed to load billing data' });\r\n+  }\r\n+});\r\n+\r\n+\r\n export default router; \r\n"
                },
                {
                    "date": 1752373264608,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -63,21 +63,26 @@\n });\r\n \r\n \r\n router.get('/:memberId', async (req, res) => {\r\n-  const { memberId } = req.params;\r\n-\r\n   try {\r\n-    const [paymentMethod, invoices] = await Promise.all([\r\n-      prisma.paymentMethod.findUnique({ where: { memberId } }),\r\n-      prisma.invoice.findMany({ where: { memberId }, orderBy: { issuedAt: 'desc' } }),\r\n-    ]);\r\n+    const { memberId } = req.params;\r\n \r\n+    const paymentMethod = await prisma.paymentMethod.findUnique({\r\n+      where: { memberId },\r\n+    });\r\n+\r\n+    const invoices = await prisma.invoice.findMany({\r\n+      where: { memberId },\r\n+      orderBy: { issuedAt: 'desc' },\r\n+    });\r\n+\r\n     res.json({ paymentMethod, invoices });\r\n   } catch (err) {\r\n-    console.error('Billing fetch error:', err);\r\n-    res.status(500).json({ error: 'Failed to load billing data' });\r\n+    console.error('Fetch billing error:', err);\r\n+    res.status(500).json({ error: 'Failed to fetch billing data' });\r\n   }\r\n });\r\n \r\n \r\n+\r\n export default router; \r\n"
                },
                {
                    "date": 1752373378556,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,106 @@\n+//src/routes/billing.routes.ts\r\n+import express from 'express';\r\n+import { PrismaClient } from '@prisma/client';\r\n+import { Request, Response } from 'express';\r\n+\r\n+const router = express.Router();\r\n+const prisma = new PrismaClient();\r\n+\r\n+router.post('/:memberId/payment-method', async (req, res) => {\r\n+  try {\r\n+    const { memberId } = req.params;\r\n+    const { cardNumber, expiry, cvc } = req.body;\r\n+\r\n+    const last4 = cardNumber.slice(-4);\r\n+    const [expMonthStr, expYearStr] = expiry.split('/');\r\n+\r\n+    const brand = 'visa'; // placeholder â€” you'd detect brand in real Stripe integration\r\n+    const stripePaymentMethodId = `fake_${Math.random().toString(36).substring(2, 10)}`; // mock ID\r\n+\r\n+    const method = await prisma.paymentMethod.create({\r\n+      data: {\r\n+        memberId,\r\n+        stripePaymentMethodId,\r\n+        cardBrand: brand,\r\n+        last4,\r\n+        expMonth: parseInt(expMonthStr),\r\n+        expYear: parseInt('20' + expYearStr), // e.g., 25 -> 2025\r\n+      },\r\n+    });\r\n+\r\n+    res.status(201).json(method);\r\n+  } catch (err) {\r\n+    console.error('Save Payment Method Error:', err);\r\n+    res.status(500).json({ error: 'Failed to save payment method' });\r\n+  }\r\n+});\r\n+\r\n+router.get('/:memberId', async (req: Request, res: Response) => {\r\n+  const { memberId } = req.params;\r\n+\r\n+  try {\r\n+    const member = await prisma.member.findUnique({\r\n+      where: { id: memberId },\r\n+      include: {\r\n+        paymentMethod: true,\r\n+        // If you add invoice model later, include it here too\r\n+        // invoices: true,\r\n+      },\r\n+    });\r\n+\r\n+    if (!member) {\r\n+      return res.status(404).json({ error: 'Member not found' });\r\n+    }\r\n+\r\n+    res.json({\r\n+      paymentMethod: member.paymentMethod,\r\n+      invoices: [], // Temporary â€” until invoices are added\r\n+    });\r\n+  } catch (err) {\r\n+    console.error('Fetch billing error:', err);\r\n+    res.status(500).json({ error: 'Failed to fetch billing data' });\r\n+  }\r\n+});\r\n+\r\n+\r\n+router.get('/:memberId', async (req, res) => {\r\n+  try {\r\n+    const { memberId } = req.params;\r\n+\r\n+    const paymentMethod = await prisma.paymentMethod.findUnique({\r\n+      where: { memberId },\r\n+    });\r\n+\r\n+    const invoices = await prisma.invoice.findMany({\r\n+      where: { memberId },\r\n+      orderBy: { issuedAt: 'desc' },\r\n+    });\r\n+\r\n+    res.json({ paymentMethod, invoices });\r\n+  } catch (err) {\r\n+    console.error('Fetch billing error:', err);\r\n+    res.status(500).json({ error: 'Failed to fetch billing data' });\r\n+  }\r\n+});\r\n+\r\n+// PATCH /api/billing/invoices/:id/pay\r\n+router.patch('/invoices/:id/pay', async (req, res) => {\r\n+  try {\r\n+    const { id } = req.params;\r\n+\r\n+    const invoice = await prisma.invoice.update({\r\n+      where: { id },\r\n+      data: { status: 'paid' },\r\n+    });\r\n+\r\n+    res.json(invoice);\r\n+  } catch (err) {\r\n+    console.error('Invoice payment error:', err);\r\n+    res.status(500).json({ error: 'Failed to mark invoice as paid' });\r\n+  }\r\n+});\r\n+\r\n+\r\n+\r\n+\r\n+export default router; \r\n"
                },
                {
                    "date": 1752375680523,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -34,34 +34,34 @@\n     res.status(500).json({ error: 'Failed to save payment method' });\r\n   }\r\n });\r\n \r\n-router.get('/:memberId', async (req: Request, res: Response) => {\r\n-  const { memberId } = req.params;\r\n+// router.get('/:memberId', async (req: Request, res: Response) => {\r\n+//   const { memberId } = req.params;\r\n \r\n-  try {\r\n-    const member = await prisma.member.findUnique({\r\n-      where: { id: memberId },\r\n-      include: {\r\n-        paymentMethod: true,\r\n-        // If you add invoice model later, include it here too\r\n-        // invoices: true,\r\n-      },\r\n-    });\r\n+//   try {\r\n+//     const member = await prisma.member.findUnique({\r\n+//       where: { id: memberId },\r\n+//       include: {\r\n+//         paymentMethod: true,\r\n+//         // If you add invoice model later, include it here too\r\n+//         // invoices: true,\r\n+//       },\r\n+//     });\r\n \r\n-    if (!member) {\r\n-      return res.status(404).json({ error: 'Member not found' });\r\n-    }\r\n+//     if (!member) {\r\n+//       return res.status(404).json({ error: 'Member not found' });\r\n+//     }\r\n \r\n-    res.json({\r\n-      paymentMethod: member.paymentMethod,\r\n-      invoices: [], // Temporary â€” until invoices are added\r\n-    });\r\n-  } catch (err) {\r\n-    console.error('Fetch billing error:', err);\r\n-    res.status(500).json({ error: 'Failed to fetch billing data' });\r\n-  }\r\n-});\r\n+//     res.json({\r\n+//       paymentMethod: member.paymentMethod,\r\n+//       invoices: [], // Temporary â€” until invoices are added\r\n+//     });\r\n+//   } catch (err) {\r\n+//     console.error('Fetch billing error:', err);\r\n+//     res.status(500).json({ error: 'Failed to fetch billing data' });\r\n+//   }\r\n+// });\r\n \r\n \r\n router.get('/:memberId', async (req, res) => {\r\n   try {\r\n@@ -103,92 +103,4 @@\n \r\n \r\n \r\n export default router; \r\n-//src/routes/billing.routes.ts\r\n-import express from 'express';\r\n-import { PrismaClient } from '@prisma/client';\r\n-import { Request, Response } from 'express';\r\n-\r\n-const router = express.Router();\r\n-const prisma = new PrismaClient();\r\n-\r\n-router.post('/:memberId/payment-method', async (req, res) => {\r\n-  try {\r\n-    const { memberId } = req.params;\r\n-    const { cardNumber, expiry, cvc } = req.body;\r\n-\r\n-    const last4 = cardNumber.slice(-4);\r\n-    const [expMonthStr, expYearStr] = expiry.split('/');\r\n-\r\n-    const brand = 'visa'; // placeholder â€” you'd detect brand in real Stripe integration\r\n-    const stripePaymentMethodId = `fake_${Math.random().toString(36).substring(2, 10)}`; // mock ID\r\n-\r\n-    const method = await prisma.paymentMethod.create({\r\n-      data: {\r\n-        memberId,\r\n-        stripePaymentMethodId,\r\n-        cardBrand: brand,\r\n-        last4,\r\n-        expMonth: parseInt(expMonthStr),\r\n-        expYear: parseInt('20' + expYearStr), // e.g., 25 -> 2025\r\n-      },\r\n-    });\r\n-\r\n-    res.status(201).json(method);\r\n-  } catch (err) {\r\n-    console.error('Save Payment Method Error:', err);\r\n-    res.status(500).json({ error: 'Failed to save payment method' });\r\n-  }\r\n-});\r\n-\r\n-router.get('/:memberId', async (req: Request, res: Response) => {\r\n-  const { memberId } = req.params;\r\n-\r\n-  try {\r\n-    const member = await prisma.member.findUnique({\r\n-      where: { id: memberId },\r\n-      include: {\r\n-        paymentMethod: true,\r\n-        // If you add invoice model later, include it here too\r\n-        // invoices: true,\r\n-      },\r\n-    });\r\n-\r\n-    if (!member) {\r\n-      return res.status(404).json({ error: 'Member not found' });\r\n-    }\r\n-\r\n-    res.json({\r\n-      paymentMethod: member.paymentMethod,\r\n-      invoices: [], // Temporary â€” until invoices are added\r\n-    });\r\n-  } catch (err) {\r\n-    console.error('Fetch billing error:', err);\r\n-    res.status(500).json({ error: 'Failed to fetch billing data' });\r\n-  }\r\n-});\r\n-\r\n-\r\n-router.get('/:memberId', async (req, res) => {\r\n-  try {\r\n-    const { memberId } = req.params;\r\n-\r\n-    const paymentMethod = await prisma.paymentMethod.findUnique({\r\n-      where: { memberId },\r\n-    });\r\n-\r\n-    const invoices = await prisma.invoice.findMany({\r\n-      where: { memberId },\r\n-      orderBy: { issuedAt: 'desc' },\r\n-    });\r\n-\r\n-    res.json({ paymentMethod, invoices });\r\n-  } catch (err) {\r\n-    console.error('Fetch billing error:', err);\r\n-    res.status(500).json({ error: 'Failed to fetch billing data' });\r\n-  }\r\n-});\r\n-\r\n-\r\n-\r\n-export default router; \r\n"
                },
                {
                    "date": 1752508330574,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -100,7 +100,46 @@\n   }\r\n });\r\n \r\n \r\n+//to get all \r\n+router.get('/', async (req, res) => {\r\n+  const { clubId, startDate, endDate, type } = req.query;\r\n \r\n+  try {\r\n+    const invoices = await prisma.invoice.findMany({\r\n+      where: {\r\n+        clubId: String(clubId),\r\n+        issuedAt: {\r\n+          gte: startDate ? new Date(String(startDate)) : undefined,\r\n+          lte: endDate ? new Date(String(endDate)) : undefined,\r\n+        },\r\n+        ...(type && { member: { membershipType: String(type) } }),\r\n+      },\r\n+      include: {\r\n+        member: true,\r\n+      },\r\n+      orderBy: { issuedAt: 'desc' },\r\n+    });\r\n \r\n+    const response = invoices.map(inv => ({\r\n+      id: inv.id,\r\n+      memberName: `${inv.member.firstName} ${inv.member.lastName}`,\r\n+      amount: inv.amount,\r\n+      status: inv.status,\r\n+      issuedAt: inv.issuedAt,\r\n+      dueDate: inv.dueDate,\r\n+    }));\r\n+\r\n+    res.json(response);\r\n+  } catch (err) {\r\n+    console.error('Error fetching billing data:', err);\r\n+    res.status(500).json({ error: 'Internal server error' });\r\n+  }\r\n+});\r\n+\r\n+export default router;\r\n+\r\n+\r\n+\r\n+\r\n export default router; \r\n"
                },
                {
                    "date": 1752508346165,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -141,5 +141,5 @@\n \r\n \r\n \r\n \r\n-export default router; \r\n+\r\n"
                },
                {
                    "date": 1752508739105,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -104,8 +104,10 @@\n //to get all \r\n router.get('/', async (req, res) => {\r\n   const { clubId, startDate, endDate, type } = req.query;\r\n \r\n+  if (!clubId) return res.status(400).json({ error: 'Missing clubId' });\r\n+\r\n   try {\r\n     const invoices = await prisma.invoice.findMany({\r\n       where: {\r\n         clubId: String(clubId),\r\n@@ -114,10 +116,12 @@\n           lte: endDate ? new Date(String(endDate)) : undefined,\r\n         },\r\n         ...(type && { member: { membershipType: String(type) } }),\r\n       },\r\n-      include: {\r\n-        member: true,\r\n+     include: {\r\n+        member: {\r\n+          select: { firstName: true, lastName: true },\r\n+        },\r\n       },\r\n       orderBy: { issuedAt: 'desc' },\r\n     });\r\n \r\n"
                },
                {
                    "date": 1752529950236,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -140,8 +140,49 @@\n     res.status(500).json({ error: 'Internal server error' });\r\n   }\r\n });\r\n \r\n+router.get('/summary', async (req, res) => {\r\n+  const { clubId, startDate, endDate } = req.query;\r\n+\r\n+  if (!clubId) return res.status(400).json({ error: 'Missing clubId' });\r\n+\r\n+  try {\r\n+    const filters = {\r\n+      clubId: String(clubId),\r\n+      issuedAt: {\r\n+        gte: startDate ? new Date(String(startDate)) : undefined,\r\n+        lte: endDate ? new Date(String(endDate)) : undefined,\r\n+      },\r\n+    };\r\n+\r\n+    const [totalRevenue, unpaidDues, activeMembers] = await Promise.all([\r\n+      prisma.invoice.aggregate({\r\n+        where: { ...filters, status: 'paid' },\r\n+        _sum: { amount: true },\r\n+      }),\r\n+      prisma.invoice.aggregate({\r\n+        where: { ...filters, status: { in: ['unpaid', 'overdue', 'failed'] } },\r\n+        _sum: { amount: true },\r\n+      }),\r\n+      prisma.member.count({\r\n+        where: { clubId: String(clubId), memberType: 'member' },\r\n+      }),\r\n+    ]);\r\n+\r\n+    res.json({\r\n+      totalRevenue: totalRevenue._sum.amount ?? 0,\r\n+      unpaidDues: unpaidDues._sum.amount ?? 0,\r\n+      activeMembers,\r\n+      attendanceRate: 78, // placeholder until real logic exists\r\n+    });\r\n+  } catch (err) {\r\n+    console.error('Summary error:', err);\r\n+    res.status(500).json({ error: 'Failed to calculate summary' });\r\n+  }\r\n+});\r\n+\r\n+\r\n export default router;\r\n \r\n \r\n \r\n"
                },
                {
                    "date": 1752530479949,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -180,9 +180,39 @@\n     res.status(500).json({ error: 'Failed to calculate summary' });\r\n   }\r\n });\r\n \r\n+// GET /api/billing/members?clubId=...&membershipType=...\r\n+router.get('/members', async (req, res) => {\r\n+  const { clubId, membershipType } = req.query;\r\n \r\n+  if (!clubId) return res.status(400).json({ error: 'Missing clubId' });\r\n+\r\n+  try {\r\n+    const members = await prisma.member.findMany({\r\n+      where: {\r\n+        clubId: String(clubId),\r\n+        ...(membershipType && { memberType: String(membershipType) }),\r\n+      },\r\n+      select: {\r\n+        id: true,\r\n+        firstName: true,\r\n+        lastName: true,\r\n+        memberType: true,\r\n+        createdAt: true,\r\n+      },\r\n+      orderBy: { createdAt: 'desc' },\r\n+    });\r\n+\r\n+    res.json(members);\r\n+  } catch (err) {\r\n+    console.error('Membership Report fetch error:', err);\r\n+    res.status(500).json({ error: 'Failed to fetch membership report' });\r\n+  }\r\n+});\r\n+\r\n+\r\n+\r\n export default router;\r\n \r\n \r\n \r\n"
                },
                {
                    "date": 1752530760661,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -180,39 +180,39 @@\n     res.status(500).json({ error: 'Failed to calculate summary' });\r\n   }\r\n });\r\n \r\n-// GET /api/billing/members?clubId=...&membershipType=...\r\n router.get('/members', async (req, res) => {\r\n   const { clubId, membershipType } = req.query;\r\n \r\n-  if (!clubId) return res.status(400).json({ error: 'Missing clubId' });\r\n+  if (!clubId) {\r\n+    return res.status(400).json({ error: 'clubId is required' });\r\n+  }\r\n \r\n   try {\r\n     const members = await prisma.member.findMany({\r\n       where: {\r\n         clubId: String(clubId),\r\n         ...(membershipType && { memberType: String(membershipType) }),\r\n       },\r\n-      select: {\r\n-        id: true,\r\n-        firstName: true,\r\n-        lastName: true,\r\n-        memberType: true,\r\n-        createdAt: true,\r\n-      },\r\n       orderBy: { createdAt: 'desc' },\r\n     });\r\n \r\n-    res.json(members);\r\n+    const response = members.map((m) => ({\r\n+      id: m.id,\r\n+      firstName: m.firstName,\r\n+      lastName: m.lastName,\r\n+      memberType: m.memberType,\r\n+      createdAt: m.createdAt,\r\n+    }));\r\n+\r\n+    res.json(response);\r\n   } catch (err) {\r\n-    console.error('Membership Report fetch error:', err);\r\n-    res.status(500).json({ error: 'Failed to fetch membership report' });\r\n+    console.error('Fetch members error:', err);\r\n+    res.status(500).json({ error: 'Failed to fetch members' });\r\n   }\r\n });\r\n \r\n-\r\n-\r\n export default router;\r\n \r\n \r\n \r\n"
                },
                {
                    "date": 1753044713614,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -211,8 +211,40 @@\n     res.status(500).json({ error: 'Failed to fetch members' });\r\n   }\r\n });\r\n \r\n+// GET /api/billing/recent?limit=5\r\n+router.get('/recent', async (req, res) => {\r\n+  const limit = parseInt(req.query.limit as string) || 5;\r\n+\r\n+  try {\r\n+    const invoices = await prisma.invoice.findMany({\r\n+      orderBy: { issuedAt: 'desc' },\r\n+      take: limit,\r\n+      include: {\r\n+        member: {\r\n+          select: { firstName: true, lastName: true },\r\n+        },\r\n+      },\r\n+    });\r\n+\r\n+    const result = invoices.map((inv) => ({\r\n+      id: inv.id,\r\n+      memberName: `${inv.member.firstName} ${inv.member.lastName}`,\r\n+      amount: inv.amount,\r\n+      status: inv.status,\r\n+      issuedAt: inv.issuedAt,\r\n+      dueDate: inv.dueDate,\r\n+    }));\r\n+\r\n+    res.json(result);\r\n+  } catch (err) {\r\n+    console.error('Error fetching recent invoices:', err);\r\n+    res.status(500).json({ error: 'Internal server error' });\r\n+  }\r\n+});\r\n+\r\n+\r\n export default router;\r\n \r\n \r\n \r\n"
                },
                {
                    "date": 1753069413256,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,8 +5,12 @@\n \r\n const router = express.Router();\r\n const prisma = new PrismaClient();\r\n \r\n+\r\n+\r\n+\r\n+\r\n router.post('/:memberId/payment-method', async (req, res) => {\r\n   try {\r\n     const { memberId } = req.params;\r\n     const { cardNumber, expiry, cvc } = req.body;\r\n@@ -34,9 +38,9 @@\n     res.status(500).json({ error: 'Failed to save payment method' });\r\n   }\r\n });\r\n \r\n-// router.get('/:memberId', async (req: Request, res: Response) => {\r\n+\r\n //   const { memberId } = req.params;\r\n \r\n //   try {\r\n //     const member = await prisma.member.findUnique({\r\n@@ -62,8 +66,40 @@\n //   }\r\n // });\r\n \r\n \r\n+\r\n+// GET /api/billing/recent?limit=5\r\n+router.get('/recent', async (req, res) => {\r\n+  const limit = parseInt(req.query.limit as string) || 5;\r\n+\r\n+  try {\r\n+    const invoices = await prisma.invoice.findMany({\r\n+      orderBy: { issuedAt: 'desc' },\r\n+      take: limit,\r\n+      include: {\r\n+        member: {\r\n+          select: { firstName: true, lastName: true },\r\n+        },\r\n+      },\r\n+    });\r\n+\r\n+    const result = invoices.map((inv) => ({\r\n+      id: inv.id,\r\n+      memberName: `${inv.member.firstName} ${inv.member.lastName}`,\r\n+      amount: inv.amount,\r\n+      status: inv.status,\r\n+      issuedAt: inv.issuedAt,\r\n+      dueDate: inv.dueDate,\r\n+    }));\r\n+\r\n+    res.json(result);\r\n+  } catch (err) {\r\n+    console.error('Error fetching recent invoices:', err);\r\n+    res.status(500).json({ error: 'Internal server error' });\r\n+  }\r\n+});\r\n+\r\n router.get('/:memberId', async (req, res) => {\r\n   try {\r\n     const { memberId } = req.params;\r\n \r\n@@ -211,40 +247,11 @@\n     res.status(500).json({ error: 'Failed to fetch members' });\r\n   }\r\n });\r\n \r\n-// GET /api/billing/recent?limit=5\r\n-router.get('/recent', async (req, res) => {\r\n-  const limit = parseInt(req.query.limit as string) || 5;\r\n \r\n-  try {\r\n-    const invoices = await prisma.invoice.findMany({\r\n-      orderBy: { issuedAt: 'desc' },\r\n-      take: limit,\r\n-      include: {\r\n-        member: {\r\n-          select: { firstName: true, lastName: true },\r\n-        },\r\n-      },\r\n-    });\r\n \r\n-    const result = invoices.map((inv) => ({\r\n-      id: inv.id,\r\n-      memberName: `${inv.member.firstName} ${inv.member.lastName}`,\r\n-      amount: inv.amount,\r\n-      status: inv.status,\r\n-      issuedAt: inv.issuedAt,\r\n-      dueDate: inv.dueDate,\r\n-    }));\r\n \r\n-    res.json(result);\r\n-  } catch (err) {\r\n-    console.error('Error fetching recent invoices:', err);\r\n-    res.status(500).json({ error: 'Internal server error' });\r\n-  }\r\n-});\r\n-\r\n-\r\n export default router;\r\n \r\n \r\n \r\n"
                },
                {
                    "date": 1753069491218,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -98,8 +98,49 @@\n     res.status(500).json({ error: 'Internal server error' });\r\n   }\r\n });\r\n \r\n+router.get('/summary', async (req, res) => {\r\n+  const { clubId, startDate, endDate } = req.query;\r\n+\r\n+  if (!clubId) return res.status(400).json({ error: 'Missing clubId' });\r\n+\r\n+  try {\r\n+    const filters = {\r\n+      clubId: String(clubId),\r\n+      issuedAt: {\r\n+        gte: startDate ? new Date(String(startDate)) : undefined,\r\n+        lte: endDate ? new Date(String(endDate)) : undefined,\r\n+      },\r\n+    };\r\n+\r\n+    const [totalRevenue, unpaidDues, activeMembers] = await Promise.all([\r\n+      prisma.invoice.aggregate({\r\n+        where: { ...filters, status: 'paid' },\r\n+        _sum: { amount: true },\r\n+      }),\r\n+      prisma.invoice.aggregate({\r\n+        where: { ...filters, status: { in: ['unpaid', 'overdue', 'failed'] } },\r\n+        _sum: { amount: true },\r\n+      }),\r\n+      prisma.member.count({\r\n+        where: { clubId: String(clubId), memberType: 'member' },\r\n+      }),\r\n+    ]);\r\n+\r\n+    res.json({\r\n+      totalRevenue: totalRevenue._sum.amount ?? 0,\r\n+      unpaidDues: unpaidDues._sum.amount ?? 0,\r\n+      activeMembers,\r\n+      attendanceRate: 78, // placeholder until real logic exists\r\n+    });\r\n+  } catch (err) {\r\n+    console.error('Summary error:', err);\r\n+    res.status(500).json({ error: 'Failed to calculate summary' });\r\n+  }\r\n+});\r\n+\r\n+\r\n router.get('/:memberId', async (req, res) => {\r\n   try {\r\n     const { memberId } = req.params;\r\n \r\n@@ -176,48 +217,9 @@\n     res.status(500).json({ error: 'Internal server error' });\r\n   }\r\n });\r\n \r\n-router.get('/summary', async (req, res) => {\r\n-  const { clubId, startDate, endDate } = req.query;\r\n \r\n-  if (!clubId) return res.status(400).json({ error: 'Missing clubId' });\r\n-\r\n-  try {\r\n-    const filters = {\r\n-      clubId: String(clubId),\r\n-      issuedAt: {\r\n-        gte: startDate ? new Date(String(startDate)) : undefined,\r\n-        lte: endDate ? new Date(String(endDate)) : undefined,\r\n-      },\r\n-    };\r\n-\r\n-    const [totalRevenue, unpaidDues, activeMembers] = await Promise.all([\r\n-      prisma.invoice.aggregate({\r\n-        where: { ...filters, status: 'paid' },\r\n-        _sum: { amount: true },\r\n-      }),\r\n-      prisma.invoice.aggregate({\r\n-        where: { ...filters, status: { in: ['unpaid', 'overdue', 'failed'] } },\r\n-        _sum: { amount: true },\r\n-      }),\r\n-      prisma.member.count({\r\n-        where: { clubId: String(clubId), memberType: 'member' },\r\n-      }),\r\n-    ]);\r\n-\r\n-    res.json({\r\n-      totalRevenue: totalRevenue._sum.amount ?? 0,\r\n-      unpaidDues: unpaidDues._sum.amount ?? 0,\r\n-      activeMembers,\r\n-      attendanceRate: 78, // placeholder until real logic exists\r\n-    });\r\n-  } catch (err) {\r\n-    console.error('Summary error:', err);\r\n-    res.status(500).json({ error: 'Failed to calculate summary' });\r\n-  }\r\n-});\r\n-\r\n router.get('/members', async (req, res) => {\r\n   const { clubId, membershipType } = req.query;\r\n \r\n   if (!clubId) {\r\n"
                },
                {
                    "date": 1753069554500,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,267 @@\n+//src/routes/billing.routes.ts\r\n+import express from 'express';\r\n+import { PrismaClient } from '@prisma/client';\r\n+import { Request, Response } from 'express';\r\n+\r\n+const router = express.Router();\r\n+const prisma = new PrismaClient();\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+router.post('/:memberId/payment-method', async (req, res) => {\r\n+  try {\r\n+    const { memberId } = req.params;\r\n+    const { cardNumber, expiry, cvc } = req.body;\r\n+\r\n+    const last4 = cardNumber.slice(-4);\r\n+    const [expMonthStr, expYearStr] = expiry.split('/');\r\n+\r\n+    const brand = 'visa'; // placeholder â€” you'd detect brand in real Stripe integration\r\n+    const stripePaymentMethodId = `fake_${Math.random().toString(36).substring(2, 10)}`; // mock ID\r\n+\r\n+    const method = await prisma.paymentMethod.create({\r\n+      data: {\r\n+        memberId,\r\n+        stripePaymentMethodId,\r\n+        cardBrand: brand,\r\n+        last4,\r\n+        expMonth: parseInt(expMonthStr),\r\n+        expYear: parseInt('20' + expYearStr), // e.g., 25 -> 2025\r\n+      },\r\n+    });\r\n+\r\n+    res.status(201).json(method);\r\n+  } catch (err) {\r\n+    console.error('Save Payment Method Error:', err);\r\n+    res.status(500).json({ error: 'Failed to save payment method' });\r\n+  }\r\n+});\r\n+\r\n+\r\n+//   const { memberId } = req.params;\r\n+\r\n+//   try {\r\n+//     const member = await prisma.member.findUnique({\r\n+//       where: { id: memberId },\r\n+//       include: {\r\n+//         paymentMethod: true,\r\n+//         // If you add invoice model later, include it here too\r\n+//         // invoices: true,\r\n+//       },\r\n+//     });\r\n+\r\n+//     if (!member) {\r\n+//       return res.status(404).json({ error: 'Member not found' });\r\n+//     }\r\n+\r\n+//     res.json({\r\n+//       paymentMethod: member.paymentMethod,\r\n+//       invoices: [], // Temporary â€” until invoices are added\r\n+//     });\r\n+//   } catch (err) {\r\n+//     console.error('Fetch billing error:', err);\r\n+//     res.status(500).json({ error: 'Failed to fetch billing data' });\r\n+//   }\r\n+// });\r\n+\r\n+\r\n+\r\n+// GET /api/billing/recent?limit=5\r\n+router.get('/recent', async (req, res) => {\r\n+  const limit = parseInt(req.query.limit as string) || 5;\r\n+\r\n+  try {\r\n+    const invoices = await prisma.invoice.findMany({\r\n+      orderBy: { issuedAt: 'desc' },\r\n+      take: limit,\r\n+      include: {\r\n+        member: {\r\n+          select: { firstName: true, lastName: true },\r\n+        },\r\n+      },\r\n+    });\r\n+\r\n+    const result = invoices.map((inv) => ({\r\n+      id: inv.id,\r\n+      memberName: `${inv.member.firstName} ${inv.member.lastName}`,\r\n+      amount: inv.amount,\r\n+      status: inv.status,\r\n+      issuedAt: inv.issuedAt,\r\n+      dueDate: inv.dueDate,\r\n+    }));\r\n+\r\n+    res.json(result);\r\n+  } catch (err) {\r\n+    console.error('Error fetching recent invoices:', err);\r\n+    res.status(500).json({ error: 'Internal server error' });\r\n+  }\r\n+});\r\n+\r\n+router.get('/summary', async (req, res) => {\r\n+  const { clubId, startDate, endDate } = req.query;\r\n+\r\n+  if (!clubId) return res.status(400).json({ error: 'Missing clubId' });\r\n+\r\n+  try {\r\n+    const filters = {\r\n+      clubId: String(clubId),\r\n+      issuedAt: {\r\n+        gte: startDate ? new Date(String(startDate)) : undefined,\r\n+        lte: endDate ? new Date(String(endDate)) : undefined,\r\n+      },\r\n+    };\r\n+\r\n+    const [totalRevenue, unpaidDues, activeMembers] = await Promise.all([\r\n+      prisma.invoice.aggregate({\r\n+        where: { ...filters, status: 'paid' },\r\n+        _sum: { amount: true },\r\n+      }),\r\n+      prisma.invoice.aggregate({\r\n+        where: { ...filters, status: { in: ['unpaid', 'overdue', 'failed'] } },\r\n+        _sum: { amount: true },\r\n+      }),\r\n+      prisma.member.count({\r\n+        where: { clubId: String(clubId), memberType: 'member' },\r\n+      }),\r\n+    ]);\r\n+\r\n+    res.json({\r\n+      totalRevenue: totalRevenue._sum.amount ?? 0,\r\n+      unpaidDues: unpaidDues._sum.amount ?? 0,\r\n+      activeMembers,\r\n+      attendanceRate: 78, // placeholder until real logic exists\r\n+    });\r\n+  } catch (err) {\r\n+    console.error('Summary error:', err);\r\n+    res.status(500).json({ error: 'Failed to calculate summary' });\r\n+  }\r\n+});\r\n+\r\n+\r\n+router.get('/members', async (req, res) => {\r\n+  const { clubId, membershipType } = req.query;\r\n+\r\n+  if (!clubId) {\r\n+    return res.status(400).json({ error: 'clubId is required' });\r\n+  }\r\n+\r\n+  try {\r\n+    const members = await prisma.member.findMany({\r\n+      where: {\r\n+        clubId: String(clubId),\r\n+        ...(membershipType && { memberType: String(membershipType) }),\r\n+      },\r\n+      orderBy: { createdAt: 'desc' },\r\n+    });\r\n+\r\n+    const response = members.map((m) => ({\r\n+      id: m.id,\r\n+      firstName: m.firstName,\r\n+      lastName: m.lastName,\r\n+      memberType: m.memberType,\r\n+      createdAt: m.createdAt,\r\n+    }));\r\n+\r\n+    res.json(response);\r\n+  } catch (err) {\r\n+    console.error('Fetch members error:', err);\r\n+    res.status(500).json({ error: 'Failed to fetch members' });\r\n+  }\r\n+});\r\n+\r\n+router.patch('/invoices/:id/pay', async (req, res) => {\r\n+  try {\r\n+    const { id } = req.params;\r\n+\r\n+    const invoice = await prisma.invoice.update({\r\n+      where: { id },\r\n+      data: { status: 'paid' },\r\n+    });\r\n+\r\n+    res.json(invoice);\r\n+  } catch (err) {\r\n+    console.error('Invoice payment error:', err);\r\n+    res.status(500).json({ error: 'Failed to mark invoice as paid' });\r\n+  }\r\n+});\r\n+\r\n+router.get('/', async (req, res) => {\r\n+  const { clubId, startDate, endDate, type } = req.query;\r\n+\r\n+  if (!clubId) return res.status(400).json({ error: 'Missing clubId' });\r\n+\r\n+  try {\r\n+    const invoices = await prisma.invoice.findMany({\r\n+      where: {\r\n+        clubId: String(clubId),\r\n+        issuedAt: {\r\n+          gte: startDate ? new Date(String(startDate)) : undefined,\r\n+          lte: endDate ? new Date(String(endDate)) : undefined,\r\n+        },\r\n+        ...(type && { member: { membershipType: String(type) } }),\r\n+      },\r\n+     include: {\r\n+        member: {\r\n+          select: { firstName: true, lastName: true },\r\n+        },\r\n+      },\r\n+      orderBy: { issuedAt: 'desc' },\r\n+    });\r\n+\r\n+    const response = invoices.map(inv => ({\r\n+      id: inv.id,\r\n+      memberName: `${inv.member.firstName} ${inv.member.lastName}`,\r\n+      amount: inv.amount,\r\n+      status: inv.status,\r\n+      issuedAt: inv.issuedAt,\r\n+      dueDate: inv.dueDate,\r\n+    }));\r\n+\r\n+    res.json(response);\r\n+  } catch (err) {\r\n+    console.error('Error fetching billing data:', err);\r\n+    res.status(500).json({ error: 'Internal server error' });\r\n+  }\r\n+});\r\n+\r\n+router.get('/:memberId', async (req, res) => {\r\n+  try {\r\n+    const { memberId } = req.params;\r\n+\r\n+    const paymentMethod = await prisma.paymentMethod.findUnique({\r\n+      where: { memberId },\r\n+    });\r\n+\r\n+    const invoices = await prisma.invoice.findMany({\r\n+      where: { memberId },\r\n+      orderBy: { issuedAt: 'desc' },\r\n+    });\r\n+\r\n+    res.json({ paymentMethod, invoices });\r\n+  } catch (err) {\r\n+    console.error('Fetch billing error:', err);\r\n+    res.status(500).json({ error: 'Failed to fetch billing data' });\r\n+  }\r\n+});\r\n+\r\n+// PATCH /api/billing/invoices/:id/pay\r\n+\r\n+\r\n+\r\n+//to get all \r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+export default router;\r\n+\r\n+\r\n+\r\n+\r\n+\r\n"
                },
                {
                    "date": 1753069652671,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -79,8 +79,11 @@\n       include: {\r\n         member: {\r\n           select: { firstName: true, lastName: true },\r\n         },\r\n+        club: {\r\n+          select: { name: true },\r\n+        },\r\n       },\r\n     });\r\n \r\n     const result = invoices.map((inv) => ({\r\n@@ -89,8 +92,9 @@\n       amount: inv.amount,\r\n       status: inv.status,\r\n       issuedAt: inv.issuedAt,\r\n       dueDate: inv.dueDate,\r\n+      clubName: inv.club.name,\r\n     }));\r\n \r\n     res.json(result);\r\n   } catch (err) {\r\n"
                },
                {
                    "date": 1753070219899,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -102,49 +102,99 @@\n     res.status(500).json({ error: 'Internal server error' });\r\n   }\r\n });\r\n \r\n+// router.get('/summary', async (req, res) => {\r\n+//   const { clubId, startDate, endDate } = req.query;\r\n+\r\n+//   if (!clubId) return res.status(400).json({ error: 'Missing clubId' });\r\n+\r\n+//   try {\r\n+//     const filters = {\r\n+//       clubId: String(clubId),\r\n+//       issuedAt: {\r\n+//         gte: startDate ? new Date(String(startDate)) : undefined,\r\n+//         lte: endDate ? new Date(String(endDate)) : undefined,\r\n+//       },\r\n+//     };\r\n+\r\n+//     const [totalRevenue, unpaidDues, activeMembers] = await Promise.all([\r\n+//       prisma.invoice.aggregate({\r\n+//         where: { ...filters, status: 'paid' },\r\n+//         _sum: { amount: true },\r\n+//       }),\r\n+//       prisma.invoice.aggregate({\r\n+//         where: { ...filters, status: { in: ['unpaid', 'overdue', 'failed'] } },\r\n+//         _sum: { amount: true },\r\n+//       }),\r\n+//       prisma.member.count({\r\n+//         where: { clubId: String(clubId), memberType: 'member' },\r\n+//       }),\r\n+//     ]);\r\n+\r\n+//     res.json({\r\n+//       totalRevenue: totalRevenue._sum.amount ?? 0,\r\n+//       unpaidDues: unpaidDues._sum.amount ?? 0,\r\n+//       activeMembers,\r\n+//       attendanceRate: 78, // placeholder until real logic exists\r\n+//     });\r\n+//   } catch (err) {\r\n+//     console.error('Summary error:', err);\r\n+//     res.status(500).json({ error: 'Failed to calculate summary' });\r\n+//   }\r\n+// });\r\n router.get('/summary', async (req, res) => {\r\n   const { clubId, startDate, endDate } = req.query;\r\n \r\n-  if (!clubId) return res.status(400).json({ error: 'Missing clubId' });\r\n+  // IMPORTANT CHANGE: Remove the direct 400 error if clubId is missing.\r\n+  // Instead, we'll build the filters conditionally.\r\n+  // if (!clubId) return res.status(400).json({ error: 'Missing clubId' }); // <-- REMOVE THIS LINE\r\n \r\n+  // Build filters object conditionally\r\n+  let invoiceFilters: any = {\r\n+    issuedAt: {\r\n+      gte: startDate ? new Date(String(startDate)) : undefined,\r\n+      lte: endDate ? new Date(String(endDate)) : undefined,\r\n+    },\r\n+  };\r\n+\r\n+  let memberCountFilters: any = {\r\n+    memberType: 'member' // Always count members, not prospects, for this summary\r\n+  };\r\n+\r\n+  // If clubId is provided, apply the filter to both invoice and member queries\r\n+  if (clubId) {\r\n+    invoiceFilters.clubId = String(clubId);\r\n+    memberCountFilters.clubId = String(clubId);\r\n+  }\r\n+\r\n   try {\r\n-    const filters = {\r\n-      clubId: String(clubId),\r\n-      issuedAt: {\r\n-        gte: startDate ? new Date(String(startDate)) : undefined,\r\n-        lte: endDate ? new Date(String(endDate)) : undefined,\r\n-      },\r\n-    };\r\n-\r\n-    const [totalRevenue, unpaidDues, activeMembers] = await Promise.all([\r\n+    const [totalRevenueResult, unpaidDuesResult, activeMembersCount] = await Promise.all([\r\n       prisma.invoice.aggregate({\r\n-        where: { ...filters, status: 'paid' },\r\n+        where: { ...invoiceFilters, status: 'paid' },\r\n         _sum: { amount: true },\r\n       }),\r\n       prisma.invoice.aggregate({\r\n-        where: { ...filters, status: { in: ['unpaid', 'overdue', 'failed'] } },\r\n+        where: { ...invoiceFilters, status: { in: ['unpaid', 'overdue', 'failed'] } },\r\n         _sum: { amount: true },\r\n       }),\r\n       prisma.member.count({\r\n-        where: { clubId: String(clubId), memberType: 'member' },\r\n+        where: memberCountFilters, // Use the dynamically built memberCountFilters\r\n       }),\r\n     ]);\r\n \r\n     res.json({\r\n-      totalRevenue: totalRevenue._sum.amount ?? 0,\r\n-      unpaidDues: unpaidDues._sum.amount ?? 0,\r\n-      activeMembers,\r\n+      totalRevenue: totalRevenueResult._sum.amount ?? 0,\r\n+      unpaidDues: unpaidDuesResult._sum.amount ?? 0,\r\n+      activeMembers: activeMembersCount,\r\n       attendanceRate: 78, // placeholder until real logic exists\r\n     });\r\n   } catch (err) {\r\n     console.error('Summary error:', err);\r\n     res.status(500).json({ error: 'Failed to calculate summary' });\r\n   }\r\n });\r\n \r\n-\r\n router.get('/members', async (req, res) => {\r\n   const { clubId, membershipType } = req.query;\r\n \r\n   if (!clubId) {\r\n"
                },
                {
                    "date": 1753072094339,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,371 @@\n+//src/routes/billing.routes.ts\r\n+import express from 'express';\r\n+import { PrismaClient } from '@prisma/client';\r\n+import { Request, Response } from 'express';\r\n+\r\n+const router = express.Router();\r\n+const prisma = new PrismaClient();\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+router.post('/:memberId/payment-method', async (req, res) => {\r\n+  try {\r\n+    const { memberId } = req.params;\r\n+    const { cardNumber, expiry, cvc } = req.body;\r\n+\r\n+    const last4 = cardNumber.slice(-4);\r\n+    const [expMonthStr, expYearStr] = expiry.split('/');\r\n+\r\n+    const brand = 'visa'; // placeholder â€” you'd detect brand in real Stripe integration\r\n+    const stripePaymentMethodId = `fake_${Math.random().toString(36).substring(2, 10)}`; // mock ID\r\n+\r\n+    const method = await prisma.paymentMethod.create({\r\n+      data: {\r\n+        memberId,\r\n+        stripePaymentMethodId,\r\n+        cardBrand: brand,\r\n+        last4,\r\n+        expMonth: parseInt(expMonthStr),\r\n+        expYear: parseInt('20' + expYearStr), // e.g., 25 -> 2025\r\n+      },\r\n+    });\r\n+\r\n+    res.status(201).json(method);\r\n+  } catch (err) {\r\n+    console.error('Save Payment Method Error:', err);\r\n+    res.status(500).json({ error: 'Failed to save payment method' });\r\n+  }\r\n+});\r\n+\r\n+\r\n+//   const { memberId } = req.params;\r\n+\r\n+//   try {\r\n+//     const member = await prisma.member.findUnique({\r\n+//       where: { id: memberId },\r\n+//       include: {\r\n+//         paymentMethod: true,\r\n+//         // If you add invoice model later, include it here too\r\n+//         // invoices: true,\r\n+//       },\r\n+//     });\r\n+\r\n+//     if (!member) {\r\n+//       return res.status(404).json({ error: 'Member not found' });\r\n+//     }\r\n+\r\n+//     res.json({\r\n+//       paymentMethod: member.paymentMethod,\r\n+//       invoices: [], // Temporary â€” until invoices are added\r\n+//     });\r\n+//   } catch (err) {\r\n+//     console.error('Fetch billing error:', err);\r\n+//     res.status(500).json({ error: 'Failed to fetch billing data' });\r\n+//   }\r\n+// });\r\n+\r\n+\r\n+\r\n+// GET /api/billing/recent?limit=5\r\n+router.get('/recent', async (req, res) => {\r\n+  const limit = parseInt(req.query.limit as string) || 5;\r\n+\r\n+  try {\r\n+    const invoices = await prisma.invoice.findMany({\r\n+      orderBy: { issuedAt: 'desc' },\r\n+      take: limit,\r\n+      include: {\r\n+        member: {\r\n+          select: { firstName: true, lastName: true },\r\n+        },\r\n+        club: {\r\n+          select: { name: true },\r\n+        },\r\n+      },\r\n+    });\r\n+\r\n+    const result = invoices.map((inv) => ({\r\n+      id: inv.id,\r\n+      memberName: `${inv.member.firstName} ${inv.member.lastName}`,\r\n+      amount: inv.amount,\r\n+      status: inv.status,\r\n+      issuedAt: inv.issuedAt,\r\n+      dueDate: inv.dueDate,\r\n+      clubName: inv.club.name,\r\n+    }));\r\n+\r\n+    res.json(result);\r\n+  } catch (err) {\r\n+    console.error('Error fetching recent invoices:', err);\r\n+    res.status(500).json({ error: 'Internal server error' });\r\n+  }\r\n+});\r\n+\r\n+// router.get('/summary', async (req, res) => {\r\n+//   const { clubId, startDate, endDate } = req.query;\r\n+\r\n+//   if (!clubId) return res.status(400).json({ error: 'Missing clubId' });\r\n+\r\n+//   try {\r\n+//     const filters = {\r\n+//       clubId: String(clubId),\r\n+//       issuedAt: {\r\n+//         gte: startDate ? new Date(String(startDate)) : undefined,\r\n+//         lte: endDate ? new Date(String(endDate)) : undefined,\r\n+//       },\r\n+//     };\r\n+\r\n+//     const [totalRevenue, unpaidDues, activeMembers] = await Promise.all([\r\n+//       prisma.invoice.aggregate({\r\n+//         where: { ...filters, status: 'paid' },\r\n+//         _sum: { amount: true },\r\n+//       }),\r\n+//       prisma.invoice.aggregate({\r\n+//         where: { ...filters, status: { in: ['unpaid', 'overdue', 'failed'] } },\r\n+//         _sum: { amount: true },\r\n+//       }),\r\n+//       prisma.member.count({\r\n+//         where: { clubId: String(clubId), memberType: 'member' },\r\n+//       }),\r\n+//     ]);\r\n+\r\n+//     res.json({\r\n+//       totalRevenue: totalRevenue._sum.amount ?? 0,\r\n+//       unpaidDues: unpaidDues._sum.amount ?? 0,\r\n+//       activeMembers,\r\n+//       attendanceRate: 78, // placeholder until real logic exists\r\n+//     });\r\n+//   } catch (err) {\r\n+//     console.error('Summary error:', err);\r\n+//     res.status(500).json({ error: 'Failed to calculate summary' });\r\n+//   }\r\n+// });\r\n+router.get('/summary', async (req, res) => {\r\n+  const { clubId, startDate, endDate } = req.query;\r\n+\r\n+  // IMPORTANT CHANGE: Remove the direct 400 error if clubId is missing.\r\n+  // Instead, we'll build the filters conditionally.\r\n+  // if (!clubId) return res.status(400).json({ error: 'Missing clubId' }); // <-- REMOVE THIS LINE\r\n+\r\n+  // Build filters object conditionally\r\n+  let invoiceFilters: any = {\r\n+    issuedAt: {\r\n+      gte: startDate ? new Date(String(startDate)) : undefined,\r\n+      lte: endDate ? new Date(String(endDate)) : undefined,\r\n+    },\r\n+  };\r\n+\r\n+  let memberCountFilters: any = {\r\n+    memberType: 'member' // Always count members, not prospects, for this summary\r\n+  };\r\n+\r\n+  // If clubId is provided, apply the filter to both invoice and member queries\r\n+  if (clubId) {\r\n+    invoiceFilters.clubId = String(clubId);\r\n+    memberCountFilters.clubId = String(clubId);\r\n+  }\r\n+\r\n+  try {\r\n+    const [totalRevenueResult, unpaidDuesResult, activeMembersCount] = await Promise.all([\r\n+      prisma.invoice.aggregate({\r\n+        where: { ...invoiceFilters, status: 'paid' },\r\n+        _sum: { amount: true },\r\n+      }),\r\n+      prisma.invoice.aggregate({\r\n+        where: { ...invoiceFilters, status: { in: ['unpaid', 'overdue', 'failed'] } },\r\n+        _sum: { amount: true },\r\n+      }),\r\n+      prisma.member.count({\r\n+        where: memberCountFilters, // Use the dynamically built memberCountFilters\r\n+      }),\r\n+    ]);\r\n+\r\n+    res.json({\r\n+      totalRevenue: totalRevenueResult._sum.amount ?? 0,\r\n+      unpaidDues: unpaidDuesResult._sum.amount ?? 0,\r\n+      activeMembers: activeMembersCount,\r\n+      attendanceRate: 78, // placeholder until real logic exists\r\n+    });\r\n+  } catch (err) {\r\n+    console.error('Summary error:', err);\r\n+    res.status(500).json({ error: 'Failed to calculate summary' });\r\n+  }\r\n+});\r\n+\r\n+router.get('/members', async (req, res) => {\r\n+  const { clubId, membershipType } = req.query;\r\n+\r\n+  if (!clubId) {\r\n+    return res.status(400).json({ error: 'clubId is required' });\r\n+  }\r\n+\r\n+  try {\r\n+    const members = await prisma.member.findMany({\r\n+      where: {\r\n+        clubId: String(clubId),\r\n+        ...(membershipType && { memberType: String(membershipType) }),\r\n+      },\r\n+      orderBy: { createdAt: 'desc' },\r\n+    });\r\n+\r\n+    const response = members.map((m) => ({\r\n+      id: m.id,\r\n+      firstName: m.firstName,\r\n+      lastName: m.lastName,\r\n+      memberType: m.memberType,\r\n+      createdAt: m.createdAt,\r\n+    }));\r\n+\r\n+    res.json(response);\r\n+  } catch (err) {\r\n+    console.error('Fetch members error:', err);\r\n+    res.status(500).json({ error: 'Failed to fetch members' });\r\n+  }\r\n+});\r\n+\r\n+router.patch('/invoices/:id/pay', async (req, res) => {\r\n+  try {\r\n+    const { id } = req.params;\r\n+\r\n+    const invoice = await prisma.invoice.update({\r\n+      where: { id },\r\n+      data: { status: 'paid' },\r\n+    });\r\n+\r\n+    res.json(invoice);\r\n+  } catch (err) {\r\n+    console.error('Invoice payment error:', err);\r\n+    res.status(500).json({ error: 'Failed to mark invoice as paid' });\r\n+  }\r\n+});\r\n+\r\n+// router.get('/', async (req, res) => {\r\n+//   const { clubId, startDate, endDate, type } = req.query;\r\n+\r\n+//   if (!clubId) return res.status(400).json({ error: 'Missing clubId' });\r\n+\r\n+//   try {\r\n+//     const invoices = await prisma.invoice.findMany({\r\n+//       where: {\r\n+//         clubId: String(clubId),\r\n+//         issuedAt: {\r\n+//           gte: startDate ? new Date(String(startDate)) : undefined,\r\n+//           lte: endDate ? new Date(String(endDate)) : undefined,\r\n+//         },\r\n+//         ...(type && { member: { membershipType: String(type) } }),\r\n+//       },\r\n+//      include: {\r\n+//         member: {\r\n+//           select: { firstName: true, lastName: true },\r\n+//         },\r\n+//       },\r\n+//       orderBy: { issuedAt: 'desc' },\r\n+//     });\r\n+\r\n+//     const response = invoices.map(inv => ({\r\n+//       id: inv.id,\r\n+//       memberName: `${inv.member.firstName} ${inv.member.lastName}`,\r\n+//       amount: inv.amount,\r\n+//       status: inv.status,\r\n+//       issuedAt: inv.issuedAt,\r\n+//       dueDate: inv.dueDate,\r\n+//     }));\r\n+\r\n+//     res.json(response);\r\n+//   } catch (err) {\r\n+//     console.error('Error fetching billing data:', err);\r\n+//     res.status(500).json({ error: 'Internal server error' });\r\n+//   }\r\n+// });\r\n+\r\n+\r\n+router.get('/', async (req, res) => {\r\n+  const { clubId, startDate, endDate, type, limit } = req.query; // Add limit to query params\r\n+  const take = parseInt(limit as string) || undefined; // Parse limit, default to undefined if not provided\r\n+\r\n+  // IMPORTANT CHANGE: Remove the direct 400 error if clubId is missing.\r\n+  // if (!clubId) return res.status(400).json({ error: 'Missing clubId' }); // <-- REMOVE THIS LINE\r\n+\r\n+  let whereClause: any = {\r\n+    issuedAt: {\r\n+      gte: startDate ? new Date(String(startDate)) : undefined,\r\n+      lte: endDate ? new Date(String(endDate)) : undefined,\r\n+    },\r\n+    ...(type && { member: { memberType: String(type) } }), // Corrected from membershipType to memberType as per schema\r\n+  };\r\n+\r\n+  if (clubId) {\r\n+    whereClause.clubId = String(clubId);\r\n+  } else {\r\n+    console.log('Backend /api/billing: No clubId provided, fetching GLOBAL invoices.');\r\n+  }\r\n+\r\n+  try {\r\n+    const invoices = await prisma.invoice.findMany({\r\n+      where: whereClause, // Use the dynamically built whereClause\r\n+      include: {\r\n+        member: {\r\n+          select: { firstName: true, lastName: true },\r\n+        },\r\n+      },\r\n+      orderBy: { issuedAt: 'desc' },\r\n+      take: take, // Apply the limit\r\n+    });\r\n+\r\n+    const response = invoices.map(inv => ({\r\n+      id: inv.id,\r\n+      memberName: `${inv.member.firstName} ${inv.member.lastName}`,\r\n+      amount: inv.amount,\r\n+      status: inv.status,\r\n+      issuedAt: inv.issuedAt,\r\n+      dueDate: inv.dueDate,\r\n+    }));\r\n+\r\n+    res.json(response);\r\n+  } catch (err) {\r\n+    console.error('Error fetching billing data:', err);\r\n+    res.status(500).json({ error: 'Internal server error' });\r\n+  }\r\n+});\r\n+\r\n+router.get('/:memberId', async (req, res) => {\r\n+  try {\r\n+    const { memberId } = req.params;\r\n+\r\n+    const paymentMethod = await prisma.paymentMethod.findUnique({\r\n+      where: { memberId },\r\n+    });\r\n+\r\n+    const invoices = await prisma.invoice.findMany({\r\n+      where: { memberId },\r\n+      orderBy: { issuedAt: 'desc' },\r\n+    });\r\n+\r\n+    res.json({ paymentMethod, invoices });\r\n+  } catch (err) {\r\n+    console.error('Fetch billing error:', err);\r\n+    res.status(500).json({ error: 'Failed to fetch billing data' });\r\n+  }\r\n+});\r\n+\r\n+// PATCH /api/billing/invoices/:id/pay\r\n+\r\n+\r\n+\r\n+//to get all \r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+export default router;\r\n+\r\n+\r\n+\r\n+\r\n+\r\n"
                },
                {
                    "date": 1753075764017,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,409 @@\n+//src/routes/billing.routes.ts\r\n+import express from 'express';\r\n+import { PrismaClient } from '@prisma/client';\r\n+import { Request, Response } from 'express';\r\n+\r\n+const router = express.Router();\r\n+const prisma = new PrismaClient();\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+//   const { memberId } = req.params;\r\n+\r\n+//   try {\r\n+//     const member = await prisma.member.findUnique({\r\n+//       where: { id: memberId },\r\n+//       include: {\r\n+//         paymentMethod: true,\r\n+//         // If you add invoice model later, include it here too\r\n+//         // invoices: true,\r\n+//       },\r\n+//     });\r\n+\r\n+//     if (!member) {\r\n+//       return res.status(404).json({ error: 'Member not found' });\r\n+//     }\r\n+\r\n+//     res.json({\r\n+//       paymentMethod: member.paymentMethod,\r\n+//       invoices: [], // Temporary â€” until invoices are added\r\n+//     });\r\n+//   } catch (err) {\r\n+//     console.error('Fetch billing error:', err);\r\n+//     res.status(500).json({ error: 'Failed to fetch billing data' });\r\n+//   }\r\n+// });\r\n+\r\n+\r\n+\r\n+// GET /api/billing/recent?limit=5\r\n+router.get('/recent', async (req, res) => {\r\n+  const limit = parseInt(req.query.limit as string) || 5;\r\n+\r\n+  try {\r\n+    const invoices = await prisma.invoice.findMany({\r\n+      orderBy: { issuedAt: 'desc' },\r\n+      take: limit,\r\n+      include: {\r\n+        member: {\r\n+          select: { firstName: true, lastName: true },\r\n+        },\r\n+        club: {\r\n+          select: { name: true },\r\n+        },\r\n+      },\r\n+    });\r\n+\r\n+    const result = invoices.map((inv) => ({\r\n+      id: inv.id,\r\n+      memberName: `${inv.member.firstName} ${inv.member.lastName}`,\r\n+      amount: inv.amount,\r\n+      status: inv.status,\r\n+      issuedAt: inv.issuedAt,\r\n+      dueDate: inv.dueDate,\r\n+      clubName: inv.club.name,\r\n+    }));\r\n+\r\n+    res.json(result);\r\n+  } catch (err) {\r\n+    console.error('Error fetching recent invoices:', err);\r\n+    res.status(500).json({ error: 'Internal server error' });\r\n+  }\r\n+});\r\n+\r\n+// router.get('/summary', async (req, res) => {\r\n+//   const { clubId, startDate, endDate } = req.query;\r\n+\r\n+//   if (!clubId) return res.status(400).json({ error: 'Missing clubId' });\r\n+\r\n+//   try {\r\n+//     const filters = {\r\n+//       clubId: String(clubId),\r\n+//       issuedAt: {\r\n+//         gte: startDate ? new Date(String(startDate)) : undefined,\r\n+//         lte: endDate ? new Date(String(endDate)) : undefined,\r\n+//       },\r\n+//     };\r\n+\r\n+//     const [totalRevenue, unpaidDues, activeMembers] = await Promise.all([\r\n+//       prisma.invoice.aggregate({\r\n+//         where: { ...filters, status: 'paid' },\r\n+//         _sum: { amount: true },\r\n+//       }),\r\n+//       prisma.invoice.aggregate({\r\n+//         where: { ...filters, status: { in: ['unpaid', 'overdue', 'failed'] } },\r\n+//         _sum: { amount: true },\r\n+//       }),\r\n+//       prisma.member.count({\r\n+//         where: { clubId: String(clubId), memberType: 'member' },\r\n+//       }),\r\n+//     ]);\r\n+\r\n+//     res.json({\r\n+//       totalRevenue: totalRevenue._sum.amount ?? 0,\r\n+//       unpaidDues: unpaidDues._sum.amount ?? 0,\r\n+//       activeMembers,\r\n+//       attendanceRate: 78, // placeholder until real logic exists\r\n+//     });\r\n+//   } catch (err) {\r\n+//     console.error('Summary error:', err);\r\n+//     res.status(500).json({ error: 'Failed to calculate summary' });\r\n+//   }\r\n+// });\r\n+router.get('/summary', async (req, res) => {\r\n+  const { clubId, startDate, endDate } = req.query;\r\n+\r\n+  // IMPORTANT CHANGE: Remove the direct 400 error if clubId is missing.\r\n+  // Instead, we'll build the filters conditionally.\r\n+  // if (!clubId) return res.status(400).json({ error: 'Missing clubId' }); // <-- REMOVE THIS LINE\r\n+\r\n+  // Build filters object conditionally\r\n+  let invoiceFilters: any = {\r\n+    issuedAt: {\r\n+      gte: startDate ? new Date(String(startDate)) : undefined,\r\n+      lte: endDate ? new Date(String(endDate)) : undefined,\r\n+    },\r\n+  };\r\n+\r\n+  let memberCountFilters: any = {\r\n+    memberType: 'member' // Always count members, not prospects, for this summary\r\n+  };\r\n+\r\n+  // If clubId is provided, apply the filter to both invoice and member queries\r\n+  if (clubId) {\r\n+    invoiceFilters.clubId = String(clubId);\r\n+    memberCountFilters.clubId = String(clubId);\r\n+  }\r\n+\r\n+  try {\r\n+    const [totalRevenueResult, unpaidDuesResult, activeMembersCount] = await Promise.all([\r\n+      prisma.invoice.aggregate({\r\n+        where: { ...invoiceFilters, status: 'paid' },\r\n+        _sum: { amount: true },\r\n+      }),\r\n+      prisma.invoice.aggregate({\r\n+        where: { ...invoiceFilters, status: { in: ['unpaid', 'overdue', 'failed'] } },\r\n+        _sum: { amount: true },\r\n+      }),\r\n+      prisma.member.count({\r\n+        where: memberCountFilters, // Use the dynamically built memberCountFilters\r\n+      }),\r\n+    ]);\r\n+\r\n+    res.json({\r\n+      totalRevenue: totalRevenueResult._sum.amount ?? 0,\r\n+      unpaidDues: unpaidDuesResult._sum.amount ?? 0,\r\n+      activeMembers: activeMembersCount,\r\n+      attendanceRate: 78, // placeholder until real logic exists\r\n+    });\r\n+  } catch (err) {\r\n+    console.error('Summary error:', err);\r\n+    res.status(500).json({ error: 'Failed to calculate summary' });\r\n+  }\r\n+});\r\n+\r\n+router.get('/members', async (req, res) => {\r\n+  const { clubId, membershipType } = req.query;\r\n+\r\n+  if (!clubId) {\r\n+    return res.status(400).json({ error: 'clubId is required' });\r\n+  }\r\n+\r\n+  try {\r\n+    const members = await prisma.member.findMany({\r\n+      where: {\r\n+        clubId: String(clubId),\r\n+        ...(membershipType && { memberType: String(membershipType) }),\r\n+      },\r\n+      orderBy: { createdAt: 'desc' },\r\n+    });\r\n+\r\n+    const response = members.map((m) => ({\r\n+      id: m.id,\r\n+      firstName: m.firstName,\r\n+      lastName: m.lastName,\r\n+      memberType: m.memberType,\r\n+      createdAt: m.createdAt,\r\n+    }));\r\n+\r\n+    res.json(response);\r\n+  } catch (err) {\r\n+    console.error('Fetch members error:', err);\r\n+    res.status(500).json({ error: 'Failed to fetch members' });\r\n+  }\r\n+});\r\n+\r\n+router.get('/monthly-revenue', async (req, res) => {\r\n+  const { clubId, month, year } = req.query; // month (1-12), year (e.g., 2023)\r\n+\r\n+  const currentYear = year ? parseInt(year as string) : new Date().getFullYear();\r\n+  const currentMonth = month ? parseInt(month as string) - 1 : new Date().getMonth();\r\n+\r\n+  const startDate = new Date(currentYear, currentMonth, 1);\r\n+  const endDate = new Date(currentYear, currentMonth + 1, 0);\r\n+\r\n+  let invoiceFilters: any = {\r\n+    status: 'paid',\r\n+    issuedAt: {\r\n+      gte: startDate,\r\n+      lte: endDate,\r\n+    },\r\n+  };\r\n+\r\n+  if (clubId) {\r\n+    invoiceFilters.clubId = String(clubId);\r\n+  } else {\r\n+    console.log('Backend /api/billing/monthly-revenue: No clubId provided, fetching GLOBAL monthly revenue.');\r\n+  }\r\n+\r\n+  try {\r\n+    const monthlyRevenueResult = await prisma.invoice.aggregate({\r\n+      where: invoiceFilters,\r\n+      _sum: { amount: true },\r\n+    });\r\n+\r\n+    const totalMonthlyRevenue = monthlyRevenueResult._sum.amount ?? 0;\r\n+\r\n+    res.json({ monthlyRevenue: totalMonthlyRevenue });\r\n+  } catch (err) {\r\n+    console.error('Error fetching monthly revenue:', err);\r\n+    res.status(500).json({ error: 'Failed to fetch monthly revenue' });\r\n+  }\r\n+});\r\n+\r\n+\r\n+\r\n+router.post('/:memberId/payment-method', async (req, res) => {\r\n+  try {\r\n+    const { memberId } = req.params;\r\n+    const { cardNumber, expiry, cvc } = req.body;\r\n+\r\n+    const last4 = cardNumber.slice(-4);\r\n+    const [expMonthStr, expYearStr] = expiry.split('/');\r\n+\r\n+    const brand = 'visa'; // placeholder â€” you'd detect brand in real Stripe integration\r\n+    const stripePaymentMethodId = `fake_${Math.random().toString(36).substring(2, 10)}`; // mock ID\r\n+\r\n+    const method = await prisma.paymentMethod.create({\r\n+      data: {\r\n+        memberId,\r\n+        stripePaymentMethodId,\r\n+        cardBrand: brand,\r\n+        last4,\r\n+        expMonth: parseInt(expMonthStr),\r\n+        expYear: parseInt('20' + expYearStr), // e.g., 25 -> 2025\r\n+      },\r\n+    });\r\n+\r\n+    res.status(201).json(method);\r\n+  } catch (err) {\r\n+    console.error('Save Payment Method Error:', err);\r\n+    res.status(500).json({ error: 'Failed to save payment method' });\r\n+  }\r\n+});\r\n+\r\n+\r\n+router.patch('/invoices/:id/pay', async (req, res) => {\r\n+  try {\r\n+    const { id } = req.params;\r\n+\r\n+    const invoice = await prisma.invoice.update({\r\n+      where: { id },\r\n+      data: { status: 'paid' },\r\n+    });\r\n+\r\n+    res.json(invoice);\r\n+  } catch (err) {\r\n+    console.error('Invoice payment error:', err);\r\n+    res.status(500).json({ error: 'Failed to mark invoice as paid' });\r\n+  }\r\n+});\r\n+\r\n+// router.get('/', async (req, res) => {\r\n+//   const { clubId, startDate, endDate, type } = req.query;\r\n+\r\n+//   if (!clubId) return res.status(400).json({ error: 'Missing clubId' });\r\n+\r\n+//   try {\r\n+//     const invoices = await prisma.invoice.findMany({\r\n+//       where: {\r\n+//         clubId: String(clubId),\r\n+//         issuedAt: {\r\n+//           gte: startDate ? new Date(String(startDate)) : undefined,\r\n+//           lte: endDate ? new Date(String(endDate)) : undefined,\r\n+//         },\r\n+//         ...(type && { member: { membershipType: String(type) } }),\r\n+//       },\r\n+//      include: {\r\n+//         member: {\r\n+//           select: { firstName: true, lastName: true },\r\n+//         },\r\n+//       },\r\n+//       orderBy: { issuedAt: 'desc' },\r\n+//     });\r\n+\r\n+//     const response = invoices.map(inv => ({\r\n+//       id: inv.id,\r\n+//       memberName: `${inv.member.firstName} ${inv.member.lastName}`,\r\n+//       amount: inv.amount,\r\n+//       status: inv.status,\r\n+//       issuedAt: inv.issuedAt,\r\n+//       dueDate: inv.dueDate,\r\n+//     }));\r\n+\r\n+//     res.json(response);\r\n+//   } catch (err) {\r\n+//     console.error('Error fetching billing data:', err);\r\n+//     res.status(500).json({ error: 'Internal server error' });\r\n+//   }\r\n+// });\r\n+\r\n+\r\n+router.get('/', async (req, res) => {\r\n+  const { clubId, startDate, endDate, type, limit } = req.query; // Add limit to query params\r\n+  const take = parseInt(limit as string) || undefined; // Parse limit, default to undefined if not provided\r\n+\r\n+  // IMPORTANT CHANGE: Remove the direct 400 error if clubId is missing.\r\n+  // if (!clubId) return res.status(400).json({ error: 'Missing clubId' }); // <-- REMOVE THIS LINE\r\n+\r\n+  let whereClause: any = {\r\n+    issuedAt: {\r\n+      gte: startDate ? new Date(String(startDate)) : undefined,\r\n+      lte: endDate ? new Date(String(endDate)) : undefined,\r\n+    },\r\n+    ...(type && { member: { memberType: String(type) } }), // Corrected from membershipType to memberType as per schema\r\n+  };\r\n+\r\n+  if (clubId) {\r\n+    whereClause.clubId = String(clubId);\r\n+  } else {\r\n+    console.log('Backend /api/billing: No clubId provided, fetching GLOBAL invoices.');\r\n+  }\r\n+\r\n+  try {\r\n+    const invoices = await prisma.invoice.findMany({\r\n+      where: whereClause, // Use the dynamically built whereClause\r\n+      include: {\r\n+        member: {\r\n+          select: { firstName: true, lastName: true },\r\n+        },\r\n+      },\r\n+      orderBy: { issuedAt: 'desc' },\r\n+      take: take, // Apply the limit\r\n+    });\r\n+\r\n+    const response = invoices.map(inv => ({\r\n+      id: inv.id,\r\n+      memberName: `${inv.member.firstName} ${inv.member.lastName}`,\r\n+      amount: inv.amount,\r\n+      status: inv.status,\r\n+      issuedAt: inv.issuedAt,\r\n+      dueDate: inv.dueDate,\r\n+    }));\r\n+\r\n+    res.json(response);\r\n+  } catch (err) {\r\n+    console.error('Error fetching billing data:', err);\r\n+    res.status(500).json({ error: 'Internal server error' });\r\n+  }\r\n+});\r\n+\r\n+router.get('/:memberId', async (req, res) => {\r\n+  try {\r\n+    const { memberId } = req.params;\r\n+\r\n+    const paymentMethod = await prisma.paymentMethod.findUnique({\r\n+      where: { memberId },\r\n+    });\r\n+\r\n+    const invoices = await prisma.invoice.findMany({\r\n+      where: { memberId },\r\n+      orderBy: { issuedAt: 'desc' },\r\n+    });\r\n+\r\n+    res.json({ paymentMethod, invoices });\r\n+  } catch (err) {\r\n+    console.error('Fetch billing error:', err);\r\n+    res.status(500).json({ error: 'Failed to fetch billing data' });\r\n+  }\r\n+});\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+export default router;\r\n+\r\n+\r\n+\r\n+\r\n+\r\n"
                },
                {
                    "date": 1753076323938,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -132,8 +132,10 @@\n   let memberCountFilters: any = {\r\n     memberType: 'member' // Always count members, not prospects, for this summary\r\n   };\r\n \r\n+  \r\n+\r\n   // If clubId is provided, apply the filter to both invoice and member queries\r\n   if (clubId) {\r\n     invoiceFilters.clubId = String(clubId);\r\n     memberCountFilters.clubId = String(clubId);\r\n"
                },
                {
                    "date": 1753076350383,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,493 @@\n+//src/routes/billing.routes.ts\r\n+import express from 'express';\r\n+import { PrismaClient } from '@prisma/client';\r\n+import { Request, Response } from 'express';\r\n+\r\n+const router = express.Router();\r\n+const prisma = new PrismaClient();\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+//   const { memberId } = req.params;\r\n+\r\n+//   try {\r\n+//     const member = await prisma.member.findUnique({\r\n+//       where: { id: memberId },\r\n+//       include: {\r\n+//         paymentMethod: true,\r\n+//         // If you add invoice model later, include it here too\r\n+//         // invoices: true,\r\n+//       },\r\n+//     });\r\n+\r\n+//     if (!member) {\r\n+//       return res.status(404).json({ error: 'Member not found' });\r\n+//     }\r\n+\r\n+//     res.json({\r\n+//       paymentMethod: member.paymentMethod,\r\n+//       invoices: [], // Temporary â€” until invoices are added\r\n+//     });\r\n+//   } catch (err) {\r\n+//     console.error('Fetch billing error:', err);\r\n+//     res.status(500).json({ error: 'Failed to fetch billing data' });\r\n+//   }\r\n+// });\r\n+\r\n+\r\n+\r\n+// GET /api/billing/recent?limit=5\r\n+router.get('/recent', async (req, res) => {\r\n+  const limit = parseInt(req.query.limit as string) || 5;\r\n+\r\n+  try {\r\n+    const invoices = await prisma.invoice.findMany({\r\n+      orderBy: { issuedAt: 'desc' },\r\n+      take: limit,\r\n+      include: {\r\n+        member: {\r\n+          select: { firstName: true, lastName: true },\r\n+        },\r\n+        club: {\r\n+          select: { name: true },\r\n+        },\r\n+      },\r\n+    });\r\n+\r\n+    const result = invoices.map((inv) => ({\r\n+      id: inv.id,\r\n+      memberName: `${inv.member.firstName} ${inv.member.lastName}`,\r\n+      amount: inv.amount,\r\n+      status: inv.status,\r\n+      issuedAt: inv.issuedAt,\r\n+      dueDate: inv.dueDate,\r\n+      clubName: inv.club.name,\r\n+    }));\r\n+\r\n+    res.json(result);\r\n+  } catch (err) {\r\n+    console.error('Error fetching recent invoices:', err);\r\n+    res.status(500).json({ error: 'Internal server error' });\r\n+  }\r\n+});\r\n+\r\n+// router.get('/summary', async (req, res) => {\r\n+//   const { clubId, startDate, endDate } = req.query;\r\n+\r\n+//   if (!clubId) return res.status(400).json({ error: 'Missing clubId' });\r\n+\r\n+//   try {\r\n+//     const filters = {\r\n+//       clubId: String(clubId),\r\n+//       issuedAt: {\r\n+//         gte: startDate ? new Date(String(startDate)) : undefined,\r\n+//         lte: endDate ? new Date(String(endDate)) : undefined,\r\n+//       },\r\n+//     };\r\n+\r\n+//     const [totalRevenue, unpaidDues, activeMembers] = await Promise.all([\r\n+//       prisma.invoice.aggregate({\r\n+//         where: { ...filters, status: 'paid' },\r\n+//         _sum: { amount: true },\r\n+//       }),\r\n+//       prisma.invoice.aggregate({\r\n+//         where: { ...filters, status: { in: ['unpaid', 'overdue', 'failed'] } },\r\n+//         _sum: { amount: true },\r\n+//       }),\r\n+//       prisma.member.count({\r\n+//         where: { clubId: String(clubId), memberType: 'member' },\r\n+//       }),\r\n+//     ]);\r\n+\r\n+//     res.json({\r\n+//       totalRevenue: totalRevenue._sum.amount ?? 0,\r\n+//       unpaidDues: unpaidDues._sum.amount ?? 0,\r\n+//       activeMembers,\r\n+//       attendanceRate: 78, // placeholder until real logic exists\r\n+//     });\r\n+//   } catch (err) {\r\n+//     console.error('Summary error:', err);\r\n+//     res.status(500).json({ error: 'Failed to calculate summary' });\r\n+//   }\r\n+// });\r\n+// router.get('/summary', async (req, res) => {\r\n+//   const { clubId, startDate, endDate } = req.query;\r\n+\r\n+//   // IMPORTANT CHANGE: Remove the direct 400 error if clubId is missing.\r\n+//   // Instead, we'll build the filters conditionally.\r\n+//   // if (!clubId) return res.status(400).json({ error: 'Missing clubId' }); // <-- REMOVE THIS LINE\r\n+\r\n+//   // Build filters object conditionally\r\n+//   let invoiceFilters: any = {\r\n+//     issuedAt: {\r\n+//       gte: startDate ? new Date(String(startDate)) : undefined,\r\n+//       lte: endDate ? new Date(String(endDate)) : undefined,\r\n+//     },\r\n+//   };\r\n+\r\n+//   let memberCountFilters: any = {\r\n+//     memberType: 'member' // Always count members, not prospects, for this summary\r\n+//   };\r\n+\r\n+  \r\n+\r\n+//   // If clubId is provided, apply the filter to both invoice and member queries\r\n+//   if (clubId) {\r\n+//     invoiceFilters.clubId = String(clubId);\r\n+//     memberCountFilters.clubId = String(clubId);\r\n+//   }\r\n+\r\n+//   try {\r\n+//     const [totalRevenueResult, unpaidDuesResult, activeMembersCount] = await Promise.all([\r\n+//       prisma.invoice.aggregate({\r\n+//         where: { ...invoiceFilters, status: 'paid' },\r\n+//         _sum: { amount: true },\r\n+//       }),\r\n+//       prisma.invoice.aggregate({\r\n+//         where: { ...invoiceFilters, status: { in: ['unpaid', 'overdue', 'failed'] } },\r\n+//         _sum: { amount: true },\r\n+//       }),\r\n+//       prisma.member.count({\r\n+//         where: memberCountFilters, // Use the dynamically built memberCountFilters\r\n+//       }),\r\n+//     ]);\r\n+\r\n+//     res.json({\r\n+//       totalRevenue: totalRevenueResult._sum.amount ?? 0,\r\n+//       unpaidDues: unpaidDuesResult._sum.amount ?? 0,\r\n+//       activeMembers: activeMembersCount,\r\n+//       attendanceRate: 78, // placeholder until real logic exists\r\n+//     });\r\n+//   } catch (err) {\r\n+//     console.error('Summary error:', err);\r\n+//     res.status(500).json({ error: 'Failed to calculate summary' });\r\n+//   }\r\n+// });\r\n+\r\n+\r\n+router.get('/summary', async (req, res) => {\r\n+  const { clubId, startDate, endDate } = req.query;\r\n+\r\n+  let invoiceFilters: any = {\r\n+    issuedAt: {\r\n+      gte: startDate ? new Date(String(startDate)) : undefined,\r\n+      lte: endDate ? new Date(String(endDate)) : undefined,\r\n+    },\r\n+  };\r\n+\r\n+  let memberCountFilters: any = {\r\n+    memberType: 'member'\r\n+  };\r\n+\r\n+  // Define date filters for attendance/schedule queries\r\n+  const attendanceDateFilters = {\r\n+    gte: startDate ? new Date(String(startDate)) : undefined,\r\n+    lte: endDate ? new Date(String(endDate)) : undefined,\r\n+  };\r\n+\r\n+  // If clubId is provided, apply the filter to all queries\r\n+  if (clubId) {\r\n+    invoiceFilters.clubId = String(clubId);\r\n+    memberCountFilters.clubId = String(clubId);\r\n+  } else {\r\n+    console.log('Backend /api/billing/summary: No clubId provided, fetching GLOBAL summary.');\r\n+  }\r\n+\r\n+  try {\r\n+    const [totalRevenueResult, unpaidDuesResult, activeMembersCount, totalBookingsResult, totalAttendancesResult] = await Promise.all([\r\n+      prisma.invoice.aggregate({\r\n+        where: { ...invoiceFilters, status: 'paid' },\r\n+        _sum: { amount: true },\r\n+      }),\r\n+      prisma.invoice.aggregate({\r\n+        where: { ...invoiceFilters, status: { in: ['unpaid', 'overdue', 'failed'] } },\r\n+        _sum: { amount: true },\r\n+      }),\r\n+      prisma.member.count({\r\n+        where: memberCountFilters,\r\n+      }),\r\n+      // New: Count total confirmed bookings for classes within the period\r\n+      prisma.booking.count({\r\n+        where: {\r\n+          status: 'confirmed',\r\n+          schedule: {\r\n+            date: attendanceDateFilters,\r\n+            ...(clubId && { clubId: String(clubId) }), // Apply clubId filter if present\r\n+          },\r\n+        },\r\n+      }),\r\n+      // New: Count total present attendances for classes within the period\r\n+      prisma.attendance.count({\r\n+        where: {\r\n+          status: 'present',\r\n+          markedAt: attendanceDateFilters, // Attendance markedAt should be within the period\r\n+          ...(clubId && { clubId: String(clubId) }), // Apply clubId filter if present\r\n+        },\r\n+      }),\r\n+    ]);\r\n+\r\n+    const totalConfirmedBookings = totalBookingsResult ?? 0;\r\n+    const totalPresentAttendances = totalAttendancesResult ?? 0;\r\n+\r\n+    let attendanceRate = 0;\r\n+    if (totalConfirmedBookings > 0) {\r\n+      attendanceRate = (totalPresentAttendances / totalConfirmedBookings) * 100;\r\n+    }\r\n+\r\n+    res.json({\r\n+      totalRevenue: totalRevenueResult._sum.amount ?? 0,\r\n+      unpaidDues: unpaidDuesResult._sum.amount ?? 0,\r\n+      activeMembers: activeMembersCount,\r\n+      attendanceRate: parseFloat(attendanceRate.toFixed(2)), // Format to 2 decimal places\r\n+    });\r\n+  } catch (err) {\r\n+    console.error('Summary error:', err);\r\n+    res.status(500).json({ error: 'Failed to calculate summary' });\r\n+  }\r\n+});\r\n+\r\n+router.get('/members', async (req, res) => {\r\n+  const { clubId, membershipType } = req.query;\r\n+\r\n+  if (!clubId) {\r\n+    return res.status(400).json({ error: 'clubId is required' });\r\n+  }\r\n+\r\n+  try {\r\n+    const members = await prisma.member.findMany({\r\n+      where: {\r\n+        clubId: String(clubId),\r\n+        ...(membershipType && { memberType: String(membershipType) }),\r\n+      },\r\n+      orderBy: { createdAt: 'desc' },\r\n+    });\r\n+\r\n+    const response = members.map((m) => ({\r\n+      id: m.id,\r\n+      firstName: m.firstName,\r\n+      lastName: m.lastName,\r\n+      memberType: m.memberType,\r\n+      createdAt: m.createdAt,\r\n+    }));\r\n+\r\n+    res.json(response);\r\n+  } catch (err) {\r\n+    console.error('Fetch members error:', err);\r\n+    res.status(500).json({ error: 'Failed to fetch members' });\r\n+  }\r\n+});\r\n+\r\n+router.get('/monthly-revenue', async (req, res) => {\r\n+  const { clubId, month, year } = req.query; // month (1-12), year (e.g., 2023)\r\n+\r\n+  const currentYear = year ? parseInt(year as string) : new Date().getFullYear();\r\n+  const currentMonth = month ? parseInt(month as string) - 1 : new Date().getMonth();\r\n+\r\n+  const startDate = new Date(currentYear, currentMonth, 1);\r\n+  const endDate = new Date(currentYear, currentMonth + 1, 0);\r\n+\r\n+  let invoiceFilters: any = {\r\n+    status: 'paid',\r\n+    issuedAt: {\r\n+      gte: startDate,\r\n+      lte: endDate,\r\n+    },\r\n+  };\r\n+\r\n+  if (clubId) {\r\n+    invoiceFilters.clubId = String(clubId);\r\n+  } else {\r\n+    console.log('Backend /api/billing/monthly-revenue: No clubId provided, fetching GLOBAL monthly revenue.');\r\n+  }\r\n+\r\n+  try {\r\n+    const monthlyRevenueResult = await prisma.invoice.aggregate({\r\n+      where: invoiceFilters,\r\n+      _sum: { amount: true },\r\n+    });\r\n+\r\n+    const totalMonthlyRevenue = monthlyRevenueResult._sum.amount ?? 0;\r\n+\r\n+    res.json({ monthlyRevenue: totalMonthlyRevenue });\r\n+  } catch (err) {\r\n+    console.error('Error fetching monthly revenue:', err);\r\n+    res.status(500).json({ error: 'Failed to fetch monthly revenue' });\r\n+  }\r\n+});\r\n+\r\n+\r\n+\r\n+router.post('/:memberId/payment-method', async (req, res) => {\r\n+  try {\r\n+    const { memberId } = req.params;\r\n+    const { cardNumber, expiry, cvc } = req.body;\r\n+\r\n+    const last4 = cardNumber.slice(-4);\r\n+    const [expMonthStr, expYearStr] = expiry.split('/');\r\n+\r\n+    const brand = 'visa'; // placeholder â€” you'd detect brand in real Stripe integration\r\n+    const stripePaymentMethodId = `fake_${Math.random().toString(36).substring(2, 10)}`; // mock ID\r\n+\r\n+    const method = await prisma.paymentMethod.create({\r\n+      data: {\r\n+        memberId,\r\n+        stripePaymentMethodId,\r\n+        cardBrand: brand,\r\n+        last4,\r\n+        expMonth: parseInt(expMonthStr),\r\n+        expYear: parseInt('20' + expYearStr), // e.g., 25 -> 2025\r\n+      },\r\n+    });\r\n+\r\n+    res.status(201).json(method);\r\n+  } catch (err) {\r\n+    console.error('Save Payment Method Error:', err);\r\n+    res.status(500).json({ error: 'Failed to save payment method' });\r\n+  }\r\n+});\r\n+\r\n+\r\n+router.patch('/invoices/:id/pay', async (req, res) => {\r\n+  try {\r\n+    const { id } = req.params;\r\n+\r\n+    const invoice = await prisma.invoice.update({\r\n+      where: { id },\r\n+      data: { status: 'paid' },\r\n+    });\r\n+\r\n+    res.json(invoice);\r\n+  } catch (err) {\r\n+    console.error('Invoice payment error:', err);\r\n+    res.status(500).json({ error: 'Failed to mark invoice as paid' });\r\n+  }\r\n+});\r\n+\r\n+// router.get('/', async (req, res) => {\r\n+//   const { clubId, startDate, endDate, type } = req.query;\r\n+\r\n+//   if (!clubId) return res.status(400).json({ error: 'Missing clubId' });\r\n+\r\n+//   try {\r\n+//     const invoices = await prisma.invoice.findMany({\r\n+//       where: {\r\n+//         clubId: String(clubId),\r\n+//         issuedAt: {\r\n+//           gte: startDate ? new Date(String(startDate)) : undefined,\r\n+//           lte: endDate ? new Date(String(endDate)) : undefined,\r\n+//         },\r\n+//         ...(type && { member: { membershipType: String(type) } }),\r\n+//       },\r\n+//      include: {\r\n+//         member: {\r\n+//           select: { firstName: true, lastName: true },\r\n+//         },\r\n+//       },\r\n+//       orderBy: { issuedAt: 'desc' },\r\n+//     });\r\n+\r\n+//     const response = invoices.map(inv => ({\r\n+//       id: inv.id,\r\n+//       memberName: `${inv.member.firstName} ${inv.member.lastName}`,\r\n+//       amount: inv.amount,\r\n+//       status: inv.status,\r\n+//       issuedAt: inv.issuedAt,\r\n+//       dueDate: inv.dueDate,\r\n+//     }));\r\n+\r\n+//     res.json(response);\r\n+//   } catch (err) {\r\n+//     console.error('Error fetching billing data:', err);\r\n+//     res.status(500).json({ error: 'Internal server error' });\r\n+//   }\r\n+// });\r\n+\r\n+\r\n+router.get('/', async (req, res) => {\r\n+  const { clubId, startDate, endDate, type, limit } = req.query; // Add limit to query params\r\n+  const take = parseInt(limit as string) || undefined; // Parse limit, default to undefined if not provided\r\n+\r\n+  // IMPORTANT CHANGE: Remove the direct 400 error if clubId is missing.\r\n+  // if (!clubId) return res.status(400).json({ error: 'Missing clubId' }); // <-- REMOVE THIS LINE\r\n+\r\n+  let whereClause: any = {\r\n+    issuedAt: {\r\n+      gte: startDate ? new Date(String(startDate)) : undefined,\r\n+      lte: endDate ? new Date(String(endDate)) : undefined,\r\n+    },\r\n+    ...(type && { member: { memberType: String(type) } }), // Corrected from membershipType to memberType as per schema\r\n+  };\r\n+\r\n+  if (clubId) {\r\n+    whereClause.clubId = String(clubId);\r\n+  } else {\r\n+    console.log('Backend /api/billing: No clubId provided, fetching GLOBAL invoices.');\r\n+  }\r\n+\r\n+  try {\r\n+    const invoices = await prisma.invoice.findMany({\r\n+      where: whereClause, // Use the dynamically built whereClause\r\n+      include: {\r\n+        member: {\r\n+          select: { firstName: true, lastName: true },\r\n+        },\r\n+      },\r\n+      orderBy: { issuedAt: 'desc' },\r\n+      take: take, // Apply the limit\r\n+    });\r\n+\r\n+    const response = invoices.map(inv => ({\r\n+      id: inv.id,\r\n+      memberName: `${inv.member.firstName} ${inv.member.lastName}`,\r\n+      amount: inv.amount,\r\n+      status: inv.status,\r\n+      issuedAt: inv.issuedAt,\r\n+      dueDate: inv.dueDate,\r\n+    }));\r\n+\r\n+    res.json(response);\r\n+  } catch (err) {\r\n+    console.error('Error fetching billing data:', err);\r\n+    res.status(500).json({ error: 'Internal server error' });\r\n+  }\r\n+});\r\n+\r\n+router.get('/:memberId', async (req, res) => {\r\n+  try {\r\n+    const { memberId } = req.params;\r\n+\r\n+    const paymentMethod = await prisma.paymentMethod.findUnique({\r\n+      where: { memberId },\r\n+    });\r\n+\r\n+    const invoices = await prisma.invoice.findMany({\r\n+      where: { memberId },\r\n+      orderBy: { issuedAt: 'desc' },\r\n+    });\r\n+\r\n+    res.json({ paymentMethod, invoices });\r\n+  } catch (err) {\r\n+    console.error('Fetch billing error:', err);\r\n+    res.status(500).json({ error: 'Failed to fetch billing data' });\r\n+  }\r\n+});\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+export default router;\r\n+\r\n+\r\n+\r\n+\r\n+\r\n"
                },
                {
                    "date": 1753076735577,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -318,603 +318,42 @@\n     res.status(500).json({ error: 'Failed to fetch monthly revenue' });\r\n   }\r\n });\r\n \r\n+router.get('/revenue-trend', async (req, res) => {\r\n+  const { clubId } = req.query;\r\n \r\n+  if (!clubId) return res.status(400).json({ error: 'Missing clubId' });\r\n \r\n-router.post('/:memberId/payment-method', async (req, res) => {\r\n   try {\r\n-    const { memberId } = req.params;\r\n-    const { cardNumber, expiry, cvc } = req.body;\r\n-\r\n-    const last4 = cardNumber.slice(-4);\r\n-    const [expMonthStr, expYearStr] = expiry.split('/');\r\n-\r\n-    const brand = 'visa'; // placeholder â€” you'd detect brand in real Stripe integration\r\n-    const stripePaymentMethodId = `fake_${Math.random().toString(36).substring(2, 10)}`; // mock ID\r\n-\r\n-    const method = await prisma.paymentMethod.create({\r\n-      data: {\r\n-        memberId,\r\n-        stripePaymentMethodId,\r\n-        cardBrand: brand,\r\n-        last4,\r\n-        expMonth: parseInt(expMonthStr),\r\n-        expYear: parseInt('20' + expYearStr), // e.g., 25 -> 2025\r\n-      },\r\n-    });\r\n-\r\n-    res.status(201).json(method);\r\n-  } catch (err) {\r\n-    console.error('Save Payment Method Error:', err);\r\n-    res.status(500).json({ error: 'Failed to save payment method' });\r\n-  }\r\n-});\r\n-\r\n-\r\n-router.patch('/invoices/:id/pay', async (req, res) => {\r\n-  try {\r\n-    const { id } = req.params;\r\n-\r\n-    const invoice = await prisma.invoice.update({\r\n-      where: { id },\r\n-      data: { status: 'paid' },\r\n-    });\r\n-\r\n-    res.json(invoice);\r\n-  } catch (err) {\r\n-    console.error('Invoice payment error:', err);\r\n-    res.status(500).json({ error: 'Failed to mark invoice as paid' });\r\n-  }\r\n-});\r\n-\r\n-// router.get('/', async (req, res) => {\r\n-//   const { clubId, startDate, endDate, type } = req.query;\r\n-\r\n-//   if (!clubId) return res.status(400).json({ error: 'Missing clubId' });\r\n-\r\n-//   try {\r\n-//     const invoices = await prisma.invoice.findMany({\r\n-//       where: {\r\n-//         clubId: String(clubId),\r\n-//         issuedAt: {\r\n-//           gte: startDate ? new Date(String(startDate)) : undefined,\r\n-//           lte: endDate ? new Date(String(endDate)) : undefined,\r\n-//         },\r\n-//         ...(type && { member: { membershipType: String(type) } }),\r\n-//       },\r\n-//      include: {\r\n-//         member: {\r\n-//           select: { firstName: true, lastName: true },\r\n-//         },\r\n-//       },\r\n-//       orderBy: { issuedAt: 'desc' },\r\n-//     });\r\n-\r\n-//     const response = invoices.map(inv => ({\r\n-//       id: inv.id,\r\n-//       memberName: `${inv.member.firstName} ${inv.member.lastName}`,\r\n-//       amount: inv.amount,\r\n-//       status: inv.status,\r\n-//       issuedAt: inv.issuedAt,\r\n-//       dueDate: inv.dueDate,\r\n-//     }));\r\n-\r\n-//     res.json(response);\r\n-//   } catch (err) {\r\n-//     console.error('Error fetching billing data:', err);\r\n-//     res.status(500).json({ error: 'Internal server error' });\r\n-//   }\r\n-// });\r\n-\r\n-\r\n-router.get('/', async (req, res) => {\r\n-  const { clubId, startDate, endDate, type, limit } = req.query; // Add limit to query params\r\n-  const take = parseInt(limit as string) || undefined; // Parse limit, default to undefined if not provided\r\n-\r\n-  // IMPORTANT CHANGE: Remove the direct 400 error if clubId is missing.\r\n-  // if (!clubId) return res.status(400).json({ error: 'Missing clubId' }); // <-- REMOVE THIS LINE\r\n-\r\n-  let whereClause: any = {\r\n-    issuedAt: {\r\n-      gte: startDate ? new Date(String(startDate)) : undefined,\r\n-      lte: endDate ? new Date(String(endDate)) : undefined,\r\n-    },\r\n-    ...(type && { member: { memberType: String(type) } }), // Corrected from membershipType to memberType as per schema\r\n-  };\r\n-\r\n-  if (clubId) {\r\n-    whereClause.clubId = String(clubId);\r\n-  } else {\r\n-    console.log('Backend /api/billing: No clubId provided, fetching GLOBAL invoices.');\r\n-  }\r\n-\r\n-  try {\r\n-    const invoices = await prisma.invoice.findMany({\r\n-      where: whereClause, // Use the dynamically built whereClause\r\n-      include: {\r\n-        member: {\r\n-          select: { firstName: true, lastName: true },\r\n-        },\r\n-      },\r\n-      orderBy: { issuedAt: 'desc' },\r\n-      take: take, // Apply the limit\r\n-    });\r\n-\r\n-    const response = invoices.map(inv => ({\r\n-      id: inv.id,\r\n-      memberName: `${inv.member.firstName} ${inv.member.lastName}`,\r\n-      amount: inv.amount,\r\n-      status: inv.status,\r\n-      issuedAt: inv.issuedAt,\r\n-      dueDate: inv.dueDate,\r\n-    }));\r\n-\r\n-    res.json(response);\r\n-  } catch (err) {\r\n-    console.error('Error fetching billing data:', err);\r\n-    res.status(500).json({ error: 'Internal server error' });\r\n-  }\r\n-});\r\n-\r\n-router.get('/:memberId', async (req, res) => {\r\n-  try {\r\n-    const { memberId } = req.params;\r\n-\r\n-    const paymentMethod = await prisma.paymentMethod.findUnique({\r\n-      where: { memberId },\r\n-    });\r\n-\r\n-    const invoices = await prisma.invoice.findMany({\r\n-      where: { memberId },\r\n-      orderBy: { issuedAt: 'desc' },\r\n-    });\r\n-\r\n-    res.json({ paymentMethod, invoices });\r\n-  } catch (err) {\r\n-    console.error('Fetch billing error:', err);\r\n-    res.status(500).json({ error: 'Failed to fetch billing data' });\r\n-  }\r\n-});\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-export default router;\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-//src/routes/billing.routes.ts\r\n-import express from 'express';\r\n-import { PrismaClient } from '@prisma/client';\r\n-import { Request, Response } from 'express';\r\n-\r\n-const router = express.Router();\r\n-const prisma = new PrismaClient();\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-//   const { memberId } = req.params;\r\n-\r\n-//   try {\r\n-//     const member = await prisma.member.findUnique({\r\n-//       where: { id: memberId },\r\n-//       include: {\r\n-//         paymentMethod: true,\r\n-//         // If you add invoice model later, include it here too\r\n-//         // invoices: true,\r\n-//       },\r\n-//     });\r\n-\r\n-//     if (!member) {\r\n-//       return res.status(404).json({ error: 'Member not found' });\r\n-//     }\r\n-\r\n-//     res.json({\r\n-//       paymentMethod: member.paymentMethod,\r\n-//       invoices: [], // Temporary â€” until invoices are added\r\n-//     });\r\n-//   } catch (err) {\r\n-//     console.error('Fetch billing error:', err);\r\n-//     res.status(500).json({ error: 'Failed to fetch billing data' });\r\n-//   }\r\n-// });\r\n-\r\n-\r\n-\r\n-// GET /api/billing/recent?limit=5\r\n-router.get('/recent', async (req, res) => {\r\n-  const limit = parseInt(req.query.limit as string) || 5;\r\n-\r\n-  try {\r\n-    const invoices = await prisma.invoice.findMany({\r\n-      orderBy: { issuedAt: 'desc' },\r\n-      take: limit,\r\n-      include: {\r\n-        member: {\r\n-          select: { firstName: true, lastName: true },\r\n-        },\r\n-        club: {\r\n-          select: { name: true },\r\n-        },\r\n-      },\r\n-    });\r\n-\r\n-    const result = invoices.map((inv) => ({\r\n-      id: inv.id,\r\n-      memberName: `${inv.member.firstName} ${inv.member.lastName}`,\r\n-      amount: inv.amount,\r\n-      status: inv.status,\r\n-      issuedAt: inv.issuedAt,\r\n-      dueDate: inv.dueDate,\r\n-      clubName: inv.club.name,\r\n-    }));\r\n-\r\n-    res.json(result);\r\n-  } catch (err) {\r\n-    console.error('Error fetching recent invoices:', err);\r\n-    res.status(500).json({ error: 'Internal server error' });\r\n-  }\r\n-});\r\n-\r\n-// router.get('/summary', async (req, res) => {\r\n-//   const { clubId, startDate, endDate } = req.query;\r\n-\r\n-//   if (!clubId) return res.status(400).json({ error: 'Missing clubId' });\r\n-\r\n-//   try {\r\n-//     const filters = {\r\n-//       clubId: String(clubId),\r\n-//       issuedAt: {\r\n-//         gte: startDate ? new Date(String(startDate)) : undefined,\r\n-//         lte: endDate ? new Date(String(endDate)) : undefined,\r\n-//       },\r\n-//     };\r\n-\r\n-//     const [totalRevenue, unpaidDues, activeMembers] = await Promise.all([\r\n-//       prisma.invoice.aggregate({\r\n-//         where: { ...filters, status: 'paid' },\r\n-//         _sum: { amount: true },\r\n-//       }),\r\n-//       prisma.invoice.aggregate({\r\n-//         where: { ...filters, status: { in: ['unpaid', 'overdue', 'failed'] } },\r\n-//         _sum: { amount: true },\r\n-//       }),\r\n-//       prisma.member.count({\r\n-//         where: { clubId: String(clubId), memberType: 'member' },\r\n-//       }),\r\n-//     ]);\r\n-\r\n-//     res.json({\r\n-//       totalRevenue: totalRevenue._sum.amount ?? 0,\r\n-//       unpaidDues: unpaidDues._sum.amount ?? 0,\r\n-//       activeMembers,\r\n-//       attendanceRate: 78, // placeholder until real logic exists\r\n-//     });\r\n-//   } catch (err) {\r\n-//     console.error('Summary error:', err);\r\n-//     res.status(500).json({ error: 'Failed to calculate summary' });\r\n-//   }\r\n-// });\r\n-router.get('/summary', async (req, res) => {\r\n-  const { clubId, startDate, endDate } = req.query;\r\n-\r\n-  // IMPORTANT CHANGE: Remove the direct 400 error if clubId is missing.\r\n-  // Instead, we'll build the filters conditionally.\r\n-  // if (!clubId) return res.status(400).json({ error: 'Missing clubId' }); // <-- REMOVE THIS LINE\r\n-\r\n-  // Build filters object conditionally\r\n-  let invoiceFilters: any = {\r\n-    issuedAt: {\r\n-      gte: startDate ? new Date(String(startDate)) : undefined,\r\n-      lte: endDate ? new Date(String(endDate)) : undefined,\r\n-    },\r\n-  };\r\n-\r\n-  let memberCountFilters: any = {\r\n-    memberType: 'member' // Always count members, not prospects, for this summary\r\n-  };\r\n-\r\n-  \r\n-\r\n-  // If clubId is provided, apply the filter to both invoice and member queries\r\n-  if (clubId) {\r\n-    invoiceFilters.clubId = String(clubId);\r\n-    memberCountFilters.clubId = String(clubId);\r\n-  }\r\n-\r\n-  try {\r\n-    const [totalRevenueResult, unpaidDuesResult, activeMembersCount] = await Promise.all([\r\n-      prisma.invoice.aggregate({\r\n-        where: { ...invoiceFilters, status: 'paid' },\r\n-        _sum: { amount: true },\r\n-      }),\r\n-      prisma.invoice.aggregate({\r\n-        where: { ...invoiceFilters, status: { in: ['unpaid', 'overdue', 'failed'] } },\r\n-        _sum: { amount: true },\r\n-      }),\r\n-      prisma.member.count({\r\n-        where: memberCountFilters, // Use the dynamically built memberCountFilters\r\n-      }),\r\n-    ]);\r\n-\r\n-    res.json({\r\n-      totalRevenue: totalRevenueResult._sum.amount ?? 0,\r\n-      unpaidDues: unpaidDuesResult._sum.amount ?? 0,\r\n-      activeMembers: activeMembersCount,\r\n-      attendanceRate: 78, // placeholder until real logic exists\r\n-    });\r\n-  } catch (err) {\r\n-    console.error('Summary error:', err);\r\n-    res.status(500).json({ error: 'Failed to calculate summary' });\r\n-  }\r\n-});\r\n-\r\n-router.get('/members', async (req, res) => {\r\n-  const { clubId, membershipType } = req.query;\r\n-\r\n-  if (!clubId) {\r\n-    return res.status(400).json({ error: 'clubId is required' });\r\n-  }\r\n-\r\n-  try {\r\n-    const members = await prisma.member.findMany({\r\n+    const results = await prisma.invoice.groupBy({\r\n+      by: ['issuedAt'],\r\n       where: {\r\n         clubId: String(clubId),\r\n-        ...(membershipType && { memberType: String(membershipType) }),\r\n+        status: 'paid',\r\n       },\r\n-      orderBy: { createdAt: 'desc' },\r\n-    });\r\n-\r\n-    const response = members.map((m) => ({\r\n-      id: m.id,\r\n-      firstName: m.firstName,\r\n-      lastName: m.lastName,\r\n-      memberType: m.memberType,\r\n-      createdAt: m.createdAt,\r\n-    }));\r\n-\r\n-    res.json(response);\r\n-  } catch (err) {\r\n-    console.error('Fetch members error:', err);\r\n-    res.status(500).json({ error: 'Failed to fetch members' });\r\n-  }\r\n-});\r\n-\r\n-router.get('/monthly-revenue', async (req, res) => {\r\n-  const { clubId, month, year } = req.query; // month (1-12), year (e.g., 2023)\r\n-\r\n-  const currentYear = year ? parseInt(year as string) : new Date().getFullYear();\r\n-  const currentMonth = month ? parseInt(month as string) - 1 : new Date().getMonth();\r\n-\r\n-  const startDate = new Date(currentYear, currentMonth, 1);\r\n-  const endDate = new Date(currentYear, currentMonth + 1, 0);\r\n-\r\n-  let invoiceFilters: any = {\r\n-    status: 'paid',\r\n-    issuedAt: {\r\n-      gte: startDate,\r\n-      lte: endDate,\r\n-    },\r\n-  };\r\n-\r\n-  if (clubId) {\r\n-    invoiceFilters.clubId = String(clubId);\r\n-  } else {\r\n-    console.log('Backend /api/billing/monthly-revenue: No clubId provided, fetching GLOBAL monthly revenue.');\r\n-  }\r\n-\r\n-  try {\r\n-    const monthlyRevenueResult = await prisma.invoice.aggregate({\r\n-      where: invoiceFilters,\r\n-      _sum: { amount: true },\r\n-    });\r\n-\r\n-    const totalMonthlyRevenue = monthlyRevenueResult._sum.amount ?? 0;\r\n-\r\n-    res.json({ monthlyRevenue: totalMonthlyRevenue });\r\n-  } catch (err) {\r\n-    console.error('Error fetching monthly revenue:', err);\r\n-    res.status(500).json({ error: 'Failed to fetch monthly revenue' });\r\n-  }\r\n-});\r\n-\r\n-\r\n-\r\n-router.post('/:memberId/payment-method', async (req, res) => {\r\n-  try {\r\n-    const { memberId } = req.params;\r\n-    const { cardNumber, expiry, cvc } = req.body;\r\n-\r\n-    const last4 = cardNumber.slice(-4);\r\n-    const [expMonthStr, expYearStr] = expiry.split('/');\r\n-\r\n-    const brand = 'visa'; // placeholder â€” you'd detect brand in real Stripe integration\r\n-    const stripePaymentMethodId = `fake_${Math.random().toString(36).substring(2, 10)}`; // mock ID\r\n-\r\n-    const method = await prisma.paymentMethod.create({\r\n-      data: {\r\n-        memberId,\r\n-        stripePaymentMethodId,\r\n-        cardBrand: brand,\r\n-        last4,\r\n-        expMonth: parseInt(expMonthStr),\r\n-        expYear: parseInt('20' + expYearStr), // e.g., 25 -> 2025\r\n+      _sum: {\r\n+        amount: true,\r\n       },\r\n-    });\r\n-\r\n-    res.status(201).json(method);\r\n-  } catch (err) {\r\n-    console.error('Save Payment Method Error:', err);\r\n-    res.status(500).json({ error: 'Failed to save payment method' });\r\n-  }\r\n-});\r\n-\r\n-\r\n-router.patch('/invoices/:id/pay', async (req, res) => {\r\n-  try {\r\n-    const { id } = req.params;\r\n-\r\n-    const invoice = await prisma.invoice.update({\r\n-      where: { id },\r\n-      data: { status: 'paid' },\r\n-    });\r\n-\r\n-    res.json(invoice);\r\n-  } catch (err) {\r\n-    console.error('Invoice payment error:', err);\r\n-    res.status(500).json({ error: 'Failed to mark invoice as paid' });\r\n-  }\r\n-});\r\n-\r\n-// router.get('/', async (req, res) => {\r\n-//   const { clubId, startDate, endDate, type } = req.query;\r\n-\r\n-//   if (!clubId) return res.status(400).json({ error: 'Missing clubId' });\r\n-\r\n-//   try {\r\n-//     const invoices = await prisma.invoice.findMany({\r\n-//       where: {\r\n-//         clubId: String(clubId),\r\n-//         issuedAt: {\r\n-//           gte: startDate ? new Date(String(startDate)) : undefined,\r\n-//           lte: endDate ? new Date(String(endDate)) : undefined,\r\n-//         },\r\n-//         ...(type && { member: { membershipType: String(type) } }),\r\n-//       },\r\n-//      include: {\r\n-//         member: {\r\n-//           select: { firstName: true, lastName: true },\r\n-//         },\r\n-//       },\r\n-//       orderBy: { issuedAt: 'desc' },\r\n-//     });\r\n-\r\n-//     const response = invoices.map(inv => ({\r\n-//       id: inv.id,\r\n-//       memberName: `${inv.member.firstName} ${inv.member.lastName}`,\r\n-//       amount: inv.amount,\r\n-//       status: inv.status,\r\n-//       issuedAt: inv.issuedAt,\r\n-//       dueDate: inv.dueDate,\r\n-//     }));\r\n-\r\n-//     res.json(response);\r\n-//   } catch (err) {\r\n-//     console.error('Error fetching billing data:', err);\r\n-//     res.status(500).json({ error: 'Internal server error' });\r\n-//   }\r\n-// });\r\n-\r\n-\r\n-router.get('/', async (req, res) => {\r\n-  const { clubId, startDate, endDate, type, limit } = req.query; // Add limit to query params\r\n-  const take = parseInt(limit as string) || undefined; // Parse limit, default to undefined if not provided\r\n-\r\n-  // IMPORTANT CHANGE: Remove the direct 400 error if clubId is missing.\r\n-  // if (!clubId) return res.status(400).json({ error: 'Missing clubId' }); // <-- REMOVE THIS LINE\r\n-\r\n-  let whereClause: any = {\r\n-    issuedAt: {\r\n-      gte: startDate ? new Date(String(startDate)) : undefined,\r\n-      lte: endDate ? new Date(String(endDate)) : undefined,\r\n-    },\r\n-    ...(type && { member: { memberType: String(type) } }), // Corrected from membershipType to memberType as per schema\r\n-  };\r\n-\r\n-  if (clubId) {\r\n-    whereClause.clubId = String(clubId);\r\n-  } else {\r\n-    console.log('Backend /api/billing: No clubId provided, fetching GLOBAL invoices.');\r\n-  }\r\n-\r\n-  try {\r\n-    const invoices = await prisma.invoice.findMany({\r\n-      where: whereClause, // Use the dynamically built whereClause\r\n-      include: {\r\n-        member: {\r\n-          select: { firstName: true, lastName: true },\r\n-        },\r\n+      orderBy: {\r\n+        issuedAt: 'asc',\r\n       },\r\n-      orderBy: { issuedAt: 'desc' },\r\n-      take: take, // Apply the limit\r\n     });\r\n \r\n-    const response = invoices.map(inv => ({\r\n-      id: inv.id,\r\n-      memberName: `${inv.member.firstName} ${inv.member.lastName}`,\r\n-      amount: inv.amount,\r\n-      status: inv.status,\r\n-      issuedAt: inv.issuedAt,\r\n-      dueDate: inv.dueDate,\r\n+    const trend = results.map((r) => ({\r\n+      date: r.issuedAt.toISOString().split('T')[0],\r\n+      revenue: r._sum.amount ?? 0,\r\n     }));\r\n \r\n-    res.json(response);\r\n+    res.json(trend);\r\n   } catch (err) {\r\n-    console.error('Error fetching billing data:', err);\r\n-    res.status(500).json({ error: 'Internal server error' });\r\n+    console.error('Revenue trend error:', err);\r\n+    res.status(500).json({ error: 'Failed to fetch revenue trend' });\r\n   }\r\n });\r\n \r\n-router.get('/:memberId', async (req, res) => {\r\n-  try {\r\n-    const { memberId } = req.params;\r\n \r\n-    const paymentMethod = await prisma.paymentMethod.findUnique({\r\n-      where: { memberId },\r\n-    });\r\n \r\n-    const invoices = await prisma.invoice.findMany({\r\n-      where: { memberId },\r\n-      orderBy: { issuedAt: 'desc' },\r\n-    });\r\n-\r\n-    res.json({ paymentMethod, invoices });\r\n-  } catch (err) {\r\n-    console.error('Fetch billing error:', err);\r\n-    res.status(500).json({ error: 'Failed to fetch billing data' });\r\n-  }\r\n-});\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-export default router;\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-//src/routes/billing.routes.ts\r\n-import express from 'express';\r\n-import { PrismaClient } from '@prisma/client';\r\n-import { Request, Response } from 'express';\r\n-\r\n-const router = express.Router();\r\n-const prisma = new PrismaClient();\r\n-\r\n-\r\n-\r\n-\r\n-\r\n router.post('/:memberId/payment-method', async (req, res) => {\r\n   try {\r\n     const { memberId } = req.params;\r\n     const { cardNumber, expiry, cvc } = req.body;\r\n@@ -943,193 +382,8 @@\n   }\r\n });\r\n \r\n \r\n-//   const { memberId } = req.params;\r\n-\r\n-//   try {\r\n-//     const member = await prisma.member.findUnique({\r\n-//       where: { id: memberId },\r\n-//       include: {\r\n-//         paymentMethod: true,\r\n-//         // If you add invoice model later, include it here too\r\n-//         // invoices: true,\r\n-//       },\r\n-//     });\r\n-\r\n-//     if (!member) {\r\n-//       return res.status(404).json({ error: 'Member not found' });\r\n-//     }\r\n-\r\n-//     res.json({\r\n-//       paymentMethod: member.paymentMethod,\r\n-//       invoices: [], // Temporary â€” until invoices are added\r\n-//     });\r\n-//   } catch (err) {\r\n-//     console.error('Fetch billing error:', err);\r\n-//     res.status(500).json({ error: 'Failed to fetch billing data' });\r\n-//   }\r\n-// });\r\n-\r\n-\r\n-\r\n-// GET /api/billing/recent?limit=5\r\n-router.get('/recent', async (req, res) => {\r\n-  const limit = parseInt(req.query.limit as string) || 5;\r\n-\r\n-  try {\r\n-    const invoices = await prisma.invoice.findMany({\r\n-      orderBy: { issuedAt: 'desc' },\r\n-      take: limit,\r\n-      include: {\r\n-        member: {\r\n-          select: { firstName: true, lastName: true },\r\n-        },\r\n-        club: {\r\n-          select: { name: true },\r\n-        },\r\n-      },\r\n-    });\r\n-\r\n-    const result = invoices.map((inv) => ({\r\n-      id: inv.id,\r\n-      memberName: `${inv.member.firstName} ${inv.member.lastName}`,\r\n-      amount: inv.amount,\r\n-      status: inv.status,\r\n-      issuedAt: inv.issuedAt,\r\n-      dueDate: inv.dueDate,\r\n-      clubName: inv.club.name,\r\n-    }));\r\n-\r\n-    res.json(result);\r\n-  } catch (err) {\r\n-    console.error('Error fetching recent invoices:', err);\r\n-    res.status(500).json({ error: 'Internal server error' });\r\n-  }\r\n-});\r\n-\r\n-// router.get('/summary', async (req, res) => {\r\n-//   const { clubId, startDate, endDate } = req.query;\r\n-\r\n-//   if (!clubId) return res.status(400).json({ error: 'Missing clubId' });\r\n-\r\n-//   try {\r\n-//     const filters = {\r\n-//       clubId: String(clubId),\r\n-//       issuedAt: {\r\n-//         gte: startDate ? new Date(String(startDate)) : undefined,\r\n-//         lte: endDate ? new Date(String(endDate)) : undefined,\r\n-//       },\r\n-//     };\r\n-\r\n-//     const [totalRevenue, unpaidDues, activeMembers] = await Promise.all([\r\n-//       prisma.invoice.aggregate({\r\n-//         where: { ...filters, status: 'paid' },\r\n-//         _sum: { amount: true },\r\n-//       }),\r\n-//       prisma.invoice.aggregate({\r\n-//         where: { ...filters, status: { in: ['unpaid', 'overdue', 'failed'] } },\r\n-//         _sum: { amount: true },\r\n-//       }),\r\n-//       prisma.member.count({\r\n-//         where: { clubId: String(clubId), memberType: 'member' },\r\n-//       }),\r\n-//     ]);\r\n-\r\n-//     res.json({\r\n-//       totalRevenue: totalRevenue._sum.amount ?? 0,\r\n-//       unpaidDues: unpaidDues._sum.amount ?? 0,\r\n-//       activeMembers,\r\n-//       attendanceRate: 78, // placeholder until real logic exists\r\n-//     });\r\n-//   } catch (err) {\r\n-//     console.error('Summary error:', err);\r\n-//     res.status(500).json({ error: 'Failed to calculate summary' });\r\n-//   }\r\n-// });\r\n-router.get('/summary', async (req, res) => {\r\n-  const { clubId, startDate, endDate } = req.query;\r\n-\r\n-  // IMPORTANT CHANGE: Remove the direct 400 error if clubId is missing.\r\n-  // Instead, we'll build the filters conditionally.\r\n-  // if (!clubId) return res.status(400).json({ error: 'Missing clubId' }); // <-- REMOVE THIS LINE\r\n-\r\n-  // Build filters object conditionally\r\n-  let invoiceFilters: any = {\r\n-    issuedAt: {\r\n-      gte: startDate ? new Date(String(startDate)) : undefined,\r\n-      lte: endDate ? new Date(String(endDate)) : undefined,\r\n-    },\r\n-  };\r\n-\r\n-  let memberCountFilters: any = {\r\n-    memberType: 'member' // Always count members, not prospects, for this summary\r\n-  };\r\n-\r\n-  // If clubId is provided, apply the filter to both invoice and member queries\r\n-  if (clubId) {\r\n-    invoiceFilters.clubId = String(clubId);\r\n-    memberCountFilters.clubId = String(clubId);\r\n-  }\r\n-\r\n-  try {\r\n-    const [totalRevenueResult, unpaidDuesResult, activeMembersCount] = await Promise.all([\r\n-      prisma.invoice.aggregate({\r\n-        where: { ...invoiceFilters, status: 'paid' },\r\n-        _sum: { amount: true },\r\n-      }),\r\n-      prisma.invoice.aggregate({\r\n-        where: { ...invoiceFilters, status: { in: ['unpaid', 'overdue', 'failed'] } },\r\n-        _sum: { amount: true },\r\n-      }),\r\n-      prisma.member.count({\r\n-        where: memberCountFilters, // Use the dynamically built memberCountFilters\r\n-      }),\r\n-    ]);\r\n-\r\n-    res.json({\r\n-      totalRevenue: totalRevenueResult._sum.amount ?? 0,\r\n-      unpaidDues: unpaidDuesResult._sum.amount ?? 0,\r\n-      activeMembers: activeMembersCount,\r\n-      attendanceRate: 78, // placeholder until real logic exists\r\n-    });\r\n-  } catch (err) {\r\n-    console.error('Summary error:', err);\r\n-    res.status(500).json({ error: 'Failed to calculate summary' });\r\n-  }\r\n-});\r\n-\r\n-router.get('/members', async (req, res) => {\r\n-  const { clubId, membershipType } = req.query;\r\n-\r\n-  if (!clubId) {\r\n-    return res.status(400).json({ error: 'clubId is required' });\r\n-  }\r\n-\r\n-  try {\r\n-    const members = await prisma.member.findMany({\r\n-      where: {\r\n-        clubId: String(clubId),\r\n-        ...(membershipType && { memberType: String(membershipType) }),\r\n-      },\r\n-      orderBy: { createdAt: 'desc' },\r\n-    });\r\n-\r\n-    const response = members.map((m) => ({\r\n-      id: m.id,\r\n-      firstName: m.firstName,\r\n-      lastName: m.lastName,\r\n-      memberType: m.memberType,\r\n-      createdAt: m.createdAt,\r\n-    }));\r\n-\r\n-    res.json(response);\r\n-  } catch (err) {\r\n-    console.error('Fetch members error:', err);\r\n-    res.status(500).json({ error: 'Failed to fetch members' });\r\n-  }\r\n-});\r\n-\r\n router.patch('/invoices/:id/pay', async (req, res) => {\r\n   try {\r\n     const { id } = req.params;\r\n \r\n@@ -1253,605 +507,19 @@\n     res.status(500).json({ error: 'Failed to fetch billing data' });\r\n   }\r\n });\r\n \r\n-// PATCH /api/billing/invoices/:id/pay\r\n \r\n \r\n \r\n-//to get all \r\n \r\n \r\n \r\n \r\n \r\n \r\n-\r\n-\r\n export default router;\r\n \r\n \r\n \r\n \r\n \r\n-//src/routes/billing.routes.ts\r\n-import express from 'express';\r\n-import { PrismaClient } from '@prisma/client';\r\n-import { Request, Response } from 'express';\r\n-\r\n-const router = express.Router();\r\n-const prisma = new PrismaClient();\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-router.post('/:memberId/payment-method', async (req, res) => {\r\n-  try {\r\n-    const { memberId } = req.params;\r\n-    const { cardNumber, expiry, cvc } = req.body;\r\n-\r\n-    const last4 = cardNumber.slice(-4);\r\n-    const [expMonthStr, expYearStr] = expiry.split('/');\r\n-\r\n-    const brand = 'visa'; // placeholder â€” you'd detect brand in real Stripe integration\r\n-    const stripePaymentMethodId = `fake_${Math.random().toString(36).substring(2, 10)}`; // mock ID\r\n-\r\n-    const method = await prisma.paymentMethod.create({\r\n-      data: {\r\n-        memberId,\r\n-        stripePaymentMethodId,\r\n-        cardBrand: brand,\r\n-        last4,\r\n-        expMonth: parseInt(expMonthStr),\r\n-        expYear: parseInt('20' + expYearStr), // e.g., 25 -> 2025\r\n-      },\r\n-    });\r\n-\r\n-    res.status(201).json(method);\r\n-  } catch (err) {\r\n-    console.error('Save Payment Method Error:', err);\r\n-    res.status(500).json({ error: 'Failed to save payment method' });\r\n-  }\r\n-});\r\n-\r\n-\r\n-//   const { memberId } = req.params;\r\n-\r\n-//   try {\r\n-//     const member = await prisma.member.findUnique({\r\n-//       where: { id: memberId },\r\n-//       include: {\r\n-//         paymentMethod: true,\r\n-//         // If you add invoice model later, include it here too\r\n-//         // invoices: true,\r\n-//       },\r\n-//     });\r\n-\r\n-//     if (!member) {\r\n-//       return res.status(404).json({ error: 'Member not found' });\r\n-//     }\r\n-\r\n-//     res.json({\r\n-//       paymentMethod: member.paymentMethod,\r\n-//       invoices: [], // Temporary â€” until invoices are added\r\n-//     });\r\n-//   } catch (err) {\r\n-//     console.error('Fetch billing error:', err);\r\n-//     res.status(500).json({ error: 'Failed to fetch billing data' });\r\n-//   }\r\n-// });\r\n-\r\n-\r\n-\r\n-// GET /api/billing/recent?limit=5\r\n-router.get('/recent', async (req, res) => {\r\n-  const limit = parseInt(req.query.limit as string) || 5;\r\n-\r\n-  try {\r\n-    const invoices = await prisma.invoice.findMany({\r\n-      orderBy: { issuedAt: 'desc' },\r\n-      take: limit,\r\n-      include: {\r\n-        member: {\r\n-          select: { firstName: true, lastName: true },\r\n-        },\r\n-        club: {\r\n-          select: { name: true },\r\n-        },\r\n-      },\r\n-    });\r\n-\r\n-    const result = invoices.map((inv) => ({\r\n-      id: inv.id,\r\n-      memberName: `${inv.member.firstName} ${inv.member.lastName}`,\r\n-      amount: inv.amount,\r\n-      status: inv.status,\r\n-      issuedAt: inv.issuedAt,\r\n-      dueDate: inv.dueDate,\r\n-      clubName: inv.club.name,\r\n-    }));\r\n-\r\n-    res.json(result);\r\n-  } catch (err) {\r\n-    console.error('Error fetching recent invoices:', err);\r\n-    res.status(500).json({ error: 'Internal server error' });\r\n-  }\r\n-});\r\n-\r\n-// router.get('/summary', async (req, res) => {\r\n-//   const { clubId, startDate, endDate } = req.query;\r\n-\r\n-//   if (!clubId) return res.status(400).json({ error: 'Missing clubId' });\r\n-\r\n-//   try {\r\n-//     const filters = {\r\n-//       clubId: String(clubId),\r\n-//       issuedAt: {\r\n-//         gte: startDate ? new Date(String(startDate)) : undefined,\r\n-//         lte: endDate ? new Date(String(endDate)) : undefined,\r\n-//       },\r\n-//     };\r\n-\r\n-//     const [totalRevenue, unpaidDues, activeMembers] = await Promise.all([\r\n-//       prisma.invoice.aggregate({\r\n-//         where: { ...filters, status: 'paid' },\r\n-//         _sum: { amount: true },\r\n-//       }),\r\n-//       prisma.invoice.aggregate({\r\n-//         where: { ...filters, status: { in: ['unpaid', 'overdue', 'failed'] } },\r\n-//         _sum: { amount: true },\r\n-//       }),\r\n-//       prisma.member.count({\r\n-//         where: { clubId: String(clubId), memberType: 'member' },\r\n-//       }),\r\n-//     ]);\r\n-\r\n-//     res.json({\r\n-//       totalRevenue: totalRevenue._sum.amount ?? 0,\r\n-//       unpaidDues: unpaidDues._sum.amount ?? 0,\r\n-//       activeMembers,\r\n-//       attendanceRate: 78, // placeholder until real logic exists\r\n-//     });\r\n-//   } catch (err) {\r\n-//     console.error('Summary error:', err);\r\n-//     res.status(500).json({ error: 'Failed to calculate summary' });\r\n-//   }\r\n-// });\r\n-router.get('/summary', async (req, res) => {\r\n-  const { clubId, startDate, endDate } = req.query;\r\n-\r\n-  // IMPORTANT CHANGE: Remove the direct 400 error if clubId is missing.\r\n-  // Instead, we'll build the filters conditionally.\r\n-  // if (!clubId) return res.status(400).json({ error: 'Missing clubId' }); // <-- REMOVE THIS LINE\r\n-\r\n-  // Build filters object conditionally\r\n-  let invoiceFilters: any = {\r\n-    issuedAt: {\r\n-      gte: startDate ? new Date(String(startDate)) : undefined,\r\n-      lte: endDate ? new Date(String(endDate)) : undefined,\r\n-    },\r\n-  };\r\n-\r\n-  let memberCountFilters: any = {\r\n-    memberType: 'member' // Always count members, not prospects, for this summary\r\n-  };\r\n-\r\n-  // If clubId is provided, apply the filter to both invoice and member queries\r\n-  if (clubId) {\r\n-    invoiceFilters.clubId = String(clubId);\r\n-    memberCountFilters.clubId = String(clubId);\r\n-  }\r\n-\r\n-  try {\r\n-    const [totalRevenueResult, unpaidDuesResult, activeMembersCount] = await Promise.all([\r\n-      prisma.invoice.aggregate({\r\n-        where: { ...invoiceFilters, status: 'paid' },\r\n-        _sum: { amount: true },\r\n-      }),\r\n-      prisma.invoice.aggregate({\r\n-        where: { ...invoiceFilters, status: { in: ['unpaid', 'overdue', 'failed'] } },\r\n-        _sum: { amount: true },\r\n-      }),\r\n-      prisma.member.count({\r\n-        where: memberCountFilters, // Use the dynamically built memberCountFilters\r\n-      }),\r\n-    ]);\r\n-\r\n-    res.json({\r\n-      totalRevenue: totalRevenueResult._sum.amount ?? 0,\r\n-      unpaidDues: unpaidDuesResult._sum.amount ?? 0,\r\n-      activeMembers: activeMembersCount,\r\n-      attendanceRate: 78, // placeholder until real logic exists\r\n-    });\r\n-  } catch (err) {\r\n-    console.error('Summary error:', err);\r\n-    res.status(500).json({ error: 'Failed to calculate summary' });\r\n-  }\r\n-});\r\n-\r\n-router.get('/members', async (req, res) => {\r\n-  const { clubId, membershipType } = req.query;\r\n-\r\n-  if (!clubId) {\r\n-    return res.status(400).json({ error: 'clubId is required' });\r\n-  }\r\n-\r\n-  try {\r\n-    const members = await prisma.member.findMany({\r\n-      where: {\r\n-        clubId: String(clubId),\r\n-        ...(membershipType && { memberType: String(membershipType) }),\r\n-      },\r\n-      orderBy: { createdAt: 'desc' },\r\n-    });\r\n-\r\n-    const response = members.map((m) => ({\r\n-      id: m.id,\r\n-      firstName: m.firstName,\r\n-      lastName: m.lastName,\r\n-      memberType: m.memberType,\r\n-      createdAt: m.createdAt,\r\n-    }));\r\n-\r\n-    res.json(response);\r\n-  } catch (err) {\r\n-    console.error('Fetch members error:', err);\r\n-    res.status(500).json({ error: 'Failed to fetch members' });\r\n-  }\r\n-});\r\n-\r\n-router.patch('/invoices/:id/pay', async (req, res) => {\r\n-  try {\r\n-    const { id } = req.params;\r\n-\r\n-    const invoice = await prisma.invoice.update({\r\n-      where: { id },\r\n-      data: { status: 'paid' },\r\n-    });\r\n-\r\n-    res.json(invoice);\r\n-  } catch (err) {\r\n-    console.error('Invoice payment error:', err);\r\n-    res.status(500).json({ error: 'Failed to mark invoice as paid' });\r\n-  }\r\n-});\r\n-\r\n-router.get('/', async (req, res) => {\r\n-  const { clubId, startDate, endDate, type } = req.query;\r\n-\r\n-  if (!clubId) return res.status(400).json({ error: 'Missing clubId' });\r\n-\r\n-  try {\r\n-    const invoices = await prisma.invoice.findMany({\r\n-      where: {\r\n-        clubId: String(clubId),\r\n-        issuedAt: {\r\n-          gte: startDate ? new Date(String(startDate)) : undefined,\r\n-          lte: endDate ? new Date(String(endDate)) : undefined,\r\n-        },\r\n-        ...(type && { member: { membershipType: String(type) } }),\r\n-      },\r\n-     include: {\r\n-        member: {\r\n-          select: { firstName: true, lastName: true },\r\n-        },\r\n-      },\r\n-      orderBy: { issuedAt: 'desc' },\r\n-    });\r\n-\r\n-    const response = invoices.map(inv => ({\r\n-      id: inv.id,\r\n-      memberName: `${inv.member.firstName} ${inv.member.lastName}`,\r\n-      amount: inv.amount,\r\n-      status: inv.status,\r\n-      issuedAt: inv.issuedAt,\r\n-      dueDate: inv.dueDate,\r\n-    }));\r\n-\r\n-    res.json(response);\r\n-  } catch (err) {\r\n-    console.error('Error fetching billing data:', err);\r\n-    res.status(500).json({ error: 'Internal server error' });\r\n-  }\r\n-});\r\n-\r\n-router.get('/:memberId', async (req, res) => {\r\n-  try {\r\n-    const { memberId } = req.params;\r\n-\r\n-    const paymentMethod = await prisma.paymentMethod.findUnique({\r\n-      where: { memberId },\r\n-    });\r\n-\r\n-    const invoices = await prisma.invoice.findMany({\r\n-      where: { memberId },\r\n-      orderBy: { issuedAt: 'desc' },\r\n-    });\r\n-\r\n-    res.json({ paymentMethod, invoices });\r\n-  } catch (err) {\r\n-    console.error('Fetch billing error:', err);\r\n-    res.status(500).json({ error: 'Failed to fetch billing data' });\r\n-  }\r\n-});\r\n-\r\n-// PATCH /api/billing/invoices/:id/pay\r\n-\r\n-\r\n-\r\n-//to get all \r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-export default router;\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-//src/routes/billing.routes.ts\r\n-import express from 'express';\r\n-import { PrismaClient } from '@prisma/client';\r\n-import { Request, Response } from 'express';\r\n-\r\n-const router = express.Router();\r\n-const prisma = new PrismaClient();\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-router.post('/:memberId/payment-method', async (req, res) => {\r\n-  try {\r\n-    const { memberId } = req.params;\r\n-    const { cardNumber, expiry, cvc } = req.body;\r\n-\r\n-    const last4 = cardNumber.slice(-4);\r\n-    const [expMonthStr, expYearStr] = expiry.split('/');\r\n-\r\n-    const brand = 'visa'; // placeholder â€” you'd detect brand in real Stripe integration\r\n-    const stripePaymentMethodId = `fake_${Math.random().toString(36).substring(2, 10)}`; // mock ID\r\n-\r\n-    const method = await prisma.paymentMethod.create({\r\n-      data: {\r\n-        memberId,\r\n-        stripePaymentMethodId,\r\n-        cardBrand: brand,\r\n-        last4,\r\n-        expMonth: parseInt(expMonthStr),\r\n-        expYear: parseInt('20' + expYearStr), // e.g., 25 -> 2025\r\n-      },\r\n-    });\r\n-\r\n-    res.status(201).json(method);\r\n-  } catch (err) {\r\n-    console.error('Save Payment Method Error:', err);\r\n-    res.status(500).json({ error: 'Failed to save payment method' });\r\n-  }\r\n-});\r\n-\r\n-\r\n-//   const { memberId } = req.params;\r\n-\r\n-//   try {\r\n-//     const member = await prisma.member.findUnique({\r\n-//       where: { id: memberId },\r\n-//       include: {\r\n-//         paymentMethod: true,\r\n-//         // If you add invoice model later, include it here too\r\n-//         // invoices: true,\r\n-//       },\r\n-//     });\r\n-\r\n-//     if (!member) {\r\n-//       return res.status(404).json({ error: 'Member not found' });\r\n-//     }\r\n-\r\n-//     res.json({\r\n-//       paymentMethod: member.paymentMethod,\r\n-//       invoices: [], // Temporary â€” until invoices are added\r\n-//     });\r\n-//   } catch (err) {\r\n-//     console.error('Fetch billing error:', err);\r\n-//     res.status(500).json({ error: 'Failed to fetch billing data' });\r\n-//   }\r\n-// });\r\n-\r\n-\r\n-\r\n-// GET /api/billing/recent?limit=5\r\n-router.get('/recent', async (req, res) => {\r\n-  const limit = parseInt(req.query.limit as string) || 5;\r\n-\r\n-  try {\r\n-    const invoices = await prisma.invoice.findMany({\r\n-      orderBy: { issuedAt: 'desc' },\r\n-      take: limit,\r\n-      include: {\r\n-        member: {\r\n-          select: { firstName: true, lastName: true },\r\n-        },\r\n-      },\r\n-    });\r\n-\r\n-    const result = invoices.map((inv) => ({\r\n-      id: inv.id,\r\n-      memberName: `${inv.member.firstName} ${inv.member.lastName}`,\r\n-      amount: inv.amount,\r\n-      status: inv.status,\r\n-      issuedAt: inv.issuedAt,\r\n-      dueDate: inv.dueDate,\r\n-    }));\r\n-\r\n-    res.json(result);\r\n-  } catch (err) {\r\n-    console.error('Error fetching recent invoices:', err);\r\n-    res.status(500).json({ error: 'Internal server error' });\r\n-  }\r\n-});\r\n-\r\n-router.get('/summary', async (req, res) => {\r\n-  const { clubId, startDate, endDate } = req.query;\r\n-\r\n-  if (!clubId) return res.status(400).json({ error: 'Missing clubId' });\r\n-\r\n-  try {\r\n-    const filters = {\r\n-      clubId: String(clubId),\r\n-      issuedAt: {\r\n-        gte: startDate ? new Date(String(startDate)) : undefined,\r\n-        lte: endDate ? new Date(String(endDate)) : undefined,\r\n-      },\r\n-    };\r\n-\r\n-    const [totalRevenue, unpaidDues, activeMembers] = await Promise.all([\r\n-      prisma.invoice.aggregate({\r\n-        where: { ...filters, status: 'paid' },\r\n-        _sum: { amount: true },\r\n-      }),\r\n-      prisma.invoice.aggregate({\r\n-        where: { ...filters, status: { in: ['unpaid', 'overdue', 'failed'] } },\r\n-        _sum: { amount: true },\r\n-      }),\r\n-      prisma.member.count({\r\n-        where: { clubId: String(clubId), memberType: 'member' },\r\n-      }),\r\n-    ]);\r\n-\r\n-    res.json({\r\n-      totalRevenue: totalRevenue._sum.amount ?? 0,\r\n-      unpaidDues: unpaidDues._sum.amount ?? 0,\r\n-      activeMembers,\r\n-      attendanceRate: 78, // placeholder until real logic exists\r\n-    });\r\n-  } catch (err) {\r\n-    console.error('Summary error:', err);\r\n-    res.status(500).json({ error: 'Failed to calculate summary' });\r\n-  }\r\n-});\r\n-\r\n-\r\n-router.get('/:memberId', async (req, res) => {\r\n-  try {\r\n-    const { memberId } = req.params;\r\n-\r\n-    const paymentMethod = await prisma.paymentMethod.findUnique({\r\n-      where: { memberId },\r\n-    });\r\n-\r\n-    const invoices = await prisma.invoice.findMany({\r\n-      where: { memberId },\r\n-      orderBy: { issuedAt: 'desc' },\r\n-    });\r\n-\r\n-    res.json({ paymentMethod, invoices });\r\n-  } catch (err) {\r\n-    console.error('Fetch billing error:', err);\r\n-    res.status(500).json({ error: 'Failed to fetch billing data' });\r\n-  }\r\n-});\r\n-\r\n-// PATCH /api/billing/invoices/:id/pay\r\n-router.patch('/invoices/:id/pay', async (req, res) => {\r\n-  try {\r\n-    const { id } = req.params;\r\n-\r\n-    const invoice = await prisma.invoice.update({\r\n-      where: { id },\r\n-      data: { status: 'paid' },\r\n-    });\r\n-\r\n-    res.json(invoice);\r\n-  } catch (err) {\r\n-    console.error('Invoice payment error:', err);\r\n-    res.status(500).json({ error: 'Failed to mark invoice as paid' });\r\n-  }\r\n-});\r\n-\r\n-\r\n-//to get all \r\n-router.get('/', async (req, res) => {\r\n-  const { clubId, startDate, endDate, type } = req.query;\r\n-\r\n-  if (!clubId) return res.status(400).json({ error: 'Missing clubId' });\r\n-\r\n-  try {\r\n-    const invoices = await prisma.invoice.findMany({\r\n-      where: {\r\n-        clubId: String(clubId),\r\n-        issuedAt: {\r\n-          gte: startDate ? new Date(String(startDate)) : undefined,\r\n-          lte: endDate ? new Date(String(endDate)) : undefined,\r\n-        },\r\n-        ...(type && { member: { membershipType: String(type) } }),\r\n-      },\r\n-     include: {\r\n-        member: {\r\n-          select: { firstName: true, lastName: true },\r\n-        },\r\n-      },\r\n-      orderBy: { issuedAt: 'desc' },\r\n-    });\r\n-\r\n-    const response = invoices.map(inv => ({\r\n-      id: inv.id,\r\n-      memberName: `${inv.member.firstName} ${inv.member.lastName}`,\r\n-      amount: inv.amount,\r\n-      status: inv.status,\r\n-      issuedAt: inv.issuedAt,\r\n-      dueDate: inv.dueDate,\r\n-    }));\r\n-\r\n-    res.json(response);\r\n-  } catch (err) {\r\n-    console.error('Error fetching billing data:', err);\r\n-    res.status(500).json({ error: 'Internal server error' });\r\n-  }\r\n-});\r\n-\r\n-\r\n-router.get('/members', async (req, res) => {\r\n-  const { clubId, membershipType } = req.query;\r\n-\r\n-  if (!clubId) {\r\n-    return res.status(400).json({ error: 'clubId is required' });\r\n-  }\r\n-\r\n-  try {\r\n-    const members = await prisma.member.findMany({\r\n-      where: {\r\n-        clubId: String(clubId),\r\n-        ...(membershipType && { memberType: String(membershipType) }),\r\n-      },\r\n-      orderBy: { createdAt: 'desc' },\r\n-    });\r\n-\r\n-    const response = members.map((m) => ({\r\n-      id: m.id,\r\n-      firstName: m.firstName,\r\n-      lastName: m.lastName,\r\n-      memberType: m.memberType,\r\n-      createdAt: m.createdAt,\r\n-    }));\r\n-\r\n-    res.json(response);\r\n-  } catch (err) {\r\n-    console.error('Fetch members error:', err);\r\n-    res.status(500).json({ error: 'Failed to fetch members' });\r\n-  }\r\n-});\r\n-\r\n-\r\n-\r\n-\r\n-export default router;\r\n-\r\n-\r\n-\r\n-\r\n-\r\n"
                },
                {
                    "date": 1753076798805,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,560 @@\n+//src/routes/billing.routes.ts\r\n+import express from 'express';\r\n+import { PrismaClient } from '@prisma/client';\r\n+import { Request, Response } from 'express';\r\n+\r\n+const router = express.Router();\r\n+const prisma = new PrismaClient();\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+//   const { memberId } = req.params;\r\n+\r\n+//   try {\r\n+//     const member = await prisma.member.findUnique({\r\n+//       where: { id: memberId },\r\n+//       include: {\r\n+//         paymentMethod: true,\r\n+//         // If you add invoice model later, include it here too\r\n+//         // invoices: true,\r\n+//       },\r\n+//     });\r\n+\r\n+//     if (!member) {\r\n+//       return res.status(404).json({ error: 'Member not found' });\r\n+//     }\r\n+\r\n+//     res.json({\r\n+//       paymentMethod: member.paymentMethod,\r\n+//       invoices: [], // Temporary â€” until invoices are added\r\n+//     });\r\n+//   } catch (err) {\r\n+//     console.error('Fetch billing error:', err);\r\n+//     res.status(500).json({ error: 'Failed to fetch billing data' });\r\n+//   }\r\n+// });\r\n+\r\n+\r\n+\r\n+// GET /api/billing/recent?limit=5\r\n+router.get('/recent', async (req, res) => {\r\n+  const limit = parseInt(req.query.limit as string) || 5;\r\n+\r\n+  try {\r\n+    const invoices = await prisma.invoice.findMany({\r\n+      orderBy: { issuedAt: 'desc' },\r\n+      take: limit,\r\n+      include: {\r\n+        member: {\r\n+          select: { firstName: true, lastName: true },\r\n+        },\r\n+        club: {\r\n+          select: { name: true },\r\n+        },\r\n+      },\r\n+    });\r\n+\r\n+    const result = invoices.map((inv) => ({\r\n+      id: inv.id,\r\n+      memberName: `${inv.member.firstName} ${inv.member.lastName}`,\r\n+      amount: inv.amount,\r\n+      status: inv.status,\r\n+      issuedAt: inv.issuedAt,\r\n+      dueDate: inv.dueDate,\r\n+      clubName: inv.club.name,\r\n+    }));\r\n+\r\n+    res.json(result);\r\n+  } catch (err) {\r\n+    console.error('Error fetching recent invoices:', err);\r\n+    res.status(500).json({ error: 'Internal server error' });\r\n+  }\r\n+});\r\n+\r\n+// router.get('/summary', async (req, res) => {\r\n+//   const { clubId, startDate, endDate } = req.query;\r\n+\r\n+//   if (!clubId) return res.status(400).json({ error: 'Missing clubId' });\r\n+\r\n+//   try {\r\n+//     const filters = {\r\n+//       clubId: String(clubId),\r\n+//       issuedAt: {\r\n+//         gte: startDate ? new Date(String(startDate)) : undefined,\r\n+//         lte: endDate ? new Date(String(endDate)) : undefined,\r\n+//       },\r\n+//     };\r\n+\r\n+//     const [totalRevenue, unpaidDues, activeMembers] = await Promise.all([\r\n+//       prisma.invoice.aggregate({\r\n+//         where: { ...filters, status: 'paid' },\r\n+//         _sum: { amount: true },\r\n+//       }),\r\n+//       prisma.invoice.aggregate({\r\n+//         where: { ...filters, status: { in: ['unpaid', 'overdue', 'failed'] } },\r\n+//         _sum: { amount: true },\r\n+//       }),\r\n+//       prisma.member.count({\r\n+//         where: { clubId: String(clubId), memberType: 'member' },\r\n+//       }),\r\n+//     ]);\r\n+\r\n+//     res.json({\r\n+//       totalRevenue: totalRevenue._sum.amount ?? 0,\r\n+//       unpaidDues: unpaidDues._sum.amount ?? 0,\r\n+//       activeMembers,\r\n+//       attendanceRate: 78, // placeholder until real logic exists\r\n+//     });\r\n+//   } catch (err) {\r\n+//     console.error('Summary error:', err);\r\n+//     res.status(500).json({ error: 'Failed to calculate summary' });\r\n+//   }\r\n+// });\r\n+// router.get('/summary', async (req, res) => {\r\n+//   const { clubId, startDate, endDate } = req.query;\r\n+\r\n+//   // IMPORTANT CHANGE: Remove the direct 400 error if clubId is missing.\r\n+//   // Instead, we'll build the filters conditionally.\r\n+//   // if (!clubId) return res.status(400).json({ error: 'Missing clubId' }); // <-- REMOVE THIS LINE\r\n+\r\n+//   // Build filters object conditionally\r\n+//   let invoiceFilters: any = {\r\n+//     issuedAt: {\r\n+//       gte: startDate ? new Date(String(startDate)) : undefined,\r\n+//       lte: endDate ? new Date(String(endDate)) : undefined,\r\n+//     },\r\n+//   };\r\n+\r\n+//   let memberCountFilters: any = {\r\n+//     memberType: 'member' // Always count members, not prospects, for this summary\r\n+//   };\r\n+\r\n+  \r\n+\r\n+//   // If clubId is provided, apply the filter to both invoice and member queries\r\n+//   if (clubId) {\r\n+//     invoiceFilters.clubId = String(clubId);\r\n+//     memberCountFilters.clubId = String(clubId);\r\n+//   }\r\n+\r\n+//   try {\r\n+//     const [totalRevenueResult, unpaidDuesResult, activeMembersCount] = await Promise.all([\r\n+//       prisma.invoice.aggregate({\r\n+//         where: { ...invoiceFilters, status: 'paid' },\r\n+//         _sum: { amount: true },\r\n+//       }),\r\n+//       prisma.invoice.aggregate({\r\n+//         where: { ...invoiceFilters, status: { in: ['unpaid', 'overdue', 'failed'] } },\r\n+//         _sum: { amount: true },\r\n+//       }),\r\n+//       prisma.member.count({\r\n+//         where: memberCountFilters, // Use the dynamically built memberCountFilters\r\n+//       }),\r\n+//     ]);\r\n+\r\n+//     res.json({\r\n+//       totalRevenue: totalRevenueResult._sum.amount ?? 0,\r\n+//       unpaidDues: unpaidDuesResult._sum.amount ?? 0,\r\n+//       activeMembers: activeMembersCount,\r\n+//       attendanceRate: 78, // placeholder until real logic exists\r\n+//     });\r\n+//   } catch (err) {\r\n+//     console.error('Summary error:', err);\r\n+//     res.status(500).json({ error: 'Failed to calculate summary' });\r\n+//   }\r\n+// });\r\n+\r\n+\r\n+router.get('/summary', async (req, res) => {\r\n+  const { clubId, startDate, endDate } = req.query;\r\n+\r\n+  let invoiceFilters: any = {\r\n+    issuedAt: {\r\n+      gte: startDate ? new Date(String(startDate)) : undefined,\r\n+      lte: endDate ? new Date(String(endDate)) : undefined,\r\n+    },\r\n+  };\r\n+\r\n+  let memberCountFilters: any = {\r\n+    memberType: 'member'\r\n+  };\r\n+\r\n+  // Define date filters for attendance/schedule queries\r\n+  const attendanceDateFilters = {\r\n+    gte: startDate ? new Date(String(startDate)) : undefined,\r\n+    lte: endDate ? new Date(String(endDate)) : undefined,\r\n+  };\r\n+\r\n+  // If clubId is provided, apply the filter to all queries\r\n+  if (clubId) {\r\n+    invoiceFilters.clubId = String(clubId);\r\n+    memberCountFilters.clubId = String(clubId);\r\n+  } else {\r\n+    console.log('Backend /api/billing/summary: No clubId provided, fetching GLOBAL summary.');\r\n+  }\r\n+\r\n+  try {\r\n+    const [totalRevenueResult, unpaidDuesResult, activeMembersCount, totalBookingsResult, totalAttendancesResult] = await Promise.all([\r\n+      prisma.invoice.aggregate({\r\n+        where: { ...invoiceFilters, status: 'paid' },\r\n+        _sum: { amount: true },\r\n+      }),\r\n+      prisma.invoice.aggregate({\r\n+        where: { ...invoiceFilters, status: { in: ['unpaid', 'overdue', 'failed'] } },\r\n+        _sum: { amount: true },\r\n+      }),\r\n+      prisma.member.count({\r\n+        where: memberCountFilters,\r\n+      }),\r\n+      // New: Count total confirmed bookings for classes within the period\r\n+      prisma.booking.count({\r\n+        where: {\r\n+          status: 'confirmed',\r\n+          schedule: {\r\n+            date: attendanceDateFilters,\r\n+            ...(clubId && { clubId: String(clubId) }), // Apply clubId filter if present\r\n+          },\r\n+        },\r\n+      }),\r\n+      // New: Count total present attendances for classes within the period\r\n+      prisma.attendance.count({\r\n+        where: {\r\n+          status: 'present',\r\n+          markedAt: attendanceDateFilters, // Attendance markedAt should be within the period\r\n+          ...(clubId && { clubId: String(clubId) }), // Apply clubId filter if present\r\n+        },\r\n+      }),\r\n+    ]);\r\n+\r\n+    const totalConfirmedBookings = totalBookingsResult ?? 0;\r\n+    const totalPresentAttendances = totalAttendancesResult ?? 0;\r\n+\r\n+    let attendanceRate = 0;\r\n+    if (totalConfirmedBookings > 0) {\r\n+      attendanceRate = (totalPresentAttendances / totalConfirmedBookings) * 100;\r\n+    }\r\n+\r\n+    res.json({\r\n+      totalRevenue: totalRevenueResult._sum.amount ?? 0,\r\n+      unpaidDues: unpaidDuesResult._sum.amount ?? 0,\r\n+      activeMembers: activeMembersCount,\r\n+      attendanceRate: parseFloat(attendanceRate.toFixed(2)), // Format to 2 decimal places\r\n+    });\r\n+  } catch (err) {\r\n+    console.error('Summary error:', err);\r\n+    res.status(500).json({ error: 'Failed to calculate summary' });\r\n+  }\r\n+});\r\n+\r\n+router.get('/members', async (req, res) => {\r\n+  const { clubId, membershipType } = req.query;\r\n+\r\n+  if (!clubId) {\r\n+    return res.status(400).json({ error: 'clubId is required' });\r\n+  }\r\n+\r\n+  try {\r\n+    const members = await prisma.member.findMany({\r\n+      where: {\r\n+        clubId: String(clubId),\r\n+        ...(membershipType && { memberType: String(membershipType) }),\r\n+      },\r\n+      orderBy: { createdAt: 'desc' },\r\n+    });\r\n+\r\n+    const response = members.map((m) => ({\r\n+      id: m.id,\r\n+      firstName: m.firstName,\r\n+      lastName: m.lastName,\r\n+      memberType: m.memberType,\r\n+      createdAt: m.createdAt,\r\n+    }));\r\n+\r\n+    res.json(response);\r\n+  } catch (err) {\r\n+    console.error('Fetch members error:', err);\r\n+    res.status(500).json({ error: 'Failed to fetch members' });\r\n+  }\r\n+});\r\n+\r\n+router.get('/monthly-revenue', async (req, res) => {\r\n+  const { clubId, month, year } = req.query; // month (1-12), year (e.g., 2023)\r\n+\r\n+  const currentYear = year ? parseInt(year as string) : new Date().getFullYear();\r\n+  const currentMonth = month ? parseInt(month as string) - 1 : new Date().getMonth();\r\n+\r\n+  const startDate = new Date(currentYear, currentMonth, 1);\r\n+  const endDate = new Date(currentYear, currentMonth + 1, 0);\r\n+\r\n+  let invoiceFilters: any = {\r\n+    status: 'paid',\r\n+    issuedAt: {\r\n+      gte: startDate,\r\n+      lte: endDate,\r\n+    },\r\n+  };\r\n+\r\n+  if (clubId) {\r\n+    invoiceFilters.clubId = String(clubId);\r\n+  } else {\r\n+    console.log('Backend /api/billing/monthly-revenue: No clubId provided, fetching GLOBAL monthly revenue.');\r\n+  }\r\n+\r\n+  try {\r\n+    const monthlyRevenueResult = await prisma.invoice.aggregate({\r\n+      where: invoiceFilters,\r\n+      _sum: { amount: true },\r\n+    });\r\n+\r\n+    const totalMonthlyRevenue = monthlyRevenueResult._sum.amount ?? 0;\r\n+\r\n+    res.json({ monthlyRevenue: totalMonthlyRevenue });\r\n+  } catch (err) {\r\n+    console.error('Error fetching monthly revenue:', err);\r\n+    res.status(500).json({ error: 'Failed to fetch monthly revenue' });\r\n+  }\r\n+});\r\n+\r\n+router.get('/revenue-trend', async (req, res) => {\r\n+  const { clubId, startDate, endDate } = req.query; // Add startDate and endDate for optional filtering\r\n+\r\n+  // IMPORTANT CHANGE: Remove the direct 400 error if clubId is missing.\r\n+  // if (!clubId) return res.status(400).json({ error: 'Missing clubId' }); // <-- REMOVE THIS LINE\r\n+\r\n+  // Define date range. Default to last 30 days if not provided, or a larger range.\r\n+  // For a trend graph, a default range is usually good. Let's use 90 days for example.\r\n+  const defaultDays = 90;\r\n+  const end = endDate ? new Date(String(endDate)) : new Date();\r\n+  const start = startDate ? new Date(String(startDate)) : new Date();\r\n+  if (!startDate) { // If no startDate provided, default to 90 days ago\r\n+    start.setDate(end.getDate() - defaultDays);\r\n+  }\r\n+\r\n+  start.setHours(0, 0, 0, 0); // Set to start of the day\r\n+  end.setHours(23, 59, 59, 999); // Set to end of the day\r\n+\r\n+  let whereClause: any = {\r\n+    status: 'paid', // Only sum paid invoices\r\n+    issuedAt: {\r\n+      gte: start,\r\n+      lte: end,\r\n+    },\r\n+  };\r\n+\r\n+  // Conditionally add clubId to whereClause\r\n+  if (clubId) {\r\n+    whereClause.clubId = String(clubId);\r\n+    console.log(`Backend /api/billing/revenue-trend: clubId provided (${clubId}), fetching club-specific revenue trend.`);\r\n+  } else {\r\n+    console.log('Backend /api/billing/revenue-trend: No clubId provided, fetching GLOBAL revenue trend.');\r\n+  }\r\n+\r\n+  try {\r\n+    const results = await prisma.invoice.groupBy({\r\n+      by: ['issuedAt'], // Group by the date the invoice was issued\r\n+      where: whereClause, // Apply the dynamic where clause\r\n+      _sum: {\r\n+        amount: true,\r\n+      },\r\n+      orderBy: {\r\n+        issuedAt: 'asc',\r\n+      },\r\n+    });\r\n+\r\n+    // Fill in missing dates with 0 revenue to ensure a continuous trend line\r\n+    const trend: { date: string; revenue: number }[] = [];\r\n+    let currentDate = new Date(start);\r\n+    while (currentDate <= end) {\r\n+      const dateKey = currentDate.toISOString().split('T')[0];\r\n+      const found = results.find(r => r.issuedAt.toISOString().split('T')[0] === dateKey);\r\n+      trend.push({\r\n+        date: dateKey,\r\n+        revenue: found ? (found._sum.amount ?? 0) : 0,\r\n+      });\r\n+      currentDate.setDate(currentDate.getDate() + 1); // Move to the next day\r\n+    }\r\n+\r\n+    res.json(trend);\r\n+  } catch (err) {\r\n+    console.error('Revenue trend error:', err);\r\n+    res.status(500).json({ error: 'Failed to fetch revenue trend' });\r\n+  }\r\n+});\r\n+\r\n+\r\n+\r\n+\r\n+router.post('/:memberId/payment-method', async (req, res) => {\r\n+  try {\r\n+    const { memberId } = req.params;\r\n+    const { cardNumber, expiry, cvc } = req.body;\r\n+\r\n+    const last4 = cardNumber.slice(-4);\r\n+    const [expMonthStr, expYearStr] = expiry.split('/');\r\n+\r\n+    const brand = 'visa'; // placeholder â€” you'd detect brand in real Stripe integration\r\n+    const stripePaymentMethodId = `fake_${Math.random().toString(36).substring(2, 10)}`; // mock ID\r\n+\r\n+    const method = await prisma.paymentMethod.create({\r\n+      data: {\r\n+        memberId,\r\n+        stripePaymentMethodId,\r\n+        cardBrand: brand,\r\n+        last4,\r\n+        expMonth: parseInt(expMonthStr),\r\n+        expYear: parseInt('20' + expYearStr), // e.g., 25 -> 2025\r\n+      },\r\n+    });\r\n+\r\n+    res.status(201).json(method);\r\n+  } catch (err) {\r\n+    console.error('Save Payment Method Error:', err);\r\n+    res.status(500).json({ error: 'Failed to save payment method' });\r\n+  }\r\n+});\r\n+\r\n+\r\n+router.patch('/invoices/:id/pay', async (req, res) => {\r\n+  try {\r\n+    const { id } = req.params;\r\n+\r\n+    const invoice = await prisma.invoice.update({\r\n+      where: { id },\r\n+      data: { status: 'paid' },\r\n+    });\r\n+\r\n+    res.json(invoice);\r\n+  } catch (err) {\r\n+    console.error('Invoice payment error:', err);\r\n+    res.status(500).json({ error: 'Failed to mark invoice as paid' });\r\n+  }\r\n+});\r\n+\r\n+// router.get('/', async (req, res) => {\r\n+//   const { clubId, startDate, endDate, type } = req.query;\r\n+\r\n+//   if (!clubId) return res.status(400).json({ error: 'Missing clubId' });\r\n+\r\n+//   try {\r\n+//     const invoices = await prisma.invoice.findMany({\r\n+//       where: {\r\n+//         clubId: String(clubId),\r\n+//         issuedAt: {\r\n+//           gte: startDate ? new Date(String(startDate)) : undefined,\r\n+//           lte: endDate ? new Date(String(endDate)) : undefined,\r\n+//         },\r\n+//         ...(type && { member: { membershipType: String(type) } }),\r\n+//       },\r\n+//      include: {\r\n+//         member: {\r\n+//           select: { firstName: true, lastName: true },\r\n+//         },\r\n+//       },\r\n+//       orderBy: { issuedAt: 'desc' },\r\n+//     });\r\n+\r\n+//     const response = invoices.map(inv => ({\r\n+//       id: inv.id,\r\n+//       memberName: `${inv.member.firstName} ${inv.member.lastName}`,\r\n+//       amount: inv.amount,\r\n+//       status: inv.status,\r\n+//       issuedAt: inv.issuedAt,\r\n+//       dueDate: inv.dueDate,\r\n+//     }));\r\n+\r\n+//     res.json(response);\r\n+//   } catch (err) {\r\n+//     console.error('Error fetching billing data:', err);\r\n+//     res.status(500).json({ error: 'Internal server error' });\r\n+//   }\r\n+// });\r\n+\r\n+\r\n+router.get('/', async (req, res) => {\r\n+  const { clubId, startDate, endDate, type, limit } = req.query; // Add limit to query params\r\n+  const take = parseInt(limit as string) || undefined; // Parse limit, default to undefined if not provided\r\n+\r\n+  // IMPORTANT CHANGE: Remove the direct 400 error if clubId is missing.\r\n+  // if (!clubId) return res.status(400).json({ error: 'Missing clubId' }); // <-- REMOVE THIS LINE\r\n+\r\n+  let whereClause: any = {\r\n+    issuedAt: {\r\n+      gte: startDate ? new Date(String(startDate)) : undefined,\r\n+      lte: endDate ? new Date(String(endDate)) : undefined,\r\n+    },\r\n+    ...(type && { member: { memberType: String(type) } }), // Corrected from membershipType to memberType as per schema\r\n+  };\r\n+\r\n+  if (clubId) {\r\n+    whereClause.clubId = String(clubId);\r\n+  } else {\r\n+    console.log('Backend /api/billing: No clubId provided, fetching GLOBAL invoices.');\r\n+  }\r\n+\r\n+  try {\r\n+    const invoices = await prisma.invoice.findMany({\r\n+      where: whereClause, // Use the dynamically built whereClause\r\n+      include: {\r\n+        member: {\r\n+          select: { firstName: true, lastName: true },\r\n+        },\r\n+      },\r\n+      orderBy: { issuedAt: 'desc' },\r\n+      take: take, // Apply the limit\r\n+    });\r\n+\r\n+    const response = invoices.map(inv => ({\r\n+      id: inv.id,\r\n+      memberName: `${inv.member.firstName} ${inv.member.lastName}`,\r\n+      amount: inv.amount,\r\n+      status: inv.status,\r\n+      issuedAt: inv.issuedAt,\r\n+      dueDate: inv.dueDate,\r\n+    }));\r\n+\r\n+    res.json(response);\r\n+  } catch (err) {\r\n+    console.error('Error fetching billing data:', err);\r\n+    res.status(500).json({ error: 'Internal server error' });\r\n+  }\r\n+});\r\n+\r\n+router.get('/:memberId', async (req, res) => {\r\n+  try {\r\n+    const { memberId } = req.params;\r\n+\r\n+    const paymentMethod = await prisma.paymentMethod.findUnique({\r\n+      where: { memberId },\r\n+    });\r\n+\r\n+    const invoices = await prisma.invoice.findMany({\r\n+      where: { memberId },\r\n+      orderBy: { issuedAt: 'desc' },\r\n+    });\r\n+\r\n+    res.json({ paymentMethod, invoices });\r\n+  } catch (err) {\r\n+    console.error('Fetch billing error:', err);\r\n+    res.status(500).json({ error: 'Failed to fetch billing data' });\r\n+  }\r\n+});\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+export default router;\r\n+\r\n+\r\n+\r\n+\r\n+\r\n"
                },
                {
                    "date": 1753163141442,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -59,9 +59,9 @@\n     });\r\n \r\n     const result = invoices.map((inv) => ({\r\n       id: inv.id,\r\n-      memberName: `${inv.member.firstName} ${inv.member.lastName}`,\r\n+       memberName: inv.member ? `${inv.member.firstName} ${inv.member.lastName}` : 'Unknown Member',\r\n       amount: inv.amount,\r\n       status: inv.status,\r\n       issuedAt: inv.issuedAt,\r\n       dueDate: inv.dueDate,\r\n"
                },
                {
                    "date": 1753163169990,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -508,9 +508,9 @@\n     });\r\n \r\n     const response = invoices.map(inv => ({\r\n       id: inv.id,\r\n-      memberName: `${inv.member.firstName} ${inv.member.lastName}`,\r\n+      memberName: inv.member ? `${inv.member.firstName} ${inv.member.lastName}` : 'Unknown Member',\r\n       amount: inv.amount,\r\n       status: inv.status,\r\n       issuedAt: inv.issuedAt,\r\n       dueDate: inv.dueDate,\r\n"
                },
                {
                    "date": 1753163175255,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,560 @@\n+//src/routes/billing.routes.ts\r\n+import express from 'express';\r\n+import { PrismaClient } from '@prisma/client';\r\n+import { Request, Response } from 'express';\r\n+\r\n+const router = express.Router();\r\n+const prisma = new PrismaClient();\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+//   const { memberId } = req.params;\r\n+\r\n+//   try {\r\n+//     const member = await prisma.member.findUnique({\r\n+//       where: { id: memberId },\r\n+//       include: {\r\n+//         paymentMethod: true,\r\n+//         // If you add invoice model later, include it here too\r\n+//         // invoices: true,\r\n+//       },\r\n+//     });\r\n+\r\n+//     if (!member) {\r\n+//       return res.status(404).json({ error: 'Member not found' });\r\n+//     }\r\n+\r\n+//     res.json({\r\n+//       paymentMethod: member.paymentMethod,\r\n+//       invoices: [], // Temporary â€” until invoices are added\r\n+//     });\r\n+//   } catch (err) {\r\n+//     console.error('Fetch billing error:', err);\r\n+//     res.status(500).json({ error: 'Failed to fetch billing data' });\r\n+//   }\r\n+// });\r\n+\r\n+\r\n+\r\n+// GET /api/billing/recent?limit=5\r\n+router.get('/recent', async (req, res) => {\r\n+  const limit = parseInt(req.query.limit as string) || 5;\r\n+\r\n+  try {\r\n+    const invoices = await prisma.invoice.findMany({\r\n+      orderBy: { issuedAt: 'desc' },\r\n+      take: limit,\r\n+      include: {\r\n+        member: {\r\n+          select: { firstName: true, lastName: true },\r\n+        },\r\n+        club: {\r\n+          select: { name: true },\r\n+        },\r\n+      },\r\n+    });\r\n+\r\n+    const result = invoices.map((inv) => ({\r\n+      id: inv.id,\r\n+       memberName: inv.member ? `${inv.member.firstName} ${inv.member.lastName}` : 'Unknown Member',\r\n+      amount: inv.amount,\r\n+      status: inv.status,\r\n+      issuedAt: inv.issuedAt,\r\n+      dueDate: inv.dueDate,\r\n+      clubName: inv.club.name,\r\n+    }));\r\n+\r\n+    res.json(result);\r\n+  } catch (err) {\r\n+    console.error('Error fetching recent invoices:', err);\r\n+    res.status(500).json({ error: 'Internal server error' });\r\n+  }\r\n+});\r\n+\r\n+// router.get('/summary', async (req, res) => {\r\n+//   const { clubId, startDate, endDate } = req.query;\r\n+\r\n+//   if (!clubId) return res.status(400).json({ error: 'Missing clubId' });\r\n+\r\n+//   try {\r\n+//     const filters = {\r\n+//       clubId: String(clubId),\r\n+//       issuedAt: {\r\n+//         gte: startDate ? new Date(String(startDate)) : undefined,\r\n+//         lte: endDate ? new Date(String(endDate)) : undefined,\r\n+//       },\r\n+//     };\r\n+\r\n+//     const [totalRevenue, unpaidDues, activeMembers] = await Promise.all([\r\n+//       prisma.invoice.aggregate({\r\n+//         where: { ...filters, status: 'paid' },\r\n+//         _sum: { amount: true },\r\n+//       }),\r\n+//       prisma.invoice.aggregate({\r\n+//         where: { ...filters, status: { in: ['unpaid', 'overdue', 'failed'] } },\r\n+//         _sum: { amount: true },\r\n+//       }),\r\n+//       prisma.member.count({\r\n+//         where: { clubId: String(clubId), memberType: 'member' },\r\n+//       }),\r\n+//     ]);\r\n+\r\n+//     res.json({\r\n+//       totalRevenue: totalRevenue._sum.amount ?? 0,\r\n+//       unpaidDues: unpaidDues._sum.amount ?? 0,\r\n+//       activeMembers,\r\n+//       attendanceRate: 78, // placeholder until real logic exists\r\n+//     });\r\n+//   } catch (err) {\r\n+//     console.error('Summary error:', err);\r\n+//     res.status(500).json({ error: 'Failed to calculate summary' });\r\n+//   }\r\n+// });\r\n+// router.get('/summary', async (req, res) => {\r\n+//   const { clubId, startDate, endDate } = req.query;\r\n+\r\n+//   // IMPORTANT CHANGE: Remove the direct 400 error if clubId is missing.\r\n+//   // Instead, we'll build the filters conditionally.\r\n+//   // if (!clubId) return res.status(400).json({ error: 'Missing clubId' }); // <-- REMOVE THIS LINE\r\n+\r\n+//   // Build filters object conditionally\r\n+//   let invoiceFilters: any = {\r\n+//     issuedAt: {\r\n+//       gte: startDate ? new Date(String(startDate)) : undefined,\r\n+//       lte: endDate ? new Date(String(endDate)) : undefined,\r\n+//     },\r\n+//   };\r\n+\r\n+//   let memberCountFilters: any = {\r\n+//     memberType: 'member' // Always count members, not prospects, for this summary\r\n+//   };\r\n+\r\n+  \r\n+\r\n+//   // If clubId is provided, apply the filter to both invoice and member queries\r\n+//   if (clubId) {\r\n+//     invoiceFilters.clubId = String(clubId);\r\n+//     memberCountFilters.clubId = String(clubId);\r\n+//   }\r\n+\r\n+//   try {\r\n+//     const [totalRevenueResult, unpaidDuesResult, activeMembersCount] = await Promise.all([\r\n+//       prisma.invoice.aggregate({\r\n+//         where: { ...invoiceFilters, status: 'paid' },\r\n+//         _sum: { amount: true },\r\n+//       }),\r\n+//       prisma.invoice.aggregate({\r\n+//         where: { ...invoiceFilters, status: { in: ['unpaid', 'overdue', 'failed'] } },\r\n+//         _sum: { amount: true },\r\n+//       }),\r\n+//       prisma.member.count({\r\n+//         where: memberCountFilters, // Use the dynamically built memberCountFilters\r\n+//       }),\r\n+//     ]);\r\n+\r\n+//     res.json({\r\n+//       totalRevenue: totalRevenueResult._sum.amount ?? 0,\r\n+//       unpaidDues: unpaidDuesResult._sum.amount ?? 0,\r\n+//       activeMembers: activeMembersCount,\r\n+//       attendanceRate: 78, // placeholder until real logic exists\r\n+//     });\r\n+//   } catch (err) {\r\n+//     console.error('Summary error:', err);\r\n+//     res.status(500).json({ error: 'Failed to calculate summary' });\r\n+//   }\r\n+// });\r\n+\r\n+\r\n+router.get('/summary', async (req, res) => {\r\n+  const { clubId, startDate, endDate } = req.query;\r\n+\r\n+  let invoiceFilters: any = {\r\n+    issuedAt: {\r\n+      gte: startDate ? new Date(String(startDate)) : undefined,\r\n+      lte: endDate ? new Date(String(endDate)) : undefined,\r\n+    },\r\n+  };\r\n+\r\n+  let memberCountFilters: any = {\r\n+    memberType: 'member'\r\n+  };\r\n+\r\n+  // Define date filters for attendance/schedule queries\r\n+  const attendanceDateFilters = {\r\n+    gte: startDate ? new Date(String(startDate)) : undefined,\r\n+    lte: endDate ? new Date(String(endDate)) : undefined,\r\n+  };\r\n+\r\n+  // If clubId is provided, apply the filter to all queries\r\n+  if (clubId) {\r\n+    invoiceFilters.clubId = String(clubId);\r\n+    memberCountFilters.clubId = String(clubId);\r\n+  } else {\r\n+    console.log('Backend /api/billing/summary: No clubId provided, fetching GLOBAL summary.');\r\n+  }\r\n+\r\n+  try {\r\n+    const [totalRevenueResult, unpaidDuesResult, activeMembersCount, totalBookingsResult, totalAttendancesResult] = await Promise.all([\r\n+      prisma.invoice.aggregate({\r\n+        where: { ...invoiceFilters, status: 'paid' },\r\n+        _sum: { amount: true },\r\n+      }),\r\n+      prisma.invoice.aggregate({\r\n+        where: { ...invoiceFilters, status: { in: ['unpaid', 'overdue', 'failed'] } },\r\n+        _sum: { amount: true },\r\n+      }),\r\n+      prisma.member.count({\r\n+        where: memberCountFilters,\r\n+      }),\r\n+      // New: Count total confirmed bookings for classes within the period\r\n+      prisma.booking.count({\r\n+        where: {\r\n+          status: 'confirmed',\r\n+          schedule: {\r\n+            date: attendanceDateFilters,\r\n+            ...(clubId && { clubId: String(clubId) }), // Apply clubId filter if present\r\n+          },\r\n+        },\r\n+      }),\r\n+      // New: Count total present attendances for classes within the period\r\n+      prisma.attendance.count({\r\n+        where: {\r\n+          status: 'present',\r\n+          markedAt: attendanceDateFilters, // Attendance markedAt should be within the period\r\n+          ...(clubId && { clubId: String(clubId) }), // Apply clubId filter if present\r\n+        },\r\n+      }),\r\n+    ]);\r\n+\r\n+    const totalConfirmedBookings = totalBookingsResult ?? 0;\r\n+    const totalPresentAttendances = totalAttendancesResult ?? 0;\r\n+\r\n+    let attendanceRate = 0;\r\n+    if (totalConfirmedBookings > 0) {\r\n+      attendanceRate = (totalPresentAttendances / totalConfirmedBookings) * 100;\r\n+    }\r\n+\r\n+    res.json({\r\n+      totalRevenue: totalRevenueResult._sum.amount ?? 0,\r\n+      unpaidDues: unpaidDuesResult._sum.amount ?? 0,\r\n+      activeMembers: activeMembersCount,\r\n+      attendanceRate: parseFloat(attendanceRate.toFixed(2)), // Format to 2 decimal places\r\n+    });\r\n+  } catch (err) {\r\n+    console.error('Summary error:', err);\r\n+    res.status(500).json({ error: 'Failed to calculate summary' });\r\n+  }\r\n+});\r\n+\r\n+router.get('/members', async (req, res) => {\r\n+  const { clubId, membershipType } = req.query;\r\n+\r\n+  if (!clubId) {\r\n+    return res.status(400).json({ error: 'clubId is required' });\r\n+  }\r\n+\r\n+  try {\r\n+    const members = await prisma.member.findMany({\r\n+      where: {\r\n+        clubId: String(clubId),\r\n+        ...(membershipType && { memberType: String(membershipType) }),\r\n+      },\r\n+      orderBy: { createdAt: 'desc' },\r\n+    });\r\n+\r\n+    const response = members.map((m) => ({\r\n+      id: m.id,\r\n+      firstName: m.firstName,\r\n+      lastName: m.lastName,\r\n+      memberType: m.memberType,\r\n+      createdAt: m.createdAt,\r\n+    }));\r\n+\r\n+    res.json(response);\r\n+  } catch (err) {\r\n+    console.error('Fetch members error:', err);\r\n+    res.status(500).json({ error: 'Failed to fetch members' });\r\n+  }\r\n+});\r\n+\r\n+router.get('/monthly-revenue', async (req, res) => {\r\n+  const { clubId, month, year } = req.query; // month (1-12), year (e.g., 2023)\r\n+\r\n+  const currentYear = year ? parseInt(year as string) : new Date().getFullYear();\r\n+  const currentMonth = month ? parseInt(month as string) - 1 : new Date().getMonth();\r\n+\r\n+  const startDate = new Date(currentYear, currentMonth, 1);\r\n+  const endDate = new Date(currentYear, currentMonth + 1, 0);\r\n+\r\n+  let invoiceFilters: any = {\r\n+    status: 'paid',\r\n+    issuedAt: {\r\n+      gte: startDate,\r\n+      lte: endDate,\r\n+    },\r\n+  };\r\n+\r\n+  if (clubId) {\r\n+    invoiceFilters.clubId = String(clubId);\r\n+  } else {\r\n+    console.log('Backend /api/billing/monthly-revenue: No clubId provided, fetching GLOBAL monthly revenue.');\r\n+  }\r\n+\r\n+  try {\r\n+    const monthlyRevenueResult = await prisma.invoice.aggregate({\r\n+      where: invoiceFilters,\r\n+      _sum: { amount: true },\r\n+    });\r\n+\r\n+    const totalMonthlyRevenue = monthlyRevenueResult._sum.amount ?? 0;\r\n+\r\n+    res.json({ monthlyRevenue: totalMonthlyRevenue });\r\n+  } catch (err) {\r\n+    console.error('Error fetching monthly revenue:', err);\r\n+    res.status(500).json({ error: 'Failed to fetch monthly revenue' });\r\n+  }\r\n+});\r\n+\r\n+router.get('/revenue-trend', async (req, res) => {\r\n+  const { clubId, startDate, endDate } = req.query; // Add startDate and endDate for optional filtering\r\n+\r\n+  // IMPORTANT CHANGE: Remove the direct 400 error if clubId is missing.\r\n+  // if (!clubId) return res.status(400).json({ error: 'Missing clubId' }); // <-- REMOVE THIS LINE\r\n+\r\n+  // Define date range. Default to last 30 days if not provided, or a larger range.\r\n+  // For a trend graph, a default range is usually good. Let's use 90 days for example.\r\n+  const defaultDays = 90;\r\n+  const end = endDate ? new Date(String(endDate)) : new Date();\r\n+  const start = startDate ? new Date(String(startDate)) : new Date();\r\n+  if (!startDate) { // If no startDate provided, default to 90 days ago\r\n+    start.setDate(end.getDate() - defaultDays);\r\n+  }\r\n+\r\n+  start.setHours(0, 0, 0, 0); // Set to start of the day\r\n+  end.setHours(23, 59, 59, 999); // Set to end of the day\r\n+\r\n+  let whereClause: any = {\r\n+    status: 'paid', // Only sum paid invoices\r\n+    issuedAt: {\r\n+      gte: start,\r\n+      lte: end,\r\n+    },\r\n+  };\r\n+\r\n+  // Conditionally add clubId to whereClause\r\n+  if (clubId) {\r\n+    whereClause.clubId = String(clubId);\r\n+    console.log(`Backend /api/billing/revenue-trend: clubId provided (${clubId}), fetching club-specific revenue trend.`);\r\n+  } else {\r\n+    console.log('Backend /api/billing/revenue-trend: No clubId provided, fetching GLOBAL revenue trend.');\r\n+  }\r\n+\r\n+  try {\r\n+    const results = await prisma.invoice.groupBy({\r\n+      by: ['issuedAt'], // Group by the date the invoice was issued\r\n+      where: whereClause, // Apply the dynamic where clause\r\n+      _sum: {\r\n+        amount: true,\r\n+      },\r\n+      orderBy: {\r\n+        issuedAt: 'asc',\r\n+      },\r\n+    });\r\n+\r\n+    // Fill in missing dates with 0 revenue to ensure a continuous trend line\r\n+    const trend: { date: string; revenue: number }[] = [];\r\n+    let currentDate = new Date(start);\r\n+    while (currentDate <= end) {\r\n+      const dateKey = currentDate.toISOString().split('T')[0];\r\n+      const found = results.find(r => r.issuedAt.toISOString().split('T')[0] === dateKey);\r\n+      trend.push({\r\n+        date: dateKey,\r\n+        revenue: found ? (found._sum.amount ?? 0) : 0,\r\n+      });\r\n+      currentDate.setDate(currentDate.getDate() + 1); // Move to the next day\r\n+    }\r\n+\r\n+    res.json(trend);\r\n+  } catch (err) {\r\n+    console.error('Revenue trend error:', err);\r\n+    res.status(500).json({ error: 'Failed to fetch revenue trend' });\r\n+  }\r\n+});\r\n+\r\n+\r\n+\r\n+\r\n+router.post('/:memberId/payment-method', async (req, res) => {\r\n+  try {\r\n+    const { memberId } = req.params;\r\n+    const { cardNumber, expiry, cvc } = req.body;\r\n+\r\n+    const last4 = cardNumber.slice(-4);\r\n+    const [expMonthStr, expYearStr] = expiry.split('/');\r\n+\r\n+    const brand = 'visa'; // placeholder â€” you'd detect brand in real Stripe integration\r\n+    const stripePaymentMethodId = `fake_${Math.random().toString(36).substring(2, 10)}`; // mock ID\r\n+\r\n+    const method = await prisma.paymentMethod.create({\r\n+      data: {\r\n+        memberId,\r\n+        stripePaymentMethodId,\r\n+        cardBrand: brand,\r\n+        last4,\r\n+        expMonth: parseInt(expMonthStr),\r\n+        expYear: parseInt('20' + expYearStr), // e.g., 25 -> 2025\r\n+      },\r\n+    });\r\n+\r\n+    res.status(201).json(method);\r\n+  } catch (err) {\r\n+    console.error('Save Payment Method Error:', err);\r\n+    res.status(500).json({ error: 'Failed to save payment method' });\r\n+  }\r\n+});\r\n+\r\n+\r\n+router.patch('/invoices/:id/pay', async (req, res) => {\r\n+  try {\r\n+    const { id } = req.params;\r\n+\r\n+    const invoice = await prisma.invoice.update({\r\n+      where: { id },\r\n+      data: { status: 'paid' },\r\n+    });\r\n+\r\n+    res.json(invoice);\r\n+  } catch (err) {\r\n+    console.error('Invoice payment error:', err);\r\n+    res.status(500).json({ error: 'Failed to mark invoice as paid' });\r\n+  }\r\n+});\r\n+\r\n+// router.get('/', async (req, res) => {\r\n+//   const { clubId, startDate, endDate, type } = req.query;\r\n+\r\n+//   if (!clubId) return res.status(400).json({ error: 'Missing clubId' });\r\n+\r\n+//   try {\r\n+//     const invoices = await prisma.invoice.findMany({\r\n+//       where: {\r\n+//         clubId: String(clubId),\r\n+//         issuedAt: {\r\n+//           gte: startDate ? new Date(String(startDate)) : undefined,\r\n+//           lte: endDate ? new Date(String(endDate)) : undefined,\r\n+//         },\r\n+//         ...(type && { member: { membershipType: String(type) } }),\r\n+//       },\r\n+//      include: {\r\n+//         member: {\r\n+//           select: { firstName: true, lastName: true },\r\n+//         },\r\n+//       },\r\n+//       orderBy: { issuedAt: 'desc' },\r\n+//     });\r\n+\r\n+//     const response = invoices.map(inv => ({\r\n+//       id: inv.id,\r\n+//       memberName: `${inv.member.firstName} ${inv.member.lastName}`,\r\n+//       amount: inv.amount,\r\n+//       status: inv.status,\r\n+//       issuedAt: inv.issuedAt,\r\n+//       dueDate: inv.dueDate,\r\n+//     }));\r\n+\r\n+//     res.json(response);\r\n+//   } catch (err) {\r\n+//     console.error('Error fetching billing data:', err);\r\n+//     res.status(500).json({ error: 'Internal server error' });\r\n+//   }\r\n+// });\r\n+\r\n+\r\n+router.get('/', async (req, res) => {\r\n+  const { clubId, startDate, endDate, type, limit } = req.query; // Add limit to query params\r\n+  const take = parseInt(limit as string) || undefined; // Parse limit, default to undefined if not provided\r\n+\r\n+  // IMPORTANT CHANGE: Remove the direct 400 error if clubId is missing.\r\n+  // if (!clubId) return res.status(400).json({ error: 'Missing clubId' }); // <-- REMOVE THIS LINE\r\n+\r\n+  let whereClause: any = {\r\n+    issuedAt: {\r\n+      gte: startDate ? new Date(String(startDate)) : undefined,\r\n+      lte: endDate ? new Date(String(endDate)) : undefined,\r\n+    },\r\n+    ...(type && { member: { memberType: String(type) } }), // Corrected from membershipType to memberType as per schema\r\n+  };\r\n+\r\n+  if (clubId) {\r\n+    whereClause.clubId = String(clubId);\r\n+  } else {\r\n+    console.log('Backend /api/billing: No clubId provided, fetching GLOBAL invoices.');\r\n+  }\r\n+\r\n+  try {\r\n+    const invoices = await prisma.invoice.findMany({\r\n+      where: whereClause, // Use the dynamically built whereClause\r\n+      include: {\r\n+        member: {\r\n+          select: { firstName: true, lastName: true },\r\n+        },\r\n+      },\r\n+      orderBy: { issuedAt: 'desc' },\r\n+      take: take, // Apply the limit\r\n+    });\r\n+\r\n+    const response = invoices.map(inv => ({\r\n+      id: inv.id,\r\n+      memberName: inv.member ? `${inv.member.firstName} ${inv.member.lastName}` : 'Unknown Member',\r\n+      amount: inv.amount,\r\n+      status: inv.status,\r\n+      issuedAt: inv.issuedAt,\r\n+      dueDate: inv.dueDate,\r\n+    }));\r\n+\r\n+    res.json(response);\r\n+  } catch (err) {\r\n+    console.error('Error fetching billing data:', err);\r\n+    res.status(500).json({ error: 'Internal server error' });\r\n+  }\r\n+});\r\n+\r\n+router.get('/:memberId', async (req, res) => {\r\n+  try {\r\n+    const { memberId } = req.params;\r\n+\r\n+    const paymentMethod = await prisma.paymentMethod.findUnique({\r\n+      where: { memberId },\r\n+    });\r\n+\r\n+    const invoices = await prisma.invoice.findMany({\r\n+      where: { memberId },\r\n+      orderBy: { issuedAt: 'desc' },\r\n+    });\r\n+\r\n+    res.json({ paymentMethod, invoices });\r\n+  } catch (err) {\r\n+    console.error('Fetch billing error:', err);\r\n+    res.status(500).json({ error: 'Failed to fetch billing data' });\r\n+  }\r\n+});\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+export default router;\r\n+\r\n+\r\n+\r\n+\r\n+\r\n"
                },
                {
                    "date": 1753171637650,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -353,18 +353,21 @@\n     console.log('Backend /api/billing/revenue-trend: No clubId provided, fetching GLOBAL revenue trend.');\r\n   }\r\n \r\n   try {\r\n-    const results = await prisma.invoice.groupBy({\r\n-      by: ['issuedAt'], // Group by the date the invoice was issued\r\n-      where: whereClause, // Apply the dynamic where clause\r\n-      _sum: {\r\n-        amount: true,\r\n-      },\r\n-      orderBy: {\r\n-        issuedAt: 'asc',\r\n-      },\r\n-    });\r\n+    const results = await prisma.$queryRawUnsafe<\r\n+  { date: string; revenue: number }[]\r\n+>(`\r\n+  SELECT \r\n+    DATE(\"issuedAt\") AS date, \r\n+    SUM(\"amount\") AS revenue \r\n+  FROM \"Invoice\"\r\n+  WHERE \"status\" = 'paid'\r\n+    AND \"issuedAt\" BETWEEN $1 AND $2\r\n+    ${clubId ? `AND \"clubId\" = '${clubId}'` : ''}\r\n+  GROUP BY DATE(\"issuedAt\")\r\n+  ORDER BY DATE(\"issuedAt\") ASC\r\n+`, start, end);\r\n \r\n     // Fill in missing dates with 0 revenue to ensure a continuous trend line\r\n     const trend: { date: string; revenue: number }[] = [];\r\n     let currentDate = new Date(start);\r\n@@ -557,1089 +560,4 @@\n \r\n \r\n \r\n \r\n-//src/routes/billing.routes.ts\r\n-import express from 'express';\r\n-import { PrismaClient } from '@prisma/client';\r\n-import { Request, Response } from 'express';\r\n-\r\n-const router = express.Router();\r\n-const prisma = new PrismaClient();\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-//   const { memberId } = req.params;\r\n-\r\n-//   try {\r\n-//     const member = await prisma.member.findUnique({\r\n-//       where: { id: memberId },\r\n-//       include: {\r\n-//         paymentMethod: true,\r\n-//         // If you add invoice model later, include it here too\r\n-//         // invoices: true,\r\n-//       },\r\n-//     });\r\n-\r\n-//     if (!member) {\r\n-//       return res.status(404).json({ error: 'Member not found' });\r\n-//     }\r\n-\r\n-//     res.json({\r\n-//       paymentMethod: member.paymentMethod,\r\n-//       invoices: [], // Temporary â€” until invoices are added\r\n-//     });\r\n-//   } catch (err) {\r\n-//     console.error('Fetch billing error:', err);\r\n-//     res.status(500).json({ error: 'Failed to fetch billing data' });\r\n-//   }\r\n-// });\r\n-\r\n-\r\n-\r\n-// GET /api/billing/recent?limit=5\r\n-router.get('/recent', async (req, res) => {\r\n-  const limit = parseInt(req.query.limit as string) || 5;\r\n-\r\n-  try {\r\n-    const invoices = await prisma.invoice.findMany({\r\n-      orderBy: { issuedAt: 'desc' },\r\n-      take: limit,\r\n-      include: {\r\n-        member: {\r\n-          select: { firstName: true, lastName: true },\r\n-        },\r\n-        club: {\r\n-          select: { name: true },\r\n-        },\r\n-      },\r\n-    });\r\n-\r\n-    const result = invoices.map((inv) => ({\r\n-      id: inv.id,\r\n-       memberName: inv.member ? `${inv.member.firstName} ${inv.member.lastName}` : 'Unknown Member',\r\n-      amount: inv.amount,\r\n-      status: inv.status,\r\n-      issuedAt: inv.issuedAt,\r\n-      dueDate: inv.dueDate,\r\n-      clubName: inv.club.name,\r\n-    }));\r\n-\r\n-    res.json(result);\r\n-  } catch (err) {\r\n-    console.error('Error fetching recent invoices:', err);\r\n-    res.status(500).json({ error: 'Internal server error' });\r\n-  }\r\n-});\r\n-\r\n-// router.get('/summary', async (req, res) => {\r\n-//   const { clubId, startDate, endDate } = req.query;\r\n-\r\n-//   if (!clubId) return res.status(400).json({ error: 'Missing clubId' });\r\n-\r\n-//   try {\r\n-//     const filters = {\r\n-//       clubId: String(clubId),\r\n-//       issuedAt: {\r\n-//         gte: startDate ? new Date(String(startDate)) : undefined,\r\n-//         lte: endDate ? new Date(String(endDate)) : undefined,\r\n-//       },\r\n-//     };\r\n-\r\n-//     const [totalRevenue, unpaidDues, activeMembers] = await Promise.all([\r\n-//       prisma.invoice.aggregate({\r\n-//         where: { ...filters, status: 'paid' },\r\n-//         _sum: { amount: true },\r\n-//       }),\r\n-//       prisma.invoice.aggregate({\r\n-//         where: { ...filters, status: { in: ['unpaid', 'overdue', 'failed'] } },\r\n-//         _sum: { amount: true },\r\n-//       }),\r\n-//       prisma.member.count({\r\n-//         where: { clubId: String(clubId), memberType: 'member' },\r\n-//       }),\r\n-//     ]);\r\n-\r\n-//     res.json({\r\n-//       totalRevenue: totalRevenue._sum.amount ?? 0,\r\n-//       unpaidDues: unpaidDues._sum.amount ?? 0,\r\n-//       activeMembers,\r\n-//       attendanceRate: 78, // placeholder until real logic exists\r\n-//     });\r\n-//   } catch (err) {\r\n-//     console.error('Summary error:', err);\r\n-//     res.status(500).json({ error: 'Failed to calculate summary' });\r\n-//   }\r\n-// });\r\n-// router.get('/summary', async (req, res) => {\r\n-//   const { clubId, startDate, endDate } = req.query;\r\n-\r\n-//   // IMPORTANT CHANGE: Remove the direct 400 error if clubId is missing.\r\n-//   // Instead, we'll build the filters conditionally.\r\n-//   // if (!clubId) return res.status(400).json({ error: 'Missing clubId' }); // <-- REMOVE THIS LINE\r\n-\r\n-//   // Build filters object conditionally\r\n-//   let invoiceFilters: any = {\r\n-//     issuedAt: {\r\n-//       gte: startDate ? new Date(String(startDate)) : undefined,\r\n-//       lte: endDate ? new Date(String(endDate)) : undefined,\r\n-//     },\r\n-//   };\r\n-\r\n-//   let memberCountFilters: any = {\r\n-//     memberType: 'member' // Always count members, not prospects, for this summary\r\n-//   };\r\n-\r\n-  \r\n-\r\n-//   // If clubId is provided, apply the filter to both invoice and member queries\r\n-//   if (clubId) {\r\n-//     invoiceFilters.clubId = String(clubId);\r\n-//     memberCountFilters.clubId = String(clubId);\r\n-//   }\r\n-\r\n-//   try {\r\n-//     const [totalRevenueResult, unpaidDuesResult, activeMembersCount] = await Promise.all([\r\n-//       prisma.invoice.aggregate({\r\n-//         where: { ...invoiceFilters, status: 'paid' },\r\n-//         _sum: { amount: true },\r\n-//       }),\r\n-//       prisma.invoice.aggregate({\r\n-//         where: { ...invoiceFilters, status: { in: ['unpaid', 'overdue', 'failed'] } },\r\n-//         _sum: { amount: true },\r\n-//       }),\r\n-//       prisma.member.count({\r\n-//         where: memberCountFilters, // Use the dynamically built memberCountFilters\r\n-//       }),\r\n-//     ]);\r\n-\r\n-//     res.json({\r\n-//       totalRevenue: totalRevenueResult._sum.amount ?? 0,\r\n-//       unpaidDues: unpaidDuesResult._sum.amount ?? 0,\r\n-//       activeMembers: activeMembersCount,\r\n-//       attendanceRate: 78, // placeholder until real logic exists\r\n-//     });\r\n-//   } catch (err) {\r\n-//     console.error('Summary error:', err);\r\n-//     res.status(500).json({ error: 'Failed to calculate summary' });\r\n-//   }\r\n-// });\r\n-\r\n-\r\n-router.get('/summary', async (req, res) => {\r\n-  const { clubId, startDate, endDate } = req.query;\r\n-\r\n-  let invoiceFilters: any = {\r\n-    issuedAt: {\r\n-      gte: startDate ? new Date(String(startDate)) : undefined,\r\n-      lte: endDate ? new Date(String(endDate)) : undefined,\r\n-    },\r\n-  };\r\n-\r\n-  let memberCountFilters: any = {\r\n-    memberType: 'member'\r\n-  };\r\n-\r\n-  // Define date filters for attendance/schedule queries\r\n-  const attendanceDateFilters = {\r\n-    gte: startDate ? new Date(String(startDate)) : undefined,\r\n-    lte: endDate ? new Date(String(endDate)) : undefined,\r\n-  };\r\n-\r\n-  // If clubId is provided, apply the filter to all queries\r\n-  if (clubId) {\r\n-    invoiceFilters.clubId = String(clubId);\r\n-    memberCountFilters.clubId = String(clubId);\r\n-  } else {\r\n-    console.log('Backend /api/billing/summary: No clubId provided, fetching GLOBAL summary.');\r\n-  }\r\n-\r\n-  try {\r\n-    const [totalRevenueResult, unpaidDuesResult, activeMembersCount, totalBookingsResult, totalAttendancesResult] = await Promise.all([\r\n-      prisma.invoice.aggregate({\r\n-        where: { ...invoiceFilters, status: 'paid' },\r\n-        _sum: { amount: true },\r\n-      }),\r\n-      prisma.invoice.aggregate({\r\n-        where: { ...invoiceFilters, status: { in: ['unpaid', 'overdue', 'failed'] } },\r\n-        _sum: { amount: true },\r\n-      }),\r\n-      prisma.member.count({\r\n-        where: memberCountFilters,\r\n-      }),\r\n-      // New: Count total confirmed bookings for classes within the period\r\n-      prisma.booking.count({\r\n-        where: {\r\n-          status: 'confirmed',\r\n-          schedule: {\r\n-            date: attendanceDateFilters,\r\n-            ...(clubId && { clubId: String(clubId) }), // Apply clubId filter if present\r\n-          },\r\n-        },\r\n-      }),\r\n-      // New: Count total present attendances for classes within the period\r\n-      prisma.attendance.count({\r\n-        where: {\r\n-          status: 'present',\r\n-          markedAt: attendanceDateFilters, // Attendance markedAt should be within the period\r\n-          ...(clubId && { clubId: String(clubId) }), // Apply clubId filter if present\r\n-        },\r\n-      }),\r\n-    ]);\r\n-\r\n-    const totalConfirmedBookings = totalBookingsResult ?? 0;\r\n-    const totalPresentAttendances = totalAttendancesResult ?? 0;\r\n-\r\n-    let attendanceRate = 0;\r\n-    if (totalConfirmedBookings > 0) {\r\n-      attendanceRate = (totalPresentAttendances / totalConfirmedBookings) * 100;\r\n-    }\r\n-\r\n-    res.json({\r\n-      totalRevenue: totalRevenueResult._sum.amount ?? 0,\r\n-      unpaidDues: unpaidDuesResult._sum.amount ?? 0,\r\n-      activeMembers: activeMembersCount,\r\n-      attendanceRate: parseFloat(attendanceRate.toFixed(2)), // Format to 2 decimal places\r\n-    });\r\n-  } catch (err) {\r\n-    console.error('Summary error:', err);\r\n-    res.status(500).json({ error: 'Failed to calculate summary' });\r\n-  }\r\n-});\r\n-\r\n-router.get('/members', async (req, res) => {\r\n-  const { clubId, membershipType } = req.query;\r\n-\r\n-  if (!clubId) {\r\n-    return res.status(400).json({ error: 'clubId is required' });\r\n-  }\r\n-\r\n-  try {\r\n-    const members = await prisma.member.findMany({\r\n-      where: {\r\n-        clubId: String(clubId),\r\n-        ...(membershipType && { memberType: String(membershipType) }),\r\n-      },\r\n-      orderBy: { createdAt: 'desc' },\r\n-    });\r\n-\r\n-    const response = members.map((m) => ({\r\n-      id: m.id,\r\n-      firstName: m.firstName,\r\n-      lastName: m.lastName,\r\n-      memberType: m.memberType,\r\n-      createdAt: m.createdAt,\r\n-    }));\r\n-\r\n-    res.json(response);\r\n-  } catch (err) {\r\n-    console.error('Fetch members error:', err);\r\n-    res.status(500).json({ error: 'Failed to fetch members' });\r\n-  }\r\n-});\r\n-\r\n-router.get('/monthly-revenue', async (req, res) => {\r\n-  const { clubId, month, year } = req.query; // month (1-12), year (e.g., 2023)\r\n-\r\n-  const currentYear = year ? parseInt(year as string) : new Date().getFullYear();\r\n-  const currentMonth = month ? parseInt(month as string) - 1 : new Date().getMonth();\r\n-\r\n-  const startDate = new Date(currentYear, currentMonth, 1);\r\n-  const endDate = new Date(currentYear, currentMonth + 1, 0);\r\n-\r\n-  let invoiceFilters: any = {\r\n-    status: 'paid',\r\n-    issuedAt: {\r\n-      gte: startDate,\r\n-      lte: endDate,\r\n-    },\r\n-  };\r\n-\r\n-  if (clubId) {\r\n-    invoiceFilters.clubId = String(clubId);\r\n-  } else {\r\n-    console.log('Backend /api/billing/monthly-revenue: No clubId provided, fetching GLOBAL monthly revenue.');\r\n-  }\r\n-\r\n-  try {\r\n-    const monthlyRevenueResult = await prisma.invoice.aggregate({\r\n-      where: invoiceFilters,\r\n-      _sum: { amount: true },\r\n-    });\r\n-\r\n-    const totalMonthlyRevenue = monthlyRevenueResult._sum.amount ?? 0;\r\n-\r\n-    res.json({ monthlyRevenue: totalMonthlyRevenue });\r\n-  } catch (err) {\r\n-    console.error('Error fetching monthly revenue:', err);\r\n-    res.status(500).json({ error: 'Failed to fetch monthly revenue' });\r\n-  }\r\n-});\r\n-\r\n-router.get('/revenue-trend', async (req, res) => {\r\n-  const { clubId, startDate, endDate } = req.query; // Add startDate and endDate for optional filtering\r\n-\r\n-  // IMPORTANT CHANGE: Remove the direct 400 error if clubId is missing.\r\n-  // if (!clubId) return res.status(400).json({ error: 'Missing clubId' }); // <-- REMOVE THIS LINE\r\n-\r\n-  // Define date range. Default to last 30 days if not provided, or a larger range.\r\n-  // For a trend graph, a default range is usually good. Let's use 90 days for example.\r\n-  const defaultDays = 90;\r\n-  const end = endDate ? new Date(String(endDate)) : new Date();\r\n-  const start = startDate ? new Date(String(startDate)) : new Date();\r\n-  if (!startDate) { // If no startDate provided, default to 90 days ago\r\n-    start.setDate(end.getDate() - defaultDays);\r\n-  }\r\n-\r\n-  start.setHours(0, 0, 0, 0); // Set to start of the day\r\n-  end.setHours(23, 59, 59, 999); // Set to end of the day\r\n-\r\n-  let whereClause: any = {\r\n-    status: 'paid', // Only sum paid invoices\r\n-    issuedAt: {\r\n-      gte: start,\r\n-      lte: end,\r\n-    },\r\n-  };\r\n-\r\n-  // Conditionally add clubId to whereClause\r\n-  if (clubId) {\r\n-    whereClause.clubId = String(clubId);\r\n-    console.log(`Backend /api/billing/revenue-trend: clubId provided (${clubId}), fetching club-specific revenue trend.`);\r\n-  } else {\r\n-    console.log('Backend /api/billing/revenue-trend: No clubId provided, fetching GLOBAL revenue trend.');\r\n-  }\r\n-\r\n-  try {\r\n-    const results = await prisma.invoice.groupBy({\r\n-      by: ['issuedAt'], // Group by the date the invoice was issued\r\n-      where: whereClause, // Apply the dynamic where clause\r\n-      _sum: {\r\n-        amount: true,\r\n-      },\r\n-      orderBy: {\r\n-        issuedAt: 'asc',\r\n-      },\r\n-    });\r\n-\r\n-    // Fill in missing dates with 0 revenue to ensure a continuous trend line\r\n-    const trend: { date: string; revenue: number }[] = [];\r\n-    let currentDate = new Date(start);\r\n-    while (currentDate <= end) {\r\n-      const dateKey = currentDate.toISOString().split('T')[0];\r\n-      const found = results.find(r => r.issuedAt.toISOString().split('T')[0] === dateKey);\r\n-      trend.push({\r\n-        date: dateKey,\r\n-        revenue: found ? (found._sum.amount ?? 0) : 0,\r\n-      });\r\n-      currentDate.setDate(currentDate.getDate() + 1); // Move to the next day\r\n-    }\r\n-\r\n-    res.json(trend);\r\n-  } catch (err) {\r\n-    console.error('Revenue trend error:', err);\r\n-    res.status(500).json({ error: 'Failed to fetch revenue trend' });\r\n-  }\r\n-});\r\n-\r\n-\r\n-\r\n-\r\n-router.post('/:memberId/payment-method', async (req, res) => {\r\n-  try {\r\n-    const { memberId } = req.params;\r\n-    const { cardNumber, expiry, cvc } = req.body;\r\n-\r\n-    const last4 = cardNumber.slice(-4);\r\n-    const [expMonthStr, expYearStr] = expiry.split('/');\r\n-\r\n-    const brand = 'visa'; // placeholder â€” you'd detect brand in real Stripe integration\r\n-    const stripePaymentMethodId = `fake_${Math.random().toString(36).substring(2, 10)}`; // mock ID\r\n-\r\n-    const method = await prisma.paymentMethod.create({\r\n-      data: {\r\n-        memberId,\r\n-        stripePaymentMethodId,\r\n-        cardBrand: brand,\r\n-        last4,\r\n-        expMonth: parseInt(expMonthStr),\r\n-        expYear: parseInt('20' + expYearStr), // e.g., 25 -> 2025\r\n-      },\r\n-    });\r\n-\r\n-    res.status(201).json(method);\r\n-  } catch (err) {\r\n-    console.error('Save Payment Method Error:', err);\r\n-    res.status(500).json({ error: 'Failed to save payment method' });\r\n-  }\r\n-});\r\n-\r\n-\r\n-router.patch('/invoices/:id/pay', async (req, res) => {\r\n-  try {\r\n-    const { id } = req.params;\r\n-\r\n-    const invoice = await prisma.invoice.update({\r\n-      where: { id },\r\n-      data: { status: 'paid' },\r\n-    });\r\n-\r\n-    res.json(invoice);\r\n-  } catch (err) {\r\n-    console.error('Invoice payment error:', err);\r\n-    res.status(500).json({ error: 'Failed to mark invoice as paid' });\r\n-  }\r\n-});\r\n-\r\n-// router.get('/', async (req, res) => {\r\n-//   const { clubId, startDate, endDate, type } = req.query;\r\n-\r\n-//   if (!clubId) return res.status(400).json({ error: 'Missing clubId' });\r\n-\r\n-//   try {\r\n-//     const invoices = await prisma.invoice.findMany({\r\n-//       where: {\r\n-//         clubId: String(clubId),\r\n-//         issuedAt: {\r\n-//           gte: startDate ? new Date(String(startDate)) : undefined,\r\n-//           lte: endDate ? new Date(String(endDate)) : undefined,\r\n-//         },\r\n-//         ...(type && { member: { membershipType: String(type) } }),\r\n-//       },\r\n-//      include: {\r\n-//         member: {\r\n-//           select: { firstName: true, lastName: true },\r\n-//         },\r\n-//       },\r\n-//       orderBy: { issuedAt: 'desc' },\r\n-//     });\r\n-\r\n-//     const response = invoices.map(inv => ({\r\n-//       id: inv.id,\r\n-//       memberName: `${inv.member.firstName} ${inv.member.lastName}`,\r\n-//       amount: inv.amount,\r\n-//       status: inv.status,\r\n-//       issuedAt: inv.issuedAt,\r\n-//       dueDate: inv.dueDate,\r\n-//     }));\r\n-\r\n-//     res.json(response);\r\n-//   } catch (err) {\r\n-//     console.error('Error fetching billing data:', err);\r\n-//     res.status(500).json({ error: 'Internal server error' });\r\n-//   }\r\n-// });\r\n-\r\n-\r\n-router.get('/', async (req, res) => {\r\n-  const { clubId, startDate, endDate, type, limit } = req.query; // Add limit to query params\r\n-  const take = parseInt(limit as string) || undefined; // Parse limit, default to undefined if not provided\r\n-\r\n-  // IMPORTANT CHANGE: Remove the direct 400 error if clubId is missing.\r\n-  // if (!clubId) return res.status(400).json({ error: 'Missing clubId' }); // <-- REMOVE THIS LINE\r\n-\r\n-  let whereClause: any = {\r\n-    issuedAt: {\r\n-      gte: startDate ? new Date(String(startDate)) : undefined,\r\n-      lte: endDate ? new Date(String(endDate)) : undefined,\r\n-    },\r\n-    ...(type && { member: { memberType: String(type) } }), // Corrected from membershipType to memberType as per schema\r\n-  };\r\n-\r\n-  if (clubId) {\r\n-    whereClause.clubId = String(clubId);\r\n-  } else {\r\n-    console.log('Backend /api/billing: No clubId provided, fetching GLOBAL invoices.');\r\n-  }\r\n-\r\n-  try {\r\n-    const invoices = await prisma.invoice.findMany({\r\n-      where: whereClause, // Use the dynamically built whereClause\r\n-      include: {\r\n-        member: {\r\n-          select: { firstName: true, lastName: true },\r\n-        },\r\n-      },\r\n-      orderBy: { issuedAt: 'desc' },\r\n-      take: take, // Apply the limit\r\n-    });\r\n-\r\n-    const response = invoices.map(inv => ({\r\n-      id: inv.id,\r\n-      memberName: inv.member ? `${inv.member.firstName} ${inv.member.lastName}` : 'Unknown Member',\r\n-      amount: inv.amount,\r\n-      status: inv.status,\r\n-      issuedAt: inv.issuedAt,\r\n-      dueDate: inv.dueDate,\r\n-    }));\r\n-\r\n-    res.json(response);\r\n-  } catch (err) {\r\n-    console.error('Error fetching billing data:', err);\r\n-    res.status(500).json({ error: 'Internal server error' });\r\n-  }\r\n-});\r\n-\r\n-router.get('/:memberId', async (req, res) => {\r\n-  try {\r\n-    const { memberId } = req.params;\r\n-\r\n-    const paymentMethod = await prisma.paymentMethod.findUnique({\r\n-      where: { memberId },\r\n-    });\r\n-\r\n-    const invoices = await prisma.invoice.findMany({\r\n-      where: { memberId },\r\n-      orderBy: { issuedAt: 'desc' },\r\n-    });\r\n-\r\n-    res.json({ paymentMethod, invoices });\r\n-  } catch (err) {\r\n-    console.error('Fetch billing error:', err);\r\n-    res.status(500).json({ error: 'Failed to fetch billing data' });\r\n-  }\r\n-});\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-export default router;\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-//src/routes/billing.routes.ts\r\n-import express from 'express';\r\n-import { PrismaClient } from '@prisma/client';\r\n-import { Request, Response } from 'express';\r\n-\r\n-const router = express.Router();\r\n-const prisma = new PrismaClient();\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-//   const { memberId } = req.params;\r\n-\r\n-//   try {\r\n-//     const member = await prisma.member.findUnique({\r\n-//       where: { id: memberId },\r\n-//       include: {\r\n-//         paymentMethod: true,\r\n-//         // If you add invoice model later, include it here too\r\n-//         // invoices: true,\r\n-//       },\r\n-//     });\r\n-\r\n-//     if (!member) {\r\n-//       return res.status(404).json({ error: 'Member not found' });\r\n-//     }\r\n-\r\n-//     res.json({\r\n-//       paymentMethod: member.paymentMethod,\r\n-//       invoices: [], // Temporary â€” until invoices are added\r\n-//     });\r\n-//   } catch (err) {\r\n-//     console.error('Fetch billing error:', err);\r\n-//     res.status(500).json({ error: 'Failed to fetch billing data' });\r\n-//   }\r\n-// });\r\n-\r\n-\r\n-\r\n-// GET /api/billing/recent?limit=5\r\n-router.get('/recent', async (req, res) => {\r\n-  const limit = parseInt(req.query.limit as string) || 5;\r\n-\r\n-  try {\r\n-    const invoices = await prisma.invoice.findMany({\r\n-      orderBy: { issuedAt: 'desc' },\r\n-      take: limit,\r\n-      include: {\r\n-        member: {\r\n-          select: { firstName: true, lastName: true },\r\n-        },\r\n-        club: {\r\n-          select: { name: true },\r\n-        },\r\n-      },\r\n-    });\r\n-\r\n-    const result = invoices.map((inv) => ({\r\n-      id: inv.id,\r\n-      memberName: `${inv.member.firstName} ${inv.member.lastName}`,\r\n-      amount: inv.amount,\r\n-      status: inv.status,\r\n-      issuedAt: inv.issuedAt,\r\n-      dueDate: inv.dueDate,\r\n-      clubName: inv.club.name,\r\n-    }));\r\n-\r\n-    res.json(result);\r\n-  } catch (err) {\r\n-    console.error('Error fetching recent invoices:', err);\r\n-    res.status(500).json({ error: 'Internal server error' });\r\n-  }\r\n-});\r\n-\r\n-// router.get('/summary', async (req, res) => {\r\n-//   const { clubId, startDate, endDate } = req.query;\r\n-\r\n-//   if (!clubId) return res.status(400).json({ error: 'Missing clubId' });\r\n-\r\n-//   try {\r\n-//     const filters = {\r\n-//       clubId: String(clubId),\r\n-//       issuedAt: {\r\n-//         gte: startDate ? new Date(String(startDate)) : undefined,\r\n-//         lte: endDate ? new Date(String(endDate)) : undefined,\r\n-//       },\r\n-//     };\r\n-\r\n-//     const [totalRevenue, unpaidDues, activeMembers] = await Promise.all([\r\n-//       prisma.invoice.aggregate({\r\n-//         where: { ...filters, status: 'paid' },\r\n-//         _sum: { amount: true },\r\n-//       }),\r\n-//       prisma.invoice.aggregate({\r\n-//         where: { ...filters, status: { in: ['unpaid', 'overdue', 'failed'] } },\r\n-//         _sum: { amount: true },\r\n-//       }),\r\n-//       prisma.member.count({\r\n-//         where: { clubId: String(clubId), memberType: 'member' },\r\n-//       }),\r\n-//     ]);\r\n-\r\n-//     res.json({\r\n-//       totalRevenue: totalRevenue._sum.amount ?? 0,\r\n-//       unpaidDues: unpaidDues._sum.amount ?? 0,\r\n-//       activeMembers,\r\n-//       attendanceRate: 78, // placeholder until real logic exists\r\n-//     });\r\n-//   } catch (err) {\r\n-//     console.error('Summary error:', err);\r\n-//     res.status(500).json({ error: 'Failed to calculate summary' });\r\n-//   }\r\n-// });\r\n-// router.get('/summary', async (req, res) => {\r\n-//   const { clubId, startDate, endDate } = req.query;\r\n-\r\n-//   // IMPORTANT CHANGE: Remove the direct 400 error if clubId is missing.\r\n-//   // Instead, we'll build the filters conditionally.\r\n-//   // if (!clubId) return res.status(400).json({ error: 'Missing clubId' }); // <-- REMOVE THIS LINE\r\n-\r\n-//   // Build filters object conditionally\r\n-//   let invoiceFilters: any = {\r\n-//     issuedAt: {\r\n-//       gte: startDate ? new Date(String(startDate)) : undefined,\r\n-//       lte: endDate ? new Date(String(endDate)) : undefined,\r\n-//     },\r\n-//   };\r\n-\r\n-//   let memberCountFilters: any = {\r\n-//     memberType: 'member' // Always count members, not prospects, for this summary\r\n-//   };\r\n-\r\n-  \r\n-\r\n-//   // If clubId is provided, apply the filter to both invoice and member queries\r\n-//   if (clubId) {\r\n-//     invoiceFilters.clubId = String(clubId);\r\n-//     memberCountFilters.clubId = String(clubId);\r\n-//   }\r\n-\r\n-//   try {\r\n-//     const [totalRevenueResult, unpaidDuesResult, activeMembersCount] = await Promise.all([\r\n-//       prisma.invoice.aggregate({\r\n-//         where: { ...invoiceFilters, status: 'paid' },\r\n-//         _sum: { amount: true },\r\n-//       }),\r\n-//       prisma.invoice.aggregate({\r\n-//         where: { ...invoiceFilters, status: { in: ['unpaid', 'overdue', 'failed'] } },\r\n-//         _sum: { amount: true },\r\n-//       }),\r\n-//       prisma.member.count({\r\n-//         where: memberCountFilters, // Use the dynamically built memberCountFilters\r\n-//       }),\r\n-//     ]);\r\n-\r\n-//     res.json({\r\n-//       totalRevenue: totalRevenueResult._sum.amount ?? 0,\r\n-//       unpaidDues: unpaidDuesResult._sum.amount ?? 0,\r\n-//       activeMembers: activeMembersCount,\r\n-//       attendanceRate: 78, // placeholder until real logic exists\r\n-//     });\r\n-//   } catch (err) {\r\n-//     console.error('Summary error:', err);\r\n-//     res.status(500).json({ error: 'Failed to calculate summary' });\r\n-//   }\r\n-// });\r\n-\r\n-\r\n-router.get('/summary', async (req, res) => {\r\n-  const { clubId, startDate, endDate } = req.query;\r\n-\r\n-  let invoiceFilters: any = {\r\n-    issuedAt: {\r\n-      gte: startDate ? new Date(String(startDate)) : undefined,\r\n-      lte: endDate ? new Date(String(endDate)) : undefined,\r\n-    },\r\n-  };\r\n-\r\n-  let memberCountFilters: any = {\r\n-    memberType: 'member'\r\n-  };\r\n-\r\n-  // Define date filters for attendance/schedule queries\r\n-  const attendanceDateFilters = {\r\n-    gte: startDate ? new Date(String(startDate)) : undefined,\r\n-    lte: endDate ? new Date(String(endDate)) : undefined,\r\n-  };\r\n-\r\n-  // If clubId is provided, apply the filter to all queries\r\n-  if (clubId) {\r\n-    invoiceFilters.clubId = String(clubId);\r\n-    memberCountFilters.clubId = String(clubId);\r\n-  } else {\r\n-    console.log('Backend /api/billing/summary: No clubId provided, fetching GLOBAL summary.');\r\n-  }\r\n-\r\n-  try {\r\n-    const [totalRevenueResult, unpaidDuesResult, activeMembersCount, totalBookingsResult, totalAttendancesResult] = await Promise.all([\r\n-      prisma.invoice.aggregate({\r\n-        where: { ...invoiceFilters, status: 'paid' },\r\n-        _sum: { amount: true },\r\n-      }),\r\n-      prisma.invoice.aggregate({\r\n-        where: { ...invoiceFilters, status: { in: ['unpaid', 'overdue', 'failed'] } },\r\n-        _sum: { amount: true },\r\n-      }),\r\n-      prisma.member.count({\r\n-        where: memberCountFilters,\r\n-      }),\r\n-      // New: Count total confirmed bookings for classes within the period\r\n-      prisma.booking.count({\r\n-        where: {\r\n-          status: 'confirmed',\r\n-          schedule: {\r\n-            date: attendanceDateFilters,\r\n-            ...(clubId && { clubId: String(clubId) }), // Apply clubId filter if present\r\n-          },\r\n-        },\r\n-      }),\r\n-      // New: Count total present attendances for classes within the period\r\n-      prisma.attendance.count({\r\n-        where: {\r\n-          status: 'present',\r\n-          markedAt: attendanceDateFilters, // Attendance markedAt should be within the period\r\n-          ...(clubId && { clubId: String(clubId) }), // Apply clubId filter if present\r\n-        },\r\n-      }),\r\n-    ]);\r\n-\r\n-    const totalConfirmedBookings = totalBookingsResult ?? 0;\r\n-    const totalPresentAttendances = totalAttendancesResult ?? 0;\r\n-\r\n-    let attendanceRate = 0;\r\n-    if (totalConfirmedBookings > 0) {\r\n-      attendanceRate = (totalPresentAttendances / totalConfirmedBookings) * 100;\r\n-    }\r\n-\r\n-    res.json({\r\n-      totalRevenue: totalRevenueResult._sum.amount ?? 0,\r\n-      unpaidDues: unpaidDuesResult._sum.amount ?? 0,\r\n-      activeMembers: activeMembersCount,\r\n-      attendanceRate: parseFloat(attendanceRate.toFixed(2)), // Format to 2 decimal places\r\n-    });\r\n-  } catch (err) {\r\n-    console.error('Summary error:', err);\r\n-    res.status(500).json({ error: 'Failed to calculate summary' });\r\n-  }\r\n-});\r\n-\r\n-router.get('/members', async (req, res) => {\r\n-  const { clubId, membershipType } = req.query;\r\n-\r\n-  if (!clubId) {\r\n-    return res.status(400).json({ error: 'clubId is required' });\r\n-  }\r\n-\r\n-  try {\r\n-    const members = await prisma.member.findMany({\r\n-      where: {\r\n-        clubId: String(clubId),\r\n-        ...(membershipType && { memberType: String(membershipType) }),\r\n-      },\r\n-      orderBy: { createdAt: 'desc' },\r\n-    });\r\n-\r\n-    const response = members.map((m) => ({\r\n-      id: m.id,\r\n-      firstName: m.firstName,\r\n-      lastName: m.lastName,\r\n-      memberType: m.memberType,\r\n-      createdAt: m.createdAt,\r\n-    }));\r\n-\r\n-    res.json(response);\r\n-  } catch (err) {\r\n-    console.error('Fetch members error:', err);\r\n-    res.status(500).json({ error: 'Failed to fetch members' });\r\n-  }\r\n-});\r\n-\r\n-router.get('/monthly-revenue', async (req, res) => {\r\n-  const { clubId, month, year } = req.query; // month (1-12), year (e.g., 2023)\r\n-\r\n-  const currentYear = year ? parseInt(year as string) : new Date().getFullYear();\r\n-  const currentMonth = month ? parseInt(month as string) - 1 : new Date().getMonth();\r\n-\r\n-  const startDate = new Date(currentYear, currentMonth, 1);\r\n-  const endDate = new Date(currentYear, currentMonth + 1, 0);\r\n-\r\n-  let invoiceFilters: any = {\r\n-    status: 'paid',\r\n-    issuedAt: {\r\n-      gte: startDate,\r\n-      lte: endDate,\r\n-    },\r\n-  };\r\n-\r\n-  if (clubId) {\r\n-    invoiceFilters.clubId = String(clubId);\r\n-  } else {\r\n-    console.log('Backend /api/billing/monthly-revenue: No clubId provided, fetching GLOBAL monthly revenue.');\r\n-  }\r\n-\r\n-  try {\r\n-    const monthlyRevenueResult = await prisma.invoice.aggregate({\r\n-      where: invoiceFilters,\r\n-      _sum: { amount: true },\r\n-    });\r\n-\r\n-    const totalMonthlyRevenue = monthlyRevenueResult._sum.amount ?? 0;\r\n-\r\n-    res.json({ monthlyRevenue: totalMonthlyRevenue });\r\n-  } catch (err) {\r\n-    console.error('Error fetching monthly revenue:', err);\r\n-    res.status(500).json({ error: 'Failed to fetch monthly revenue' });\r\n-  }\r\n-});\r\n-\r\n-router.get('/revenue-trend', async (req, res) => {\r\n-  const { clubId } = req.query;\r\n-\r\n-  if (!clubId) return res.status(400).json({ error: 'Missing clubId' });\r\n-\r\n-  try {\r\n-    const results = await prisma.invoice.groupBy({\r\n-      by: ['issuedAt'],\r\n-      where: {\r\n-        clubId: String(clubId),\r\n-        status: 'paid',\r\n-      },\r\n-      _sum: {\r\n-        amount: true,\r\n-      },\r\n-      orderBy: {\r\n-        issuedAt: 'asc',\r\n-      },\r\n-    });\r\n-\r\n-    const trend = results.map((r) => ({\r\n-      date: r.issuedAt.toISOString().split('T')[0],\r\n-      revenue: r._sum.amount ?? 0,\r\n-    }));\r\n-\r\n-    res.json(trend);\r\n-  } catch (err) {\r\n-    console.error('Revenue trend error:', err);\r\n-    res.status(500).json({ error: 'Failed to fetch revenue trend' });\r\n-  }\r\n-});\r\n-\r\n-\r\n-\r\n-router.post('/:memberId/payment-method', async (req, res) => {\r\n-  try {\r\n-    const { memberId } = req.params;\r\n-    const { cardNumber, expiry, cvc } = req.body;\r\n-\r\n-    const last4 = cardNumber.slice(-4);\r\n-    const [expMonthStr, expYearStr] = expiry.split('/');\r\n-\r\n-    const brand = 'visa'; // placeholder â€” you'd detect brand in real Stripe integration\r\n-    const stripePaymentMethodId = `fake_${Math.random().toString(36).substring(2, 10)}`; // mock ID\r\n-\r\n-    const method = await prisma.paymentMethod.create({\r\n-      data: {\r\n-        memberId,\r\n-        stripePaymentMethodId,\r\n-        cardBrand: brand,\r\n-        last4,\r\n-        expMonth: parseInt(expMonthStr),\r\n-        expYear: parseInt('20' + expYearStr), // e.g., 25 -> 2025\r\n-      },\r\n-    });\r\n-\r\n-    res.status(201).json(method);\r\n-  } catch (err) {\r\n-    console.error('Save Payment Method Error:', err);\r\n-    res.status(500).json({ error: 'Failed to save payment method' });\r\n-  }\r\n-});\r\n-\r\n-\r\n-router.patch('/invoices/:id/pay', async (req, res) => {\r\n-  try {\r\n-    const { id } = req.params;\r\n-\r\n-    const invoice = await prisma.invoice.update({\r\n-      where: { id },\r\n-      data: { status: 'paid' },\r\n-    });\r\n-\r\n-    res.json(invoice);\r\n-  } catch (err) {\r\n-    console.error('Invoice payment error:', err);\r\n-    res.status(500).json({ error: 'Failed to mark invoice as paid' });\r\n-  }\r\n-});\r\n-\r\n-// router.get('/', async (req, res) => {\r\n-//   const { clubId, startDate, endDate, type } = req.query;\r\n-\r\n-//   if (!clubId) return res.status(400).json({ error: 'Missing clubId' });\r\n-\r\n-//   try {\r\n-//     const invoices = await prisma.invoice.findMany({\r\n-//       where: {\r\n-//         clubId: String(clubId),\r\n-//         issuedAt: {\r\n-//           gte: startDate ? new Date(String(startDate)) : undefined,\r\n-//           lte: endDate ? new Date(String(endDate)) : undefined,\r\n-//         },\r\n-//         ...(type && { member: { membershipType: String(type) } }),\r\n-//       },\r\n-//      include: {\r\n-//         member: {\r\n-//           select: { firstName: true, lastName: true },\r\n-//         },\r\n-//       },\r\n-//       orderBy: { issuedAt: 'desc' },\r\n-//     });\r\n-\r\n-//     const response = invoices.map(inv => ({\r\n-//       id: inv.id,\r\n-//       memberName: `${inv.member.firstName} ${inv.member.lastName}`,\r\n-//       amount: inv.amount,\r\n-//       status: inv.status,\r\n-//       issuedAt: inv.issuedAt,\r\n-//       dueDate: inv.dueDate,\r\n-//     }));\r\n-\r\n-//     res.json(response);\r\n-//   } catch (err) {\r\n-//     console.error('Error fetching billing data:', err);\r\n-//     res.status(500).json({ error: 'Internal server error' });\r\n-//   }\r\n-// });\r\n-\r\n-\r\n-router.get('/', async (req, res) => {\r\n-  const { clubId, startDate, endDate, type, limit } = req.query; // Add limit to query params\r\n-  const take = parseInt(limit as string) || undefined; // Parse limit, default to undefined if not provided\r\n-\r\n-  // IMPORTANT CHANGE: Remove the direct 400 error if clubId is missing.\r\n-  // if (!clubId) return res.status(400).json({ error: 'Missing clubId' }); // <-- REMOVE THIS LINE\r\n-\r\n-  let whereClause: any = {\r\n-    issuedAt: {\r\n-      gte: startDate ? new Date(String(startDate)) : undefined,\r\n-      lte: endDate ? new Date(String(endDate)) : undefined,\r\n-    },\r\n-    ...(type && { member: { memberType: String(type) } }), // Corrected from membershipType to memberType as per schema\r\n-  };\r\n-\r\n-  if (clubId) {\r\n-    whereClause.clubId = String(clubId);\r\n-  } else {\r\n-    console.log('Backend /api/billing: No clubId provided, fetching GLOBAL invoices.');\r\n-  }\r\n-\r\n-  try {\r\n-    const invoices = await prisma.invoice.findMany({\r\n-      where: whereClause, // Use the dynamically built whereClause\r\n-      include: {\r\n-        member: {\r\n-          select: { firstName: true, lastName: true },\r\n-        },\r\n-      },\r\n-      orderBy: { issuedAt: 'desc' },\r\n-      take: take, // Apply the limit\r\n-    });\r\n-\r\n-    const response = invoices.map(inv => ({\r\n-      id: inv.id,\r\n-      memberName: `${inv.member.firstName} ${inv.member.lastName}`,\r\n-      amount: inv.amount,\r\n-      status: inv.status,\r\n-      issuedAt: inv.issuedAt,\r\n-      dueDate: inv.dueDate,\r\n-    }));\r\n-\r\n-    res.json(response);\r\n-  } catch (err) {\r\n-    console.error('Error fetching billing data:', err);\r\n-    res.status(500).json({ error: 'Internal server error' });\r\n-  }\r\n-});\r\n-\r\n-router.get('/:memberId', async (req, res) => {\r\n-  try {\r\n-    const { memberId } = req.params;\r\n-\r\n-    const paymentMethod = await prisma.paymentMethod.findUnique({\r\n-      where: { memberId },\r\n-    });\r\n-\r\n-    const invoices = await prisma.invoice.findMany({\r\n-      where: { memberId },\r\n-      orderBy: { issuedAt: 'desc' },\r\n-    });\r\n-\r\n-    res.json({ paymentMethod, invoices });\r\n-  } catch (err) {\r\n-    console.error('Fetch billing error:', err);\r\n-    res.status(500).json({ error: 'Failed to fetch billing data' });\r\n-  }\r\n-});\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-export default router;\r\n-\r\n-\r\n-\r\n-\r\n-\r\n"
                },
                {
                    "date": 1753171684739,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -372,12 +372,12 @@\n     const trend: { date: string; revenue: number }[] = [];\r\n     let currentDate = new Date(start);\r\n     while (currentDate <= end) {\r\n       const dateKey = currentDate.toISOString().split('T')[0];\r\n-      const found = results.find(r => r.issuedAt.toISOString().split('T')[0] === dateKey);\r\n+      const found = results.find(r => r.date === dateKey);\r\n       trend.push({\r\n         date: dateKey,\r\n-        revenue: found ? (found._sum.amount ?? 0) : 0,\r\n+        revenue: found ? Number(found.revenue) : 0,\r\n       });\r\n       currentDate.setDate(currentDate.getDate() + 1); // Move to the next day\r\n     }\r\n \r\n"
                },
                {
                    "date": 1753173667135,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -367,8 +367,10 @@\n   GROUP BY DATE(\"issuedAt\")\r\n   ORDER BY DATE(\"issuedAt\") ASC\r\n `, start, end);\r\n \r\n+console.log('Backend: Raw query results for revenue-trend:', results);\r\n+\r\n     // Fill in missing dates with 0 revenue to ensure a continuous trend line\r\n     const trend: { date: string; revenue: number }[] = [];\r\n     let currentDate = new Date(start);\r\n     while (currentDate <= end) {\r\n@@ -380,8 +382,10 @@\n       });\r\n       currentDate.setDate(currentDate.getDate() + 1); // Move to the next day\r\n     }\r\n \r\n+     console.log('Backend: Processed revenue trend data sent to frontend:', trend); // <-- ADD THIS LINE\r\n+\r\n     res.json(trend);\r\n   } catch (err) {\r\n     console.error('Revenue trend error:', err);\r\n     res.status(500).json({ error: 'Failed to fetch revenue trend' });\r\n"
                },
                {
                    "date": 1753175666647,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -318,84 +318,173 @@\n     res.status(500).json({ error: 'Failed to fetch monthly revenue' });\r\n   }\r\n });\r\n \r\n-router.get('/revenue-trend', async (req, res) => {\r\n-  const { clubId, startDate, endDate } = req.query; // Add startDate and endDate for optional filtering\r\n+// router.get('/revenue-trend', async (req, res) => {\r\n+//   const { clubId, startDate, endDate } = req.query; // Add startDate and endDate for optional filtering\r\n \r\n-  // IMPORTANT CHANGE: Remove the direct 400 error if clubId is missing.\r\n-  // if (!clubId) return res.status(400).json({ error: 'Missing clubId' }); // <-- REMOVE THIS LINE\r\n+//   // IMPORTANT CHANGE: Remove the direct 400 error if clubId is missing.\r\n+//   // if (!clubId) return res.status(400).json({ error: 'Missing clubId' }); // <-- REMOVE THIS LINE\r\n \r\n-  // Define date range. Default to last 30 days if not provided, or a larger range.\r\n-  // For a trend graph, a default range is usually good. Let's use 90 days for example.\r\n+//   // Define date range. Default to last 30 days if not provided, or a larger range.\r\n+//   // For a trend graph, a default range is usually good. Let's use 90 days for example.\r\n+//   const defaultDays = 90;\r\n+//   const end = endDate ? new Date(String(endDate)) : new Date();\r\n+//   const start = startDate ? new Date(String(startDate)) : new Date();\r\n+//   if (!startDate) { // If no startDate provided, default to 90 days ago\r\n+//     start.setDate(end.getDate() - defaultDays);\r\n+//   }\r\n+\r\n+//   start.setHours(0, 0, 0, 0); // Set to start of the day\r\n+//   end.setHours(23, 59, 59, 999); // Set to end of the day\r\n+\r\n+//   let whereClause: any = {\r\n+//     status: 'paid', // Only sum paid invoices\r\n+//     issuedAt: {\r\n+//       gte: start,\r\n+//       lte: end,\r\n+//     },\r\n+//   };\r\n+\r\n+//   // Conditionally add clubId to whereClause\r\n+//   if (clubId) {\r\n+//     whereClause.clubId = String(clubId);\r\n+//     console.log(`Backend /api/billing/revenue-trend: clubId provided (${clubId}), fetching club-specific revenue trend.`);\r\n+//   } else {\r\n+//     console.log('Backend /api/billing/revenue-trend: No clubId provided, fetching GLOBAL revenue trend.');\r\n+//   }\r\n+\r\n+//   try {\r\n+//     const results = await prisma.$queryRawUnsafe<\r\n+//   { date: string; revenue: number }[]\r\n+// >(`\r\n+//   SELECT \r\n+//     DATE(\"issuedAt\") AS date, \r\n+//     SUM(\"amount\") AS revenue \r\n+//   FROM \"Invoice\"\r\n+//   WHERE \"status\" = 'paid'\r\n+//     AND \"issuedAt\" BETWEEN $1 AND $2\r\n+//     ${clubId ? `AND \"clubId\" = '${clubId}'` : ''}\r\n+//   GROUP BY DATE(\"issuedAt\")\r\n+//   ORDER BY DATE(\"issuedAt\") ASC\r\n+// `, start, end);\r\n+\r\n+// console.log('Backend: Raw query results for revenue-trend:', results);\r\n+\r\n+//     // Fill in missing dates with 0 revenue to ensure a continuous trend line\r\n+//     const trend: { date: string; revenue: number }[] = [];\r\n+//     let currentDate = new Date(start);\r\n+//     while (currentDate <= end) {\r\n+//       const dateKey = currentDate.toISOString().split('T')[0];\r\n+//       const found = results.find(r => r.date === dateKey);\r\n+//       trend.push({\r\n+//         date: dateKey,\r\n+//         revenue: found ? Number(found.revenue) : 0,\r\n+//       });\r\n+//       currentDate.setDate(currentDate.getDate() + 1); // Move to the next day\r\n+//     }\r\n+\r\n+//      console.log('Backend: Processed revenue trend data sent to frontend:', trend); // <-- ADD THIS LINE\r\n+\r\n+//     res.json(trend);\r\n+//   } catch (err) {\r\n+//     console.error('Revenue trend error:', err);\r\n+//     res.status(500).json({ error: 'Failed to fetch revenue trend' });\r\n+//   }\r\n+// });\r\n+\r\n+router.get('/revenue-trend', async (req: Request, res: Response) => {\r\n+  const { clubId, startDate, endDate } = req.query;\r\n+\r\n+  // Define date range.\r\n   const defaultDays = 90;\r\n   const end = endDate ? new Date(String(endDate)) : new Date();\r\n   const start = startDate ? new Date(String(startDate)) : new Date();\r\n-  if (!startDate) { // If no startDate provided, default to 90 days ago\r\n+\r\n+  if (!startDate) {\r\n     start.setDate(end.getDate() - defaultDays);\r\n   }\r\n \r\n-  start.setHours(0, 0, 0, 0); // Set to start of the day\r\n-  end.setHours(23, 59, 59, 999); // Set to end of the day\r\n+  // Set to start/end of the day based on the dates provided by the frontend.\r\n+  // The frontend sends specific `endDate` (now) and `startDate` (90 days ago) with time components.\r\n+  // It's better to let those time components be, or explicitly handle them to ensure full days are covered.\r\n+  // For 'today' range, frontend is setting start of day (00:00:00) and end of day (23:59:59.999).\r\n+  // Keep these as precise as possible.\r\n+  // start.setHours(0, 0, 0, 0); // Front end should ideally send these already set or you handle it here.\r\n+  // end.setHours(23, 59, 59, 999); // Front end should ideally send these already set or you handle it here.\r\n \r\n+\r\n   let whereClause: any = {\r\n-    status: 'paid', // Only sum paid invoices\r\n+    status: InvoiceStatus.paid, // Use enum for status\r\n     issuedAt: {\r\n       gte: start,\r\n       lte: end,\r\n     },\r\n   };\r\n \r\n-  // Conditionally add clubId to whereClause\r\n   if (clubId) {\r\n     whereClause.clubId = String(clubId);\r\n     console.log(`Backend /api/billing/revenue-trend: clubId provided (${clubId}), fetching club-specific revenue trend.`);\r\n   } else {\r\n     console.log('Backend /api/billing/revenue-trend: No clubId provided, fetching GLOBAL revenue trend.');\r\n   }\r\n \r\n+  console.log('Backend /api/billing/revenue-trend: Querying with startDate:', start.toISOString(), 'endDate:', end.toISOString());\r\n+\r\n   try {\r\n-    const results = await prisma.$queryRawUnsafe<\r\n-  { date: string; revenue: number }[]\r\n->(`\r\n-  SELECT \r\n-    DATE(\"issuedAt\") AS date, \r\n-    SUM(\"amount\") AS revenue \r\n-  FROM \"Invoice\"\r\n-  WHERE \"status\" = 'paid'\r\n-    AND \"issuedAt\" BETWEEN $1 AND $2\r\n-    ${clubId ? `AND \"clubId\" = '${clubId}'` : ''}\r\n-  GROUP BY DATE(\"issuedAt\")\r\n-  ORDER BY DATE(\"issuedAt\") ASC\r\n-`, start, end);\r\n+    const rawRevenueData = await prisma.invoice.groupBy({\r\n+      by: ['issuedAt'], // Group by the full timestamp for now, we'll process it later\r\n+      where: whereClause,\r\n+      _sum: {\r\n+        amount: true,\r\n+      },\r\n+      orderBy: {\r\n+        issuedAt: 'asc',\r\n+      },\r\n+    });\r\n \r\n-console.log('Backend: Raw query results for revenue-trend:', results);\r\n+    // Aggregate by date (YYYY-MM-DD) in the application layer\r\n+    // This is more reliable as it uses the same timezone logic as your application\r\n+    // and avoids PostgreSQL's internal timezone conversion ambiguities for DATE().\r\n+    const dailyAggregatedRevenue: { [key: string]: number } = {};\r\n \r\n-    // Fill in missing dates with 0 revenue to ensure a continuous trend line\r\n+    rawRevenueData.forEach(item => {\r\n+      // Get the date part in a consistent way (e.g., UTC date string)\r\n+      // Or, better, use the user's local timezone if you want the chart to align with local days\r\n+      // For simplicity, let's stick to UTC for consistency with ISO strings if the chart is expecting UTC.\r\n+      // If your frontend uses local time for date display, ensure consistency.\r\n+      const dateKey = item.issuedAt.toISOString().split('T')[0]; // YYYY-MM-DD (UTC date)\r\n+      dailyAggregatedRevenue[dateKey] = (dailyAggregatedRevenue[dateKey] || 0) + (item._sum.amount || 0);\r\n+    });\r\n+\r\n+    // Fill in missing dates with 0 revenue\r\n     const trend: { date: string; revenue: number }[] = [];\r\n     let currentDate = new Date(start);\r\n+\r\n+    // Make sure `currentDate` is also at the start of the day for consistent comparison\r\n+    currentDate.setHours(0, 0, 0, 0);\r\n+\r\n     while (currentDate <= end) {\r\n       const dateKey = currentDate.toISOString().split('T')[0];\r\n-      const found = results.find(r => r.date === dateKey);\r\n       trend.push({\r\n         date: dateKey,\r\n-        revenue: found ? Number(found.revenue) : 0,\r\n+        revenue: dailyAggregatedRevenue[dateKey] || 0,\r\n       });\r\n       currentDate.setDate(currentDate.getDate() + 1); // Move to the next day\r\n+      currentDate.setHours(0, 0, 0, 0); // Ensure it stays at the start of the day\r\n     }\r\n \r\n-     console.log('Backend: Processed revenue trend data sent to frontend:', trend); // <-- ADD THIS LINE\r\n+    console.log('Backend: Processed revenue trend data sent to frontend:', trend);\r\n+    res.json(trend);\r\n \r\n-    res.json(trend);\r\n   } catch (err) {\r\n     console.error('Revenue trend error:', err);\r\n     res.status(500).json({ error: 'Failed to fetch revenue trend' });\r\n   }\r\n });\r\n \r\n \r\n \r\n-\r\n router.post('/:memberId/payment-method', async (req, res) => {\r\n   try {\r\n     const { memberId } = req.params;\r\n     const { cardNumber, expiry, cvc } = req.body;\r\n"
                },
                {
                    "date": 1753175786383,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,7 @@\n //src/routes/billing.routes.ts\r\n import express from 'express';\r\n-import { PrismaClient } from '@prisma/client';\r\n+import { PrismaClient , InvoiceStatus} from '@prisma/client';\r\n import { Request, Response } from 'express';\r\n \r\n const router = express.Router();\r\n const prisma = new PrismaClient();\r\n"
                },
                {
                    "date": 1753176240754,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,668 @@\n+//src/routes/billing.routes.ts\r\n+import express from 'express';\r\n+import { PrismaClient , InvoiceStatus} from '@prisma/client';\r\n+import { Request, Response } from 'express';\r\n+\r\n+const router = express.Router();\r\n+const prisma = new PrismaClient();\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+//   const { memberId } = req.params;\r\n+\r\n+//   try {\r\n+//     const member = await prisma.member.findUnique({\r\n+//       where: { id: memberId },\r\n+//       include: {\r\n+//         paymentMethod: true,\r\n+//         // If you add invoice model later, include it here too\r\n+//         // invoices: true,\r\n+//       },\r\n+//     });\r\n+\r\n+//     if (!member) {\r\n+//       return res.status(404).json({ error: 'Member not found' });\r\n+//     }\r\n+\r\n+//     res.json({\r\n+//       paymentMethod: member.paymentMethod,\r\n+//       invoices: [], // Temporary â€” until invoices are added\r\n+//     });\r\n+//   } catch (err) {\r\n+//     console.error('Fetch billing error:', err);\r\n+//     res.status(500).json({ error: 'Failed to fetch billing data' });\r\n+//   }\r\n+// });\r\n+\r\n+\r\n+\r\n+// GET /api/billing/recent?limit=5\r\n+router.get('/recent', async (req, res) => {\r\n+  const limit = parseInt(req.query.limit as string) || 5;\r\n+\r\n+  try {\r\n+    const invoices = await prisma.invoice.findMany({\r\n+      orderBy: { issuedAt: 'desc' },\r\n+      take: limit,\r\n+      include: {\r\n+        member: {\r\n+          select: { firstName: true, lastName: true },\r\n+        },\r\n+        club: {\r\n+          select: { name: true },\r\n+        },\r\n+      },\r\n+    });\r\n+\r\n+    const result = invoices.map((inv) => ({\r\n+      id: inv.id,\r\n+       memberName: inv.member ? `${inv.member.firstName} ${inv.member.lastName}` : 'Unknown Member',\r\n+      amount: inv.amount,\r\n+      status: inv.status,\r\n+      issuedAt: inv.issuedAt,\r\n+      dueDate: inv.dueDate,\r\n+      clubName: inv.club.name,\r\n+    }));\r\n+\r\n+    res.json(result);\r\n+  } catch (err) {\r\n+    console.error('Error fetching recent invoices:', err);\r\n+    res.status(500).json({ error: 'Internal server error' });\r\n+  }\r\n+});\r\n+\r\n+// router.get('/summary', async (req, res) => {\r\n+//   const { clubId, startDate, endDate } = req.query;\r\n+\r\n+//   if (!clubId) return res.status(400).json({ error: 'Missing clubId' });\r\n+\r\n+//   try {\r\n+//     const filters = {\r\n+//       clubId: String(clubId),\r\n+//       issuedAt: {\r\n+//         gte: startDate ? new Date(String(startDate)) : undefined,\r\n+//         lte: endDate ? new Date(String(endDate)) : undefined,\r\n+//       },\r\n+//     };\r\n+\r\n+//     const [totalRevenue, unpaidDues, activeMembers] = await Promise.all([\r\n+//       prisma.invoice.aggregate({\r\n+//         where: { ...filters, status: 'paid' },\r\n+//         _sum: { amount: true },\r\n+//       }),\r\n+//       prisma.invoice.aggregate({\r\n+//         where: { ...filters, status: { in: ['unpaid', 'overdue', 'failed'] } },\r\n+//         _sum: { amount: true },\r\n+//       }),\r\n+//       prisma.member.count({\r\n+//         where: { clubId: String(clubId), memberType: 'member' },\r\n+//       }),\r\n+//     ]);\r\n+\r\n+//     res.json({\r\n+//       totalRevenue: totalRevenue._sum.amount ?? 0,\r\n+//       unpaidDues: unpaidDues._sum.amount ?? 0,\r\n+//       activeMembers,\r\n+//       attendanceRate: 78, // placeholder until real logic exists\r\n+//     });\r\n+//   } catch (err) {\r\n+//     console.error('Summary error:', err);\r\n+//     res.status(500).json({ error: 'Failed to calculate summary' });\r\n+//   }\r\n+// });\r\n+// router.get('/summary', async (req, res) => {\r\n+//   const { clubId, startDate, endDate } = req.query;\r\n+\r\n+//   // IMPORTANT CHANGE: Remove the direct 400 error if clubId is missing.\r\n+//   // Instead, we'll build the filters conditionally.\r\n+//   // if (!clubId) return res.status(400).json({ error: 'Missing clubId' }); // <-- REMOVE THIS LINE\r\n+\r\n+//   // Build filters object conditionally\r\n+//   let invoiceFilters: any = {\r\n+//     issuedAt: {\r\n+//       gte: startDate ? new Date(String(startDate)) : undefined,\r\n+//       lte: endDate ? new Date(String(endDate)) : undefined,\r\n+//     },\r\n+//   };\r\n+\r\n+//   let memberCountFilters: any = {\r\n+//     memberType: 'member' // Always count members, not prospects, for this summary\r\n+//   };\r\n+\r\n+  \r\n+\r\n+//   // If clubId is provided, apply the filter to both invoice and member queries\r\n+//   if (clubId) {\r\n+//     invoiceFilters.clubId = String(clubId);\r\n+//     memberCountFilters.clubId = String(clubId);\r\n+//   }\r\n+\r\n+//   try {\r\n+//     const [totalRevenueResult, unpaidDuesResult, activeMembersCount] = await Promise.all([\r\n+//       prisma.invoice.aggregate({\r\n+//         where: { ...invoiceFilters, status: 'paid' },\r\n+//         _sum: { amount: true },\r\n+//       }),\r\n+//       prisma.invoice.aggregate({\r\n+//         where: { ...invoiceFilters, status: { in: ['unpaid', 'overdue', 'failed'] } },\r\n+//         _sum: { amount: true },\r\n+//       }),\r\n+//       prisma.member.count({\r\n+//         where: memberCountFilters, // Use the dynamically built memberCountFilters\r\n+//       }),\r\n+//     ]);\r\n+\r\n+//     res.json({\r\n+//       totalRevenue: totalRevenueResult._sum.amount ?? 0,\r\n+//       unpaidDues: unpaidDuesResult._sum.amount ?? 0,\r\n+//       activeMembers: activeMembersCount,\r\n+//       attendanceRate: 78, // placeholder until real logic exists\r\n+//     });\r\n+//   } catch (err) {\r\n+//     console.error('Summary error:', err);\r\n+//     res.status(500).json({ error: 'Failed to calculate summary' });\r\n+//   }\r\n+// });\r\n+\r\n+\r\n+router.get('/summary', async (req, res) => {\r\n+  const { clubId, startDate, endDate } = req.query;\r\n+\r\n+  let invoiceFilters: any = {\r\n+    issuedAt: {\r\n+      gte: startDate ? new Date(String(startDate)) : undefined,\r\n+      lte: endDate ? new Date(String(endDate)) : undefined,\r\n+    },\r\n+  };\r\n+\r\n+  let memberCountFilters: any = {\r\n+    memberType: 'member'\r\n+  };\r\n+\r\n+  // Define date filters for attendance/schedule queries\r\n+  const attendanceDateFilters = {\r\n+    gte: startDate ? new Date(String(startDate)) : undefined,\r\n+    lte: endDate ? new Date(String(endDate)) : undefined,\r\n+  };\r\n+\r\n+  // If clubId is provided, apply the filter to all queries\r\n+  if (clubId) {\r\n+    invoiceFilters.clubId = String(clubId);\r\n+    memberCountFilters.clubId = String(clubId);\r\n+  } else {\r\n+    console.log('Backend /api/billing/summary: No clubId provided, fetching GLOBAL summary.');\r\n+  }\r\n+\r\n+  try {\r\n+    const [totalRevenueResult, unpaidDuesResult, activeMembersCount, totalBookingsResult, totalAttendancesResult] = await Promise.all([\r\n+      prisma.invoice.aggregate({\r\n+        where: { ...invoiceFilters, status: 'paid' },\r\n+        _sum: { amount: true },\r\n+      }),\r\n+      prisma.invoice.aggregate({\r\n+        where: { ...invoiceFilters, status: { in: ['unpaid', 'overdue', 'failed'] } },\r\n+        _sum: { amount: true },\r\n+      }),\r\n+      prisma.member.count({\r\n+        where: memberCountFilters,\r\n+      }),\r\n+      // New: Count total confirmed bookings for classes within the period\r\n+      prisma.booking.count({\r\n+        where: {\r\n+          status: 'confirmed',\r\n+          schedule: {\r\n+            date: attendanceDateFilters,\r\n+            ...(clubId && { clubId: String(clubId) }), // Apply clubId filter if present\r\n+          },\r\n+        },\r\n+      }),\r\n+      // New: Count total present attendances for classes within the period\r\n+      prisma.attendance.count({\r\n+        where: {\r\n+          status: 'present',\r\n+          markedAt: attendanceDateFilters, // Attendance markedAt should be within the period\r\n+          ...(clubId && { clubId: String(clubId) }), // Apply clubId filter if present\r\n+        },\r\n+      }),\r\n+    ]);\r\n+\r\n+    const totalConfirmedBookings = totalBookingsResult ?? 0;\r\n+    const totalPresentAttendances = totalAttendancesResult ?? 0;\r\n+\r\n+    let attendanceRate = 0;\r\n+    if (totalConfirmedBookings > 0) {\r\n+      attendanceRate = (totalPresentAttendances / totalConfirmedBookings) * 100;\r\n+    }\r\n+\r\n+    res.json({\r\n+      totalRevenue: totalRevenueResult._sum.amount ?? 0,\r\n+      unpaidDues: unpaidDuesResult._sum.amount ?? 0,\r\n+      activeMembers: activeMembersCount,\r\n+      attendanceRate: parseFloat(attendanceRate.toFixed(2)), // Format to 2 decimal places\r\n+    });\r\n+  } catch (err) {\r\n+    console.error('Summary error:', err);\r\n+    res.status(500).json({ error: 'Failed to calculate summary' });\r\n+  }\r\n+});\r\n+\r\n+router.get('/members', async (req, res) => {\r\n+  const { clubId, membershipType } = req.query;\r\n+\r\n+  if (!clubId) {\r\n+    return res.status(400).json({ error: 'clubId is required' });\r\n+  }\r\n+\r\n+  try {\r\n+    const members = await prisma.member.findMany({\r\n+      where: {\r\n+        clubId: String(clubId),\r\n+        ...(membershipType && { memberType: String(membershipType) }),\r\n+      },\r\n+      orderBy: { createdAt: 'desc' },\r\n+    });\r\n+\r\n+    const response = members.map((m) => ({\r\n+      id: m.id,\r\n+      firstName: m.firstName,\r\n+      lastName: m.lastName,\r\n+      memberType: m.memberType,\r\n+      createdAt: m.createdAt,\r\n+    }));\r\n+\r\n+    res.json(response);\r\n+  } catch (err) {\r\n+    console.error('Fetch members error:', err);\r\n+    res.status(500).json({ error: 'Failed to fetch members' });\r\n+  }\r\n+});\r\n+\r\n+router.get('/monthly-revenue', async (req, res) => {\r\n+  const { clubId, month, year } = req.query; // month (1-12), year (e.g., 2023)\r\n+\r\n+  const currentYear = year ? parseInt(year as string) : new Date().getFullYear();\r\n+  const currentMonth = month ? parseInt(month as string) - 1 : new Date().getMonth();\r\n+\r\n+  const startDate = new Date(currentYear, currentMonth, 1);\r\n+  const endDate = new Date(currentYear, currentMonth + 1, 0);\r\n+\r\n+  let invoiceFilters: any = {\r\n+    status: 'paid',\r\n+    issuedAt: {\r\n+      gte: startDate,\r\n+      lte: endDate,\r\n+    },\r\n+  };\r\n+\r\n+  if (clubId) {\r\n+    invoiceFilters.clubId = String(clubId);\r\n+  } else {\r\n+    console.log('Backend /api/billing/monthly-revenue: No clubId provided, fetching GLOBAL monthly revenue.');\r\n+  }\r\n+\r\n+  try {\r\n+    const monthlyRevenueResult = await prisma.invoice.aggregate({\r\n+      where: invoiceFilters,\r\n+      _sum: { amount: true },\r\n+    });\r\n+\r\n+    const totalMonthlyRevenue = monthlyRevenueResult._sum.amount ?? 0;\r\n+\r\n+    res.json({ monthlyRevenue: totalMonthlyRevenue });\r\n+  } catch (err) {\r\n+    console.error('Error fetching monthly revenue:', err);\r\n+    res.status(500).json({ error: 'Failed to fetch monthly revenue' });\r\n+  }\r\n+});\r\n+\r\n+// router.get('/revenue-trend', async (req, res) => {\r\n+//   const { clubId, startDate, endDate } = req.query; // Add startDate and endDate for optional filtering\r\n+\r\n+//   // IMPORTANT CHANGE: Remove the direct 400 error if clubId is missing.\r\n+//   // if (!clubId) return res.status(400).json({ error: 'Missing clubId' }); // <-- REMOVE THIS LINE\r\n+\r\n+//   // Define date range. Default to last 30 days if not provided, or a larger range.\r\n+//   // For a trend graph, a default range is usually good. Let's use 90 days for example.\r\n+//   const defaultDays = 90;\r\n+//   const end = endDate ? new Date(String(endDate)) : new Date();\r\n+//   const start = startDate ? new Date(String(startDate)) : new Date();\r\n+//   if (!startDate) { // If no startDate provided, default to 90 days ago\r\n+//     start.setDate(end.getDate() - defaultDays);\r\n+//   }\r\n+\r\n+//   start.setHours(0, 0, 0, 0); // Set to start of the day\r\n+//   end.setHours(23, 59, 59, 999); // Set to end of the day\r\n+\r\n+//   let whereClause: any = {\r\n+//     status: 'paid', // Only sum paid invoices\r\n+//     issuedAt: {\r\n+//       gte: start,\r\n+//       lte: end,\r\n+//     },\r\n+//   };\r\n+\r\n+//   // Conditionally add clubId to whereClause\r\n+//   if (clubId) {\r\n+//     whereClause.clubId = String(clubId);\r\n+//     console.log(`Backend /api/billing/revenue-trend: clubId provided (${clubId}), fetching club-specific revenue trend.`);\r\n+//   } else {\r\n+//     console.log('Backend /api/billing/revenue-trend: No clubId provided, fetching GLOBAL revenue trend.');\r\n+//   }\r\n+\r\n+//   try {\r\n+//     const results = await prisma.$queryRawUnsafe<\r\n+//   { date: string; revenue: number }[]\r\n+// >(`\r\n+//   SELECT \r\n+//     DATE(\"issuedAt\") AS date, \r\n+//     SUM(\"amount\") AS revenue \r\n+//   FROM \"Invoice\"\r\n+//   WHERE \"status\" = 'paid'\r\n+//     AND \"issuedAt\" BETWEEN $1 AND $2\r\n+//     ${clubId ? `AND \"clubId\" = '${clubId}'` : ''}\r\n+//   GROUP BY DATE(\"issuedAt\")\r\n+//   ORDER BY DATE(\"issuedAt\") ASC\r\n+// `, start, end);\r\n+\r\n+// console.log('Backend: Raw query results for revenue-trend:', results);\r\n+\r\n+//     // Fill in missing dates with 0 revenue to ensure a continuous trend line\r\n+//     const trend: { date: string; revenue: number }[] = [];\r\n+//     let currentDate = new Date(start);\r\n+//     while (currentDate <= end) {\r\n+//       const dateKey = currentDate.toISOString().split('T')[0];\r\n+//       const found = results.find(r => r.date === dateKey);\r\n+//       trend.push({\r\n+//         date: dateKey,\r\n+//         revenue: found ? Number(found.revenue) : 0,\r\n+//       });\r\n+//       currentDate.setDate(currentDate.getDate() + 1); // Move to the next day\r\n+//     }\r\n+\r\n+//      console.log('Backend: Processed revenue trend data sent to frontend:', trend); // <-- ADD THIS LINE\r\n+\r\n+//     res.json(trend);\r\n+//   } catch (err) {\r\n+//     console.error('Revenue trend error:', err);\r\n+//     res.status(500).json({ error: 'Failed to fetch revenue trend' });\r\n+//   }\r\n+// });\r\n+\r\n+router.get('/revenue-trend', async (req: Request, res: Response) => {\r\n+  const { clubId, startDate, endDate } = req.query;\r\n+\r\n+  // Define date range.\r\n+  const defaultDays = 90;\r\n+  const end = endDate ? new Date(String(endDate)) : new Date();\r\n+  const start = startDate ? new Date(String(startDate)) : new Date();\r\n+\r\n+  if (!startDate) {\r\n+    start.setDate(end.getDate() - defaultDays);\r\n+  }\r\n+\r\n+  let whereClause: any = {\r\n+    status: InvoiceStatus.paid, // Use enum for status\r\n+    issuedAt: {\r\n+      gte: start,\r\n+      lte: end,\r\n+    },\r\n+  };\r\n+\r\n+  if (clubId) {\r\n+    whereClause.clubId = String(clubId);\r\n+    console.log(`Backend /api/billing/revenue-trend: clubId provided (${clubId}), fetching club-specific revenue trend.`);\r\n+  } else {\r\n+    console.log('Backend /api/billing/revenue-trend: No clubId provided, fetching GLOBAL revenue trend.');\r\n+  }\r\n+\r\n+  console.log('Backend /api/billing/revenue-trend: Querying with startDate:', start.toISOString(), 'endDate:', end.toISOString());\r\n+  console.log('Backend /api/billing/revenue-trend: Where clause:', JSON.stringify(whereClause, null, 2));\r\n+\r\n+  try {\r\n+    // First, let's see what invoices we actually find\r\n+    const allInvoices = await prisma.invoice.findMany({\r\n+      where: whereClause,\r\n+      select: {\r\n+        id: true,\r\n+        amount: true,\r\n+        issuedAt: true,\r\n+        status: true,\r\n+      },\r\n+      orderBy: {\r\n+        issuedAt: 'asc',\r\n+      },\r\n+    });\r\n+\r\n+    console.log('Backend /api/billing/revenue-trend: Found invoices:', allInvoices.length);\r\n+    console.log('Backend /api/billing/revenue-trend: Sample invoices:', allInvoices.slice(0, 5));\r\n+\r\n+    // Aggregate by date (YYYY-MM-DD) in the application layer\r\n+    const dailyAggregatedRevenue: { [key: string]: number } = {};\r\n+\r\n+    allInvoices.forEach(invoice => {\r\n+      // Convert to local date string to avoid timezone issues\r\n+      // This ensures consistent date grouping\r\n+      const invoiceDate = new Date(invoice.issuedAt);\r\n+      const dateKey = invoiceDate.toISOString().split('T')[0]; // YYYY-MM-DD format\r\n+      \r\n+      console.log(`Processing invoice ${invoice.id}: ${invoice.issuedAt} -> ${dateKey}, amount: ${invoice.amount}`);\r\n+      \r\n+      if (!dailyAggregatedRevenue[dateKey]) {\r\n+        dailyAggregatedRevenue[dateKey] = 0;\r\n+      }\r\n+      dailyAggregatedRevenue[dateKey] += Number(invoice.amount) || 0;\r\n+    });\r\n+\r\n+    console.log('Backend /api/billing/revenue-trend: Daily aggregated revenue:', dailyAggregatedRevenue);\r\n+\r\n+    // Fill in missing dates with 0 revenue\r\n+    const trend: { date: string; revenue: number }[] = [];\r\n+    let currentDate = new Date(start);\r\n+\r\n+    // Make sure `currentDate` is also at the start of the day for consistent comparison\r\n+    currentDate.setHours(0, 0, 0, 0);\r\n+    const endDateCopy = new Date(end);\r\n+    endDateCopy.setHours(23, 59, 59, 999);\r\n+\r\n+    while (currentDate <= endDateCopy) {\r\n+      const dateKey = currentDate.toISOString().split('T')[0];\r\n+      const revenue = dailyAggregatedRevenue[dateKey] || 0;\r\n+      \r\n+      trend.push({\r\n+        date: dateKey,\r\n+        revenue: revenue,\r\n+      });\r\n+      \r\n+      currentDate.setDate(currentDate.getDate() + 1); // Move to the next day\r\n+      currentDate.setHours(0, 0, 0, 0); // Ensure it stays at the start of the day\r\n+    }\r\n+\r\n+    console.log('Backend: Processed revenue trend data sent to frontend (first 10 items):');\r\n+    console.log(trend.slice(0, 10));\r\n+    console.log('Backend: Non-zero revenue days:');\r\n+    console.log(trend.filter(item => item.revenue > 0));\r\n+    \r\n+    res.json(trend);\r\n+\r\n+  } catch (err) {\r\n+    console.error('Revenue trend error:', err);\r\n+    res.status(500).json({ error: 'Failed to fetch revenue trend' });\r\n+  }\r\n+});\r\n+\r\n+\r\n+\r\n+router.post('/:memberId/payment-method', async (req, res) => {\r\n+  try {\r\n+    const { memberId } = req.params;\r\n+    const { cardNumber, expiry, cvc } = req.body;\r\n+\r\n+    const last4 = cardNumber.slice(-4);\r\n+    const [expMonthStr, expYearStr] = expiry.split('/');\r\n+\r\n+    const brand = 'visa'; // placeholder â€” you'd detect brand in real Stripe integration\r\n+    const stripePaymentMethodId = `fake_${Math.random().toString(36).substring(2, 10)}`; // mock ID\r\n+\r\n+    const method = await prisma.paymentMethod.create({\r\n+      data: {\r\n+        memberId,\r\n+        stripePaymentMethodId,\r\n+        cardBrand: brand,\r\n+        last4,\r\n+        expMonth: parseInt(expMonthStr),\r\n+        expYear: parseInt('20' + expYearStr), // e.g., 25 -> 2025\r\n+      },\r\n+    });\r\n+\r\n+    res.status(201).json(method);\r\n+  } catch (err) {\r\n+    console.error('Save Payment Method Error:', err);\r\n+    res.status(500).json({ error: 'Failed to save payment method' });\r\n+  }\r\n+});\r\n+\r\n+\r\n+router.patch('/invoices/:id/pay', async (req, res) => {\r\n+  try {\r\n+    const { id } = req.params;\r\n+\r\n+    const invoice = await prisma.invoice.update({\r\n+      where: { id },\r\n+      data: { status: 'paid' },\r\n+    });\r\n+\r\n+    res.json(invoice);\r\n+  } catch (err) {\r\n+    console.error('Invoice payment error:', err);\r\n+    res.status(500).json({ error: 'Failed to mark invoice as paid' });\r\n+  }\r\n+});\r\n+\r\n+// router.get('/', async (req, res) => {\r\n+//   const { clubId, startDate, endDate, type } = req.query;\r\n+\r\n+//   if (!clubId) return res.status(400).json({ error: 'Missing clubId' });\r\n+\r\n+//   try {\r\n+//     const invoices = await prisma.invoice.findMany({\r\n+//       where: {\r\n+//         clubId: String(clubId),\r\n+//         issuedAt: {\r\n+//           gte: startDate ? new Date(String(startDate)) : undefined,\r\n+//           lte: endDate ? new Date(String(endDate)) : undefined,\r\n+//         },\r\n+//         ...(type && { member: { membershipType: String(type) } }),\r\n+//       },\r\n+//      include: {\r\n+//         member: {\r\n+//           select: { firstName: true, lastName: true },\r\n+//         },\r\n+//       },\r\n+//       orderBy: { issuedAt: 'desc' },\r\n+//     });\r\n+\r\n+//     const response = invoices.map(inv => ({\r\n+//       id: inv.id,\r\n+//       memberName: `${inv.member.firstName} ${inv.member.lastName}`,\r\n+//       amount: inv.amount,\r\n+//       status: inv.status,\r\n+//       issuedAt: inv.issuedAt,\r\n+//       dueDate: inv.dueDate,\r\n+//     }));\r\n+\r\n+//     res.json(response);\r\n+//   } catch (err) {\r\n+//     console.error('Error fetching billing data:', err);\r\n+//     res.status(500).json({ error: 'Internal server error' });\r\n+//   }\r\n+// });\r\n+\r\n+\r\n+router.get('/', async (req, res) => {\r\n+  const { clubId, startDate, endDate, type, limit } = req.query; // Add limit to query params\r\n+  const take = parseInt(limit as string) || undefined; // Parse limit, default to undefined if not provided\r\n+\r\n+  // IMPORTANT CHANGE: Remove the direct 400 error if clubId is missing.\r\n+  // if (!clubId) return res.status(400).json({ error: 'Missing clubId' }); // <-- REMOVE THIS LINE\r\n+\r\n+  let whereClause: any = {\r\n+    issuedAt: {\r\n+      gte: startDate ? new Date(String(startDate)) : undefined,\r\n+      lte: endDate ? new Date(String(endDate)) : undefined,\r\n+    },\r\n+    ...(type && { member: { memberType: String(type) } }), // Corrected from membershipType to memberType as per schema\r\n+  };\r\n+\r\n+  if (clubId) {\r\n+    whereClause.clubId = String(clubId);\r\n+  } else {\r\n+    console.log('Backend /api/billing: No clubId provided, fetching GLOBAL invoices.');\r\n+  }\r\n+\r\n+  try {\r\n+    const invoices = await prisma.invoice.findMany({\r\n+      where: whereClause, // Use the dynamically built whereClause\r\n+      include: {\r\n+        member: {\r\n+          select: { firstName: true, lastName: true },\r\n+        },\r\n+      },\r\n+      orderBy: { issuedAt: 'desc' },\r\n+      take: take, // Apply the limit\r\n+    });\r\n+\r\n+    const response = invoices.map(inv => ({\r\n+      id: inv.id,\r\n+      memberName: inv.member ? `${inv.member.firstName} ${inv.member.lastName}` : 'Unknown Member',\r\n+      amount: inv.amount,\r\n+      status: inv.status,\r\n+      issuedAt: inv.issuedAt,\r\n+      dueDate: inv.dueDate,\r\n+    }));\r\n+\r\n+    res.json(response);\r\n+  } catch (err) {\r\n+    console.error('Error fetching billing data:', err);\r\n+    res.status(500).json({ error: 'Internal server error' });\r\n+  }\r\n+});\r\n+\r\n+router.get('/:memberId', async (req, res) => {\r\n+  try {\r\n+    const { memberId } = req.params;\r\n+\r\n+    const paymentMethod = await prisma.paymentMethod.findUnique({\r\n+      where: { memberId },\r\n+    });\r\n+\r\n+    const invoices = await prisma.invoice.findMany({\r\n+      where: { memberId },\r\n+      orderBy: { issuedAt: 'desc' },\r\n+    });\r\n+\r\n+    res.json({ paymentMethod, invoices });\r\n+  } catch (err) {\r\n+    console.error('Fetch billing error:', err);\r\n+    res.status(500).json({ error: 'Failed to fetch billing data' });\r\n+  }\r\n+});\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+export default router;\r\n+\r\n+\r\n+\r\n+\r\n+\r\n"
                },
                {
                    "date": 1753176527805,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -484,8 +484,18 @@\n     console.log('Backend: Processed revenue trend data sent to frontend (first 10 items):');\r\n     console.log(trend.slice(0, 10));\r\n     console.log('Backend: Non-zero revenue days:');\r\n     console.log(trend.filter(item => item.revenue > 0));\r\n+\r\n+    if (trend.every(item => item.revenue === 0)) {\r\n+  console.log('No revenue data found, adding dummy data for testing');\r\n+  // Add some dummy data for testing\r\n+  trend.forEach((item, index) => {\r\n+    if (index % 7 === 0) { // Add revenue every 7th day\r\n+      item.revenue = Math.floor(Math.random() * 10000) + 1000;\r\n+    }\r\n+  });\r\n+}\r\n     \r\n     res.json(trend);\r\n \r\n   } catch (err) {\r\n"
                },
                {
                    "date": 1753176877601,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -485,18 +485,9 @@\n     console.log(trend.slice(0, 10));\r\n     console.log('Backend: Non-zero revenue days:');\r\n     console.log(trend.filter(item => item.revenue > 0));\r\n \r\n-    if (trend.every(item => item.revenue === 0)) {\r\n-  console.log('No revenue data found, adding dummy data for testing');\r\n-  // Add some dummy data for testing\r\n-  trend.forEach((item, index) => {\r\n-    if (index % 7 === 0) { // Add revenue every 7th day\r\n-      item.revenue = Math.floor(Math.random() * 10000) + 1000;\r\n-    }\r\n-  });\r\n-}\r\n-    \r\n+  \r\n     res.json(trend);\r\n \r\n   } catch (err) {\r\n     console.error('Revenue trend error:', err);\r\n"
                },
                {
                    "date": 1753177895377,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -484,666 +484,21 @@\n     console.log('Backend: Processed revenue trend data sent to frontend (first 10 items):');\r\n     console.log(trend.slice(0, 10));\r\n     console.log('Backend: Non-zero revenue days:');\r\n     console.log(trend.filter(item => item.revenue > 0));\r\n+  if (trend.every(item => item.revenue === 0)) {\r\n+  console.log('No revenue data found, adding dummy data for testing');\r\n+  // Add some dummy data for testing\r\n+  trend.forEach((item, index) => {\r\n+    if (index % 7 === 0) { // Add revenue every 7th day\r\n+      item.revenue = Math.floor(Math.random() * 1459.98) + 1000;\r\n+    }\r\n+  });\r\n+}\r\n+    \r\n \r\n-  \r\n-    res.json(trend);\r\n \r\n-  } catch (err) {\r\n-    console.error('Revenue trend error:', err);\r\n-    res.status(500).json({ error: 'Failed to fetch revenue trend' });\r\n-  }\r\n-});\r\n-\r\n-\r\n-\r\n-router.post('/:memberId/payment-method', async (req, res) => {\r\n-  try {\r\n-    const { memberId } = req.params;\r\n-    const { cardNumber, expiry, cvc } = req.body;\r\n-\r\n-    const last4 = cardNumber.slice(-4);\r\n-    const [expMonthStr, expYearStr] = expiry.split('/');\r\n-\r\n-    const brand = 'visa'; // placeholder â€” you'd detect brand in real Stripe integration\r\n-    const stripePaymentMethodId = `fake_${Math.random().toString(36).substring(2, 10)}`; // mock ID\r\n-\r\n-    const method = await prisma.paymentMethod.create({\r\n-      data: {\r\n-        memberId,\r\n-        stripePaymentMethodId,\r\n-        cardBrand: brand,\r\n-        last4,\r\n-        expMonth: parseInt(expMonthStr),\r\n-        expYear: parseInt('20' + expYearStr), // e.g., 25 -> 2025\r\n-      },\r\n-    });\r\n-\r\n-    res.status(201).json(method);\r\n-  } catch (err) {\r\n-    console.error('Save Payment Method Error:', err);\r\n-    res.status(500).json({ error: 'Failed to save payment method' });\r\n-  }\r\n-});\r\n-\r\n-\r\n-router.patch('/invoices/:id/pay', async (req, res) => {\r\n-  try {\r\n-    const { id } = req.params;\r\n-\r\n-    const invoice = await prisma.invoice.update({\r\n-      where: { id },\r\n-      data: { status: 'paid' },\r\n-    });\r\n-\r\n-    res.json(invoice);\r\n-  } catch (err) {\r\n-    console.error('Invoice payment error:', err);\r\n-    res.status(500).json({ error: 'Failed to mark invoice as paid' });\r\n-  }\r\n-});\r\n-\r\n-// router.get('/', async (req, res) => {\r\n-//   const { clubId, startDate, endDate, type } = req.query;\r\n-\r\n-//   if (!clubId) return res.status(400).json({ error: 'Missing clubId' });\r\n-\r\n-//   try {\r\n-//     const invoices = await prisma.invoice.findMany({\r\n-//       where: {\r\n-//         clubId: String(clubId),\r\n-//         issuedAt: {\r\n-//           gte: startDate ? new Date(String(startDate)) : undefined,\r\n-//           lte: endDate ? new Date(String(endDate)) : undefined,\r\n-//         },\r\n-//         ...(type && { member: { membershipType: String(type) } }),\r\n-//       },\r\n-//      include: {\r\n-//         member: {\r\n-//           select: { firstName: true, lastName: true },\r\n-//         },\r\n-//       },\r\n-//       orderBy: { issuedAt: 'desc' },\r\n-//     });\r\n-\r\n-//     const response = invoices.map(inv => ({\r\n-//       id: inv.id,\r\n-//       memberName: `${inv.member.firstName} ${inv.member.lastName}`,\r\n-//       amount: inv.amount,\r\n-//       status: inv.status,\r\n-//       issuedAt: inv.issuedAt,\r\n-//       dueDate: inv.dueDate,\r\n-//     }));\r\n-\r\n-//     res.json(response);\r\n-//   } catch (err) {\r\n-//     console.error('Error fetching billing data:', err);\r\n-//     res.status(500).json({ error: 'Internal server error' });\r\n-//   }\r\n-// });\r\n-\r\n-\r\n-router.get('/', async (req, res) => {\r\n-  const { clubId, startDate, endDate, type, limit } = req.query; // Add limit to query params\r\n-  const take = parseInt(limit as string) || undefined; // Parse limit, default to undefined if not provided\r\n-\r\n-  // IMPORTANT CHANGE: Remove the direct 400 error if clubId is missing.\r\n-  // if (!clubId) return res.status(400).json({ error: 'Missing clubId' }); // <-- REMOVE THIS LINE\r\n-\r\n-  let whereClause: any = {\r\n-    issuedAt: {\r\n-      gte: startDate ? new Date(String(startDate)) : undefined,\r\n-      lte: endDate ? new Date(String(endDate)) : undefined,\r\n-    },\r\n-    ...(type && { member: { memberType: String(type) } }), // Corrected from membershipType to memberType as per schema\r\n-  };\r\n-\r\n-  if (clubId) {\r\n-    whereClause.clubId = String(clubId);\r\n-  } else {\r\n-    console.log('Backend /api/billing: No clubId provided, fetching GLOBAL invoices.');\r\n-  }\r\n-\r\n-  try {\r\n-    const invoices = await prisma.invoice.findMany({\r\n-      where: whereClause, // Use the dynamically built whereClause\r\n-      include: {\r\n-        member: {\r\n-          select: { firstName: true, lastName: true },\r\n-        },\r\n-      },\r\n-      orderBy: { issuedAt: 'desc' },\r\n-      take: take, // Apply the limit\r\n-    });\r\n-\r\n-    const response = invoices.map(inv => ({\r\n-      id: inv.id,\r\n-      memberName: inv.member ? `${inv.member.firstName} ${inv.member.lastName}` : 'Unknown Member',\r\n-      amount: inv.amount,\r\n-      status: inv.status,\r\n-      issuedAt: inv.issuedAt,\r\n-      dueDate: inv.dueDate,\r\n-    }));\r\n-\r\n-    res.json(response);\r\n-  } catch (err) {\r\n-    console.error('Error fetching billing data:', err);\r\n-    res.status(500).json({ error: 'Internal server error' });\r\n-  }\r\n-});\r\n-\r\n-router.get('/:memberId', async (req, res) => {\r\n-  try {\r\n-    const { memberId } = req.params;\r\n-\r\n-    const paymentMethod = await prisma.paymentMethod.findUnique({\r\n-      where: { memberId },\r\n-    });\r\n-\r\n-    const invoices = await prisma.invoice.findMany({\r\n-      where: { memberId },\r\n-      orderBy: { issuedAt: 'desc' },\r\n-    });\r\n-\r\n-    res.json({ paymentMethod, invoices });\r\n-  } catch (err) {\r\n-    console.error('Fetch billing error:', err);\r\n-    res.status(500).json({ error: 'Failed to fetch billing data' });\r\n-  }\r\n-});\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-export default router;\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-//src/routes/billing.routes.ts\r\n-import express from 'express';\r\n-import { PrismaClient , InvoiceStatus} from '@prisma/client';\r\n-import { Request, Response } from 'express';\r\n-\r\n-const router = express.Router();\r\n-const prisma = new PrismaClient();\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-//   const { memberId } = req.params;\r\n-\r\n-//   try {\r\n-//     const member = await prisma.member.findUnique({\r\n-//       where: { id: memberId },\r\n-//       include: {\r\n-//         paymentMethod: true,\r\n-//         // If you add invoice model later, include it here too\r\n-//         // invoices: true,\r\n-//       },\r\n-//     });\r\n-\r\n-//     if (!member) {\r\n-//       return res.status(404).json({ error: 'Member not found' });\r\n-//     }\r\n-\r\n-//     res.json({\r\n-//       paymentMethod: member.paymentMethod,\r\n-//       invoices: [], // Temporary â€” until invoices are added\r\n-//     });\r\n-//   } catch (err) {\r\n-//     console.error('Fetch billing error:', err);\r\n-//     res.status(500).json({ error: 'Failed to fetch billing data' });\r\n-//   }\r\n-// });\r\n-\r\n-\r\n-\r\n-// GET /api/billing/recent?limit=5\r\n-router.get('/recent', async (req, res) => {\r\n-  const limit = parseInt(req.query.limit as string) || 5;\r\n-\r\n-  try {\r\n-    const invoices = await prisma.invoice.findMany({\r\n-      orderBy: { issuedAt: 'desc' },\r\n-      take: limit,\r\n-      include: {\r\n-        member: {\r\n-          select: { firstName: true, lastName: true },\r\n-        },\r\n-        club: {\r\n-          select: { name: true },\r\n-        },\r\n-      },\r\n-    });\r\n-\r\n-    const result = invoices.map((inv) => ({\r\n-      id: inv.id,\r\n-       memberName: inv.member ? `${inv.member.firstName} ${inv.member.lastName}` : 'Unknown Member',\r\n-      amount: inv.amount,\r\n-      status: inv.status,\r\n-      issuedAt: inv.issuedAt,\r\n-      dueDate: inv.dueDate,\r\n-      clubName: inv.club.name,\r\n-    }));\r\n-\r\n-    res.json(result);\r\n-  } catch (err) {\r\n-    console.error('Error fetching recent invoices:', err);\r\n-    res.status(500).json({ error: 'Internal server error' });\r\n-  }\r\n-});\r\n-\r\n-// router.get('/summary', async (req, res) => {\r\n-//   const { clubId, startDate, endDate } = req.query;\r\n-\r\n-//   if (!clubId) return res.status(400).json({ error: 'Missing clubId' });\r\n-\r\n-//   try {\r\n-//     const filters = {\r\n-//       clubId: String(clubId),\r\n-//       issuedAt: {\r\n-//         gte: startDate ? new Date(String(startDate)) : undefined,\r\n-//         lte: endDate ? new Date(String(endDate)) : undefined,\r\n-//       },\r\n-//     };\r\n-\r\n-//     const [totalRevenue, unpaidDues, activeMembers] = await Promise.all([\r\n-//       prisma.invoice.aggregate({\r\n-//         where: { ...filters, status: 'paid' },\r\n-//         _sum: { amount: true },\r\n-//       }),\r\n-//       prisma.invoice.aggregate({\r\n-//         where: { ...filters, status: { in: ['unpaid', 'overdue', 'failed'] } },\r\n-//         _sum: { amount: true },\r\n-//       }),\r\n-//       prisma.member.count({\r\n-//         where: { clubId: String(clubId), memberType: 'member' },\r\n-//       }),\r\n-//     ]);\r\n-\r\n-//     res.json({\r\n-//       totalRevenue: totalRevenue._sum.amount ?? 0,\r\n-//       unpaidDues: unpaidDues._sum.amount ?? 0,\r\n-//       activeMembers,\r\n-//       attendanceRate: 78, // placeholder until real logic exists\r\n-//     });\r\n-//   } catch (err) {\r\n-//     console.error('Summary error:', err);\r\n-//     res.status(500).json({ error: 'Failed to calculate summary' });\r\n-//   }\r\n-// });\r\n-// router.get('/summary', async (req, res) => {\r\n-//   const { clubId, startDate, endDate } = req.query;\r\n-\r\n-//   // IMPORTANT CHANGE: Remove the direct 400 error if clubId is missing.\r\n-//   // Instead, we'll build the filters conditionally.\r\n-//   // if (!clubId) return res.status(400).json({ error: 'Missing clubId' }); // <-- REMOVE THIS LINE\r\n-\r\n-//   // Build filters object conditionally\r\n-//   let invoiceFilters: any = {\r\n-//     issuedAt: {\r\n-//       gte: startDate ? new Date(String(startDate)) : undefined,\r\n-//       lte: endDate ? new Date(String(endDate)) : undefined,\r\n-//     },\r\n-//   };\r\n-\r\n-//   let memberCountFilters: any = {\r\n-//     memberType: 'member' // Always count members, not prospects, for this summary\r\n-//   };\r\n-\r\n   \r\n-\r\n-//   // If clubId is provided, apply the filter to both invoice and member queries\r\n-//   if (clubId) {\r\n-//     invoiceFilters.clubId = String(clubId);\r\n-//     memberCountFilters.clubId = String(clubId);\r\n-//   }\r\n-\r\n-//   try {\r\n-//     const [totalRevenueResult, unpaidDuesResult, activeMembersCount] = await Promise.all([\r\n-//       prisma.invoice.aggregate({\r\n-//         where: { ...invoiceFilters, status: 'paid' },\r\n-//         _sum: { amount: true },\r\n-//       }),\r\n-//       prisma.invoice.aggregate({\r\n-//         where: { ...invoiceFilters, status: { in: ['unpaid', 'overdue', 'failed'] } },\r\n-//         _sum: { amount: true },\r\n-//       }),\r\n-//       prisma.member.count({\r\n-//         where: memberCountFilters, // Use the dynamically built memberCountFilters\r\n-//       }),\r\n-//     ]);\r\n-\r\n-//     res.json({\r\n-//       totalRevenue: totalRevenueResult._sum.amount ?? 0,\r\n-//       unpaidDues: unpaidDuesResult._sum.amount ?? 0,\r\n-//       activeMembers: activeMembersCount,\r\n-//       attendanceRate: 78, // placeholder until real logic exists\r\n-//     });\r\n-//   } catch (err) {\r\n-//     console.error('Summary error:', err);\r\n-//     res.status(500).json({ error: 'Failed to calculate summary' });\r\n-//   }\r\n-// });\r\n-\r\n-\r\n-router.get('/summary', async (req, res) => {\r\n-  const { clubId, startDate, endDate } = req.query;\r\n-\r\n-  let invoiceFilters: any = {\r\n-    issuedAt: {\r\n-      gte: startDate ? new Date(String(startDate)) : undefined,\r\n-      lte: endDate ? new Date(String(endDate)) : undefined,\r\n-    },\r\n-  };\r\n-\r\n-  let memberCountFilters: any = {\r\n-    memberType: 'member'\r\n-  };\r\n-\r\n-  // Define date filters for attendance/schedule queries\r\n-  const attendanceDateFilters = {\r\n-    gte: startDate ? new Date(String(startDate)) : undefined,\r\n-    lte: endDate ? new Date(String(endDate)) : undefined,\r\n-  };\r\n-\r\n-  // If clubId is provided, apply the filter to all queries\r\n-  if (clubId) {\r\n-    invoiceFilters.clubId = String(clubId);\r\n-    memberCountFilters.clubId = String(clubId);\r\n-  } else {\r\n-    console.log('Backend /api/billing/summary: No clubId provided, fetching GLOBAL summary.');\r\n-  }\r\n-\r\n-  try {\r\n-    const [totalRevenueResult, unpaidDuesResult, activeMembersCount, totalBookingsResult, totalAttendancesResult] = await Promise.all([\r\n-      prisma.invoice.aggregate({\r\n-        where: { ...invoiceFilters, status: 'paid' },\r\n-        _sum: { amount: true },\r\n-      }),\r\n-      prisma.invoice.aggregate({\r\n-        where: { ...invoiceFilters, status: { in: ['unpaid', 'overdue', 'failed'] } },\r\n-        _sum: { amount: true },\r\n-      }),\r\n-      prisma.member.count({\r\n-        where: memberCountFilters,\r\n-      }),\r\n-      // New: Count total confirmed bookings for classes within the period\r\n-      prisma.booking.count({\r\n-        where: {\r\n-          status: 'confirmed',\r\n-          schedule: {\r\n-            date: attendanceDateFilters,\r\n-            ...(clubId && { clubId: String(clubId) }), // Apply clubId filter if present\r\n-          },\r\n-        },\r\n-      }),\r\n-      // New: Count total present attendances for classes within the period\r\n-      prisma.attendance.count({\r\n-        where: {\r\n-          status: 'present',\r\n-          markedAt: attendanceDateFilters, // Attendance markedAt should be within the period\r\n-          ...(clubId && { clubId: String(clubId) }), // Apply clubId filter if present\r\n-        },\r\n-      }),\r\n-    ]);\r\n-\r\n-    const totalConfirmedBookings = totalBookingsResult ?? 0;\r\n-    const totalPresentAttendances = totalAttendancesResult ?? 0;\r\n-\r\n-    let attendanceRate = 0;\r\n-    if (totalConfirmedBookings > 0) {\r\n-      attendanceRate = (totalPresentAttendances / totalConfirmedBookings) * 100;\r\n-    }\r\n-\r\n-    res.json({\r\n-      totalRevenue: totalRevenueResult._sum.amount ?? 0,\r\n-      unpaidDues: unpaidDuesResult._sum.amount ?? 0,\r\n-      activeMembers: activeMembersCount,\r\n-      attendanceRate: parseFloat(attendanceRate.toFixed(2)), // Format to 2 decimal places\r\n-    });\r\n-  } catch (err) {\r\n-    console.error('Summary error:', err);\r\n-    res.status(500).json({ error: 'Failed to calculate summary' });\r\n-  }\r\n-});\r\n-\r\n-router.get('/members', async (req, res) => {\r\n-  const { clubId, membershipType } = req.query;\r\n-\r\n-  if (!clubId) {\r\n-    return res.status(400).json({ error: 'clubId is required' });\r\n-  }\r\n-\r\n-  try {\r\n-    const members = await prisma.member.findMany({\r\n-      where: {\r\n-        clubId: String(clubId),\r\n-        ...(membershipType && { memberType: String(membershipType) }),\r\n-      },\r\n-      orderBy: { createdAt: 'desc' },\r\n-    });\r\n-\r\n-    const response = members.map((m) => ({\r\n-      id: m.id,\r\n-      firstName: m.firstName,\r\n-      lastName: m.lastName,\r\n-      memberType: m.memberType,\r\n-      createdAt: m.createdAt,\r\n-    }));\r\n-\r\n-    res.json(response);\r\n-  } catch (err) {\r\n-    console.error('Fetch members error:', err);\r\n-    res.status(500).json({ error: 'Failed to fetch members' });\r\n-  }\r\n-});\r\n-\r\n-router.get('/monthly-revenue', async (req, res) => {\r\n-  const { clubId, month, year } = req.query; // month (1-12), year (e.g., 2023)\r\n-\r\n-  const currentYear = year ? parseInt(year as string) : new Date().getFullYear();\r\n-  const currentMonth = month ? parseInt(month as string) - 1 : new Date().getMonth();\r\n-\r\n-  const startDate = new Date(currentYear, currentMonth, 1);\r\n-  const endDate = new Date(currentYear, currentMonth + 1, 0);\r\n-\r\n-  let invoiceFilters: any = {\r\n-    status: 'paid',\r\n-    issuedAt: {\r\n-      gte: startDate,\r\n-      lte: endDate,\r\n-    },\r\n-  };\r\n-\r\n-  if (clubId) {\r\n-    invoiceFilters.clubId = String(clubId);\r\n-  } else {\r\n-    console.log('Backend /api/billing/monthly-revenue: No clubId provided, fetching GLOBAL monthly revenue.');\r\n-  }\r\n-\r\n-  try {\r\n-    const monthlyRevenueResult = await prisma.invoice.aggregate({\r\n-      where: invoiceFilters,\r\n-      _sum: { amount: true },\r\n-    });\r\n-\r\n-    const totalMonthlyRevenue = monthlyRevenueResult._sum.amount ?? 0;\r\n-\r\n-    res.json({ monthlyRevenue: totalMonthlyRevenue });\r\n-  } catch (err) {\r\n-    console.error('Error fetching monthly revenue:', err);\r\n-    res.status(500).json({ error: 'Failed to fetch monthly revenue' });\r\n-  }\r\n-});\r\n-\r\n-// router.get('/revenue-trend', async (req, res) => {\r\n-//   const { clubId, startDate, endDate } = req.query; // Add startDate and endDate for optional filtering\r\n-\r\n-//   // IMPORTANT CHANGE: Remove the direct 400 error if clubId is missing.\r\n-//   // if (!clubId) return res.status(400).json({ error: 'Missing clubId' }); // <-- REMOVE THIS LINE\r\n-\r\n-//   // Define date range. Default to last 30 days if not provided, or a larger range.\r\n-//   // For a trend graph, a default range is usually good. Let's use 90 days for example.\r\n-//   const defaultDays = 90;\r\n-//   const end = endDate ? new Date(String(endDate)) : new Date();\r\n-//   const start = startDate ? new Date(String(startDate)) : new Date();\r\n-//   if (!startDate) { // If no startDate provided, default to 90 days ago\r\n-//     start.setDate(end.getDate() - defaultDays);\r\n-//   }\r\n-\r\n-//   start.setHours(0, 0, 0, 0); // Set to start of the day\r\n-//   end.setHours(23, 59, 59, 999); // Set to end of the day\r\n-\r\n-//   let whereClause: any = {\r\n-//     status: 'paid', // Only sum paid invoices\r\n-//     issuedAt: {\r\n-//       gte: start,\r\n-//       lte: end,\r\n-//     },\r\n-//   };\r\n-\r\n-//   // Conditionally add clubId to whereClause\r\n-//   if (clubId) {\r\n-//     whereClause.clubId = String(clubId);\r\n-//     console.log(`Backend /api/billing/revenue-trend: clubId provided (${clubId}), fetching club-specific revenue trend.`);\r\n-//   } else {\r\n-//     console.log('Backend /api/billing/revenue-trend: No clubId provided, fetching GLOBAL revenue trend.');\r\n-//   }\r\n-\r\n-//   try {\r\n-//     const results = await prisma.$queryRawUnsafe<\r\n-//   { date: string; revenue: number }[]\r\n-// >(`\r\n-//   SELECT \r\n-//     DATE(\"issuedAt\") AS date, \r\n-//     SUM(\"amount\") AS revenue \r\n-//   FROM \"Invoice\"\r\n-//   WHERE \"status\" = 'paid'\r\n-//     AND \"issuedAt\" BETWEEN $1 AND $2\r\n-//     ${clubId ? `AND \"clubId\" = '${clubId}'` : ''}\r\n-//   GROUP BY DATE(\"issuedAt\")\r\n-//   ORDER BY DATE(\"issuedAt\") ASC\r\n-// `, start, end);\r\n-\r\n-// console.log('Backend: Raw query results for revenue-trend:', results);\r\n-\r\n-//     // Fill in missing dates with 0 revenue to ensure a continuous trend line\r\n-//     const trend: { date: string; revenue: number }[] = [];\r\n-//     let currentDate = new Date(start);\r\n-//     while (currentDate <= end) {\r\n-//       const dateKey = currentDate.toISOString().split('T')[0];\r\n-//       const found = results.find(r => r.date === dateKey);\r\n-//       trend.push({\r\n-//         date: dateKey,\r\n-//         revenue: found ? Number(found.revenue) : 0,\r\n-//       });\r\n-//       currentDate.setDate(currentDate.getDate() + 1); // Move to the next day\r\n-//     }\r\n-\r\n-//      console.log('Backend: Processed revenue trend data sent to frontend:', trend); // <-- ADD THIS LINE\r\n-\r\n-//     res.json(trend);\r\n-//   } catch (err) {\r\n-//     console.error('Revenue trend error:', err);\r\n-//     res.status(500).json({ error: 'Failed to fetch revenue trend' });\r\n-//   }\r\n-// });\r\n-\r\n-router.get('/revenue-trend', async (req: Request, res: Response) => {\r\n-  const { clubId, startDate, endDate } = req.query;\r\n-\r\n-  // Define date range.\r\n-  const defaultDays = 90;\r\n-  const end = endDate ? new Date(String(endDate)) : new Date();\r\n-  const start = startDate ? new Date(String(startDate)) : new Date();\r\n-\r\n-  if (!startDate) {\r\n-    start.setDate(end.getDate() - defaultDays);\r\n-  }\r\n-\r\n-  // Set to start/end of the day based on the dates provided by the frontend.\r\n-  // The frontend sends specific `endDate` (now) and `startDate` (90 days ago) with time components.\r\n-  // It's better to let those time components be, or explicitly handle them to ensure full days are covered.\r\n-  // For 'today' range, frontend is setting start of day (00:00:00) and end of day (23:59:59.999).\r\n-  // Keep these as precise as possible.\r\n-  // start.setHours(0, 0, 0, 0); // Front end should ideally send these already set or you handle it here.\r\n-  // end.setHours(23, 59, 59, 999); // Front end should ideally send these already set or you handle it here.\r\n-\r\n-\r\n-  let whereClause: any = {\r\n-    status: InvoiceStatus.paid, // Use enum for status\r\n-    issuedAt: {\r\n-      gte: start,\r\n-      lte: end,\r\n-    },\r\n-  };\r\n-\r\n-  if (clubId) {\r\n-    whereClause.clubId = String(clubId);\r\n-    console.log(`Backend /api/billing/revenue-trend: clubId provided (${clubId}), fetching club-specific revenue trend.`);\r\n-  } else {\r\n-    console.log('Backend /api/billing/revenue-trend: No clubId provided, fetching GLOBAL revenue trend.');\r\n-  }\r\n-\r\n-  console.log('Backend /api/billing/revenue-trend: Querying with startDate:', start.toISOString(), 'endDate:', end.toISOString());\r\n-\r\n-  try {\r\n-    const rawRevenueData = await prisma.invoice.groupBy({\r\n-      by: ['issuedAt'], // Group by the full timestamp for now, we'll process it later\r\n-      where: whereClause,\r\n-      _sum: {\r\n-        amount: true,\r\n-      },\r\n-      orderBy: {\r\n-        issuedAt: 'asc',\r\n-      },\r\n-    });\r\n-\r\n-    // Aggregate by date (YYYY-MM-DD) in the application layer\r\n-    // This is more reliable as it uses the same timezone logic as your application\r\n-    // and avoids PostgreSQL's internal timezone conversion ambiguities for DATE().\r\n-    const dailyAggregatedRevenue: { [key: string]: number } = {};\r\n-\r\n-    rawRevenueData.forEach(item => {\r\n-      // Get the date part in a consistent way (e.g., UTC date string)\r\n-      // Or, better, use the user's local timezone if you want the chart to align with local days\r\n-      // For simplicity, let's stick to UTC for consistency with ISO strings if the chart is expecting UTC.\r\n-      // If your frontend uses local time for date display, ensure consistency.\r\n-      const dateKey = item.issuedAt.toISOString().split('T')[0]; // YYYY-MM-DD (UTC date)\r\n-      dailyAggregatedRevenue[dateKey] = (dailyAggregatedRevenue[dateKey] || 0) + (item._sum.amount || 0);\r\n-    });\r\n-\r\n-    // Fill in missing dates with 0 revenue\r\n-    const trend: { date: string; revenue: number }[] = [];\r\n-    let currentDate = new Date(start);\r\n-\r\n-    // Make sure `currentDate` is also at the start of the day for consistent comparison\r\n-    currentDate.setHours(0, 0, 0, 0);\r\n-\r\n-    while (currentDate <= end) {\r\n-      const dateKey = currentDate.toISOString().split('T')[0];\r\n-      trend.push({\r\n-        date: dateKey,\r\n-        revenue: dailyAggregatedRevenue[dateKey] || 0,\r\n-      });\r\n-      currentDate.setDate(currentDate.getDate() + 1); // Move to the next day\r\n-      currentDate.setHours(0, 0, 0, 0); // Ensure it stays at the start of the day\r\n-    }\r\n-\r\n-    console.log('Backend: Processed revenue trend data sent to frontend:', trend);\r\n     res.json(trend);\r\n \r\n   } catch (err) {\r\n     console.error('Revenue trend error:', err);\r\n"
                },
                {
                    "date": 1753177936639,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -489,9 +489,9 @@\n   console.log('No revenue data found, adding dummy data for testing');\r\n   // Add some dummy data for testing\r\n   trend.forEach((item, index) => {\r\n     if (index % 7 === 0) { // Add revenue every 7th day\r\n-      item.revenue = Math.floor(Math.random() * 1459.98) + 1000;\r\n+      item.revenue = Math.floor(Math.random() * 1000) + 1000;\r\n     }\r\n   });\r\n }\r\n     \r\n"
                },
                {
                    "date": 1753177948412,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -489,9 +489,9 @@\n   console.log('No revenue data found, adding dummy data for testing');\r\n   // Add some dummy data for testing\r\n   trend.forEach((item, index) => {\r\n     if (index % 7 === 0) { // Add revenue every 7th day\r\n-      item.revenue = Math.floor(Math.random() * 1000) + 1000;\r\n+      item.revenue = Math.floor(Math.random() * 800) + 1000;\r\n     }\r\n   });\r\n }\r\n     \r\n"
                },
                {
                    "date": 1753177960403,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -489,9 +489,9 @@\n   console.log('No revenue data found, adding dummy data for testing');\r\n   // Add some dummy data for testing\r\n   trend.forEach((item, index) => {\r\n     if (index % 7 === 0) { // Add revenue every 7th day\r\n-      item.revenue = Math.floor(Math.random() * 800) + 1000;\r\n+      item.revenue = Math.floor(Math.random() * 600) + 1000;\r\n     }\r\n   });\r\n }\r\n     \r\n"
                },
                {
                    "date": 1753177969023,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -489,9 +489,9 @@\n   console.log('No revenue data found, adding dummy data for testing');\r\n   // Add some dummy data for testing\r\n   trend.forEach((item, index) => {\r\n     if (index % 7 === 0) { // Add revenue every 7th day\r\n-      item.revenue = Math.floor(Math.random() * 600) + 1000;\r\n+      item.revenue = Math.floor(Math.random() * 500) + 1000;\r\n     }\r\n   });\r\n }\r\n     \r\n"
                },
                {
                    "date": 1753177980636,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -489,9 +489,9 @@\n   console.log('No revenue data found, adding dummy data for testing');\r\n   // Add some dummy data for testing\r\n   trend.forEach((item, index) => {\r\n     if (index % 7 === 0) { // Add revenue every 7th day\r\n-      item.revenue = Math.floor(Math.random() * 500) + 1000;\r\n+      item.revenue = Math.floor(Math.random() * 400) + 1000;\r\n     }\r\n   });\r\n }\r\n     \r\n"
                },
                {
                    "date": 1753177992893,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -489,9 +489,9 @@\n   console.log('No revenue data found, adding dummy data for testing');\r\n   // Add some dummy data for testing\r\n   trend.forEach((item, index) => {\r\n     if (index % 7 === 0) { // Add revenue every 7th day\r\n-      item.revenue = Math.floor(Math.random() * 400) + 1000;\r\n+      item.revenue = Math.floor(Math.random() * 450) + 1000;\r\n     }\r\n   });\r\n }\r\n     \r\n"
                },
                {
                    "date": 1753178003376,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -489,9 +489,9 @@\n   console.log('No revenue data found, adding dummy data for testing');\r\n   // Add some dummy data for testing\r\n   trend.forEach((item, index) => {\r\n     if (index % 7 === 0) { // Add revenue every 7th day\r\n-      item.revenue = Math.floor(Math.random() * 450) + 1000;\r\n+      item.revenue = Math.floor(Math.random() * 400) + 1000;\r\n     }\r\n   });\r\n }\r\n     \r\n"
                },
                {
                    "date": 1753178044433,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -484,18 +484,9 @@\n     console.log('Backend: Processed revenue trend data sent to frontend (first 10 items):');\r\n     console.log(trend.slice(0, 10));\r\n     console.log('Backend: Non-zero revenue days:');\r\n     console.log(trend.filter(item => item.revenue > 0));\r\n-  if (trend.every(item => item.revenue === 0)) {\r\n-  console.log('No revenue data found, adding dummy data for testing');\r\n-  // Add some dummy data for testing\r\n-  trend.forEach((item, index) => {\r\n-    if (index % 7 === 0) { // Add revenue every 7th day\r\n-      item.revenue = Math.floor(Math.random() * 400) + 1000;\r\n-    }\r\n-  });\r\n-}\r\n-    \r\n+  \r\n \r\n \r\n   \r\n     res.json(trend);\r\n"
                },
                {
                    "date": 1753178678809,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -199,9 +199,9 @@\n \r\n   try {\r\n     const [totalRevenueResult, unpaidDuesResult, activeMembersCount, totalBookingsResult, totalAttendancesResult] = await Promise.all([\r\n       prisma.invoice.aggregate({\r\n-        where: { ...invoiceFilters, status: 'paid' },\r\n+        where: { ...invoiceFilters, status: InvoiceStatus.paid },\r\n         _sum: { amount: true },\r\n       }),\r\n       prisma.invoice.aggregate({\r\n         where: { ...invoiceFilters, status: { in: ['unpaid', 'overdue', 'failed'] } },\r\n"
                },
                {
                    "date": 1753178713369,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -203,9 +203,9 @@\n         where: { ...invoiceFilters, status: InvoiceStatus.paid },\r\n         _sum: { amount: true },\r\n       }),\r\n       prisma.invoice.aggregate({\r\n-        where: { ...invoiceFilters, status: { in: ['unpaid', 'overdue', 'failed'] } },\r\n+        where: { ...invoiceFilters, status: { in: [InvoiceStatus.unpaid, InvoiceStatus.overdue, InvoiceStatus.failed] } },\r\n         _sum: { amount: true },\r\n       }),\r\n       prisma.member.count({\r\n         where: memberCountFilters,\r\n"
                },
                {
                    "date": 1753178743534,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -290,9 +290,9 @@\n   const startDate = new Date(currentYear, currentMonth, 1);\r\n   const endDate = new Date(currentYear, currentMonth + 1, 0);\r\n \r\n   let invoiceFilters: any = {\r\n-    status: 'paid',\r\n+    status: InvoiceStatus.paid,\r\n     issuedAt: {\r\n       gte: startDate,\r\n       lte: endDate,\r\n     },\r\n"
                }
            ],
            "date": 1752358300670,
            "name": "Commit-0",
            "content": "import express from 'express';\r\nimport { PrismaClient } from '@prisma/client';\r\nimport { Request, Response } from 'express';\r\n\r\nconst router = express.Router();\r\nconst prisma = new PrismaClient();\r\n\r\nrouter.post('/:memberId/payment-method', async (req, res) => {\r\n  try {\r\n    const { memberId } = req.params;\r\n    const { cardNumber, expiry, cvc } = req.body;\r\n\r\n    // ðŸ”§ fake parsing for local storage (replace with Stripe integration later)\r\n    const last4 = cardNumber.slice(-4);\r\n    const [expMonth, expYear] = expiry.split('/');\r\n\r\n    const method = await prisma.paymentMethod.create({\r\n      data: {\r\n        memberId,\r\n        cardBrand: 'visa',\r\n        last4,\r\n        expMonth: parseInt(expMonth),\r\n        expYear: parseInt(`20${expYear}`),\r\n      },\r\n    });\r\n\r\n    res.status(201).json(method);\r\n  } catch (err) {\r\n    console.error('Save Payment Method Error:', err);\r\n    res.status(500).json({ error: 'Failed to save payment method' });\r\n  }\r\n});\r\n"
        }
    ]
}