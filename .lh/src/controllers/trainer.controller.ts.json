{
    "sourceFile": "src/controllers/trainer.controller.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 16,
            "patches": [
                {
                    "date": 1752451240563,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1752482121022,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,4 +1,8 @@\n+//src>controllers/trainer.controller.ts\r\n+import { Request, Response } from 'express';\r\n+\r\n+import prisma from '../lib/prisma';\r\n export const getTrainersByFranchise = async (req: Request, res: Response) => {\r\n   const { franchiseId } = req.params;\r\n \r\n   try {\r\n"
                },
                {
                    "date": 1752482705479,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,21 +1,26 @@\n-//src>controllers/trainer.controller.ts\r\n import { Request, Response } from 'express';\r\n+import { PrismaClient } from '@prisma/client';\r\n \r\n-import prisma from '../lib/prisma';\r\n+const prisma = new PrismaClient();\r\n+\r\n export const getTrainersByFranchise = async (req: Request, res: Response) => {\r\n   const { franchiseId } = req.params;\r\n \r\n   try {\r\n-    const trainers = await prisma.user.findMany({\r\n+    const trainers = await prisma.trainer.findMany({\r\n       where: {\r\n-        role: 'trainer',\r\n-        franchiseId,\r\n+        clubId: franchiseId, // ✅ This matches your schema\r\n       },\r\n-      select: { id: true, firstName: true, lastName: true },\r\n+      select: {\r\n+        id: true,\r\n+        name: true,\r\n+        email: true,\r\n+      },\r\n     });\r\n \r\n     res.json(trainers);\r\n   } catch (error) {\r\n+    console.error('Error fetching trainers:', error);\r\n     res.status(500).json({ error: 'Error fetching trainers' });\r\n   }\r\n };\r\n"
                },
                {
                    "date": 1752490243069,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,4 +1,5 @@\n+// src/controllers/trainer.controller.ts\r\n import { Request, Response } from 'express';\r\n import { PrismaClient } from '@prisma/client';\r\n \r\n const prisma = new PrismaClient();\r\n"
                },
                {
                    "date": 1752729681442,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -24,4 +24,36 @@\n     console.error('Error fetching trainers:', error);\r\n     res.status(500).json({ error: 'Error fetching trainers' });\r\n   }\r\n };\r\n+\r\n+\r\n+export const createTrainer = async (req: Request, res: Response) => {\r\n+  const { name, email, phone, specialization, clubId } = req.body;\r\n+\r\n+  // Basic validation\r\n+  if (!name || !email || !clubId) {\r\n+    return res.status(400).json({ error: 'Name, email, and clubId are required.' });\r\n+  }\r\n+\r\n+  try {\r\n+    const newTrainer = await prisma.trainer.create({\r\n+      data: {\r\n+        name,\r\n+        email,\r\n+        phone, // Optional, so no strong validation here\r\n+        specialization, // Optional\r\n+        club: {\r\n+          connect: { id: clubId }, // Connect the trainer to the specified club\r\n+        },\r\n+      },\r\n+    });\r\n+    res.status(201).json(newTrainer); // 201 Created status\r\n+  } catch (error) {\r\n+    console.error('Error creating trainer:', error);\r\n+    // Handle specific Prisma errors, e.g., unique constraint violation for email\r\n+    if (error.code === 'P2002' && error.meta?.target?.includes('email')) {\r\n+      return res.status(409).json({ error: 'A trainer with this email already exists.' });\r\n+    }\r\n+    res.status(500).json({ error: 'Failed to create trainer.' });\r\n+  }\r\n+};\r\n"
                },
                {
                    "date": 1752730086769,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,31 +3,53 @@\n import { PrismaClient } from '@prisma/client';\r\n \r\n const prisma = new PrismaClient();\r\n \r\n+// export const getTrainersByFranchise = async (req: Request, res: Response) => {\r\n+//   const { franchiseId } = req.params;\r\n+\r\n+//   try {\r\n+//     const trainers = await prisma.trainer.findMany({\r\n+//       where: {\r\n+//         clubId: franchiseId, // ✅ This matches your schema\r\n+//       },\r\n+//       select: {\r\n+//         id: true,\r\n+//         name: true,\r\n+//         email: true,\r\n+//       },\r\n+//     });\r\n+\r\n+//     res.json(trainers);\r\n+//   } catch (error) {\r\n+//     console.error('Error fetching trainers:', error);\r\n+//     res.status(500).json({ error: 'Error fetching trainers' });\r\n+//   }\r\n+// };\r\n+\r\n export const getTrainersByFranchise = async (req: Request, res: Response) => {\r\n-  const { franchiseId } = req.params;\r\n+  const { clubId } = req.params; // Changed to clubId to match common naming\r\n \r\n   try {\r\n     const trainers = await prisma.trainer.findMany({\r\n       where: {\r\n-        clubId: franchiseId, // ✅ This matches your schema\r\n+        clubId: clubId,\r\n       },\r\n       select: {\r\n         id: true,\r\n         name: true,\r\n         email: true,\r\n+        phone: true,\r\n+        specialization: true\r\n       },\r\n     });\r\n-\r\n     res.json(trainers);\r\n   } catch (error) {\r\n     console.error('Error fetching trainers:', error);\r\n     res.status(500).json({ error: 'Error fetching trainers' });\r\n   }\r\n };\r\n \r\n-\r\n export const createTrainer = async (req: Request, res: Response) => {\r\n   const { name, email, phone, specialization, clubId } = req.body;\r\n \r\n   // Basic validation\r\n"
                },
                {
                    "date": 1752733219410,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -48,8 +48,39 @@\n     res.status(500).json({ error: 'Error fetching trainers' });\r\n   }\r\n };\r\n \r\n+// export const createTrainer = async (req: Request, res: Response) => {\r\n+//   const { name, email, phone, specialization, clubId } = req.body;\r\n+\r\n+//   // Basic validation\r\n+//   if (!name || !email || !clubId) {\r\n+//     return res.status(400).json({ error: 'Name, email, and clubId are required.' });\r\n+//   }\r\n+\r\n+//   try {\r\n+//     const newTrainer = await prisma.trainer.create({\r\n+//       data: {\r\n+//         name,\r\n+//         email,\r\n+//         phone, // Optional, so no strong validation here\r\n+//         specialization, // Optional\r\n+//         club: {\r\n+//           connect: { id: clubId }, // Connect the trainer to the specified club\r\n+//         },\r\n+//       },\r\n+//     });\r\n+//     res.status(201).json(newTrainer); // 201 Created status\r\n+//   } catch (error) {\r\n+//     console.error('Error creating trainer:', error);\r\n+//     // Handle specific Prisma errors, e.g., unique constraint violation for email\r\n+//     if (error.code === 'P2002' && error.meta?.target?.includes('email')) {\r\n+//       return res.status(409).json({ error: 'A trainer with this email already exists.' });\r\n+//     }\r\n+//     res.status(500).json({ error: 'Failed to create trainer.' });\r\n+//   }\r\n+// };\r\n+\r\n export const createTrainer = async (req: Request, res: Response) => {\r\n   const { name, email, phone, specialization, clubId } = req.body;\r\n \r\n   // Basic validation\r\n@@ -57,25 +88,60 @@\n     return res.status(400).json({ error: 'Name, email, and clubId are required.' });\r\n   }\r\n \r\n   try {\r\n-    const newTrainer = await prisma.trainer.create({\r\n-      data: {\r\n-        name,\r\n-        email,\r\n-        phone, // Optional, so no strong validation here\r\n-        specialization, // Optional\r\n-        club: {\r\n-          connect: { id: clubId }, // Connect the trainer to the specified club\r\n+    // Start a Prisma transaction for atomicity: Create User AND Trainer\r\n+    const [user, trainer] = await prisma.$transaction([\r\n+      // 1. Create a User record for the trainer\r\n+      // We don't set a password here; it will be set via the email link\r\n+      prisma.user.create({\r\n+        data: {\r\n+          email,\r\n+          // Assign a temporary dummy password or null if your schema allows null.\r\n+          // If password cannot be null, use a strong random string here,\r\n+          // then immediately send a reset link, and user will overwrite it.\r\n+          // For simplicity, we'll use a placeholder and expect it to be updated.\r\n+          // Using a secure temporary password is more robust if password field is not nullable.\r\n+          password: await hashPassword('temp-password-123!@#'), // This will be overwritten by setup link\r\n+          role: 'trainer', // Assign the 'trainer' role\r\n+          club: { connect: { id: clubId } },\r\n+          name: name, // Associate the user name\r\n         },\r\n+      }),\r\n+      // 2. Create the Trainer record\r\n+      prisma.trainer.create({\r\n+        data: {\r\n+          name,\r\n+          email,\r\n+          phone,\r\n+          specialization,\r\n+          club: { connect: { id: clubId } },\r\n+        },\r\n+      }),\r\n+    ]);\r\n+\r\n+    // 3. Generate a password setup token and send email\r\n+    const passwordSetupToken = generatePasswordSetupToken(user.id, user.email);\r\n+    await sendPasswordSetupEmail(user.email, user.name || 'Trainer', passwordSetupToken);\r\n+\r\n+    res.status(201).json({\r\n+      message: 'Trainer created successfully. An email has been sent to set their password.',\r\n+      trainer: {\r\n+        id: trainer.id,\r\n+        name: trainer.name,\r\n+        email: trainer.email,\r\n+        phone: trainer.phone,\r\n+        specialization: trainer.specialization,\r\n       },\r\n+      userId: user.id // Return the user ID for reference\r\n     });\r\n-    res.status(201).json(newTrainer); // 201 Created status\r\n+\r\n   } catch (error) {\r\n-    console.error('Error creating trainer:', error);\r\n+    console.error('Error creating trainer and user:', error);\r\n     // Handle specific Prisma errors, e.g., unique constraint violation for email\r\n     if (error.code === 'P2002' && error.meta?.target?.includes('email')) {\r\n-      return res.status(409).json({ error: 'A trainer with this email already exists.' });\r\n+      // If trainer or user email already exists, it will throw this error\r\n+      return res.status(409).json({ error: 'A trainer or user with this email already exists.' });\r\n     }\r\n-    res.status(500).json({ error: 'Failed to create trainer.' });\r\n+    res.status(500).json({ error: 'Failed to create trainer and user.' });\r\n   }\r\n-};\r\n+};\n\\ No newline at end of file\n"
                },
                {
                    "date": 1752733262180,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,9 @@\n // src/controllers/trainer.controller.ts\r\n import { Request, Response } from 'express';\r\n import { PrismaClient } from '@prisma/client';\r\n+import { hashPassword, generatePasswordSetupToken } from '../utils/authUtils'; // Import auth utilities\r\n+import { sendPasswordSetupEmail } from '../services/email.service; \r\n \r\n const prisma = new PrismaClient();\r\n \r\n // export const getTrainersByFranchise = async (req: Request, res: Response) => {\r\n"
                },
                {
                    "date": 1752733269371,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,9 +1,9 @@\n // src/controllers/trainer.controller.ts\r\n import { Request, Response } from 'express';\r\n import { PrismaClient } from '@prisma/client';\r\n import { hashPassword, generatePasswordSetupToken } from '../utils/authUtils'; // Import auth utilities\r\n-import { sendPasswordSetupEmail } from '../services/email.service; \r\n+import { sendPasswordSetupEmail } from '../services/email.service'; \r\n \r\n const prisma = new PrismaClient();\r\n \r\n // export const getTrainersByFranchise = async (req: Request, res: Response) => {\r\n"
                },
                {
                    "date": 1752758239080,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,183 @@\n+// src/controllers/trainer.controller.ts\r\n+import { Request, Response } from 'express';\r\n+import { PrismaClient } from '@prisma/client';\r\n+import { hashPassword, generatePasswordSetupToken } from '../utils/authUtils'; // Import auth utilities\r\n+import { sendPasswordSetupEmail } from '../services/email.service'; \r\n+\r\n+\r\n+const prisma = new PrismaClient();\r\n+\r\n+\r\n+interface AuthenticatedRequest extends Request {\r\n+  user?: {\r\n+    id: string;\r\n+    clubId?: string;\r\n+    role: string;\r\n+  };\r\n+}\r\n+// export const getTrainersByFranchise = async (req: Request, res: Response) => {\r\n+//   const { franchiseId } = req.params;\r\n+\r\n+//   try {\r\n+//     const trainers = await prisma.trainer.findMany({\r\n+//       where: {\r\n+//         clubId: franchiseId, // ✅ This matches your schema\r\n+//       },\r\n+//       select: {\r\n+//         id: true,\r\n+//         name: true,\r\n+//         email: true,\r\n+//       },\r\n+//     });\r\n+\r\n+//     res.json(trainers);\r\n+//   } catch (error) {\r\n+//     console.error('Error fetching trainers:', error);\r\n+//     res.status(500).json({ error: 'Error fetching trainers' });\r\n+//   }\r\n+// };\r\n+\r\n+// export const getTrainersByFranchise = async (req: Request, res: Response) => {\r\n+//   const { clubId } = req.params; // Changed to clubId to match common naming\r\n+\r\n+//   try {\r\n+//     const trainers = await prisma.trainer.findMany({\r\n+//       where: {\r\n+//         clubId: clubId,\r\n+//       },\r\n+//       select: {\r\n+//         id: true,\r\n+//         name: true,\r\n+//         email: true,\r\n+//         phone: true,\r\n+//         specialization: true\r\n+//       },\r\n+//     });\r\n+//     res.json(trainers);\r\n+//   } catch (error) {\r\n+//     console.error('Error fetching trainers:', error);\r\n+//     res.status(500).json({ error: 'Error fetching trainers' });\r\n+//   }\r\n+// };\r\n+\r\n+\r\n+export const getTrainersByFranchise = async (req: AuthenticatedRequest, res: Response) => {\r\n+  const { franchiseId } = req.params; // This is the clubId\r\n+  const userClubId = req.user?.clubId;\r\n+  const userRole = req.user?.role;\r\n+\r\n+  // Ensure the requesting user is an admin for that club, or a super_admin\r\n+  if (!userClubId || (userRole !== 'super_admin' && userClubId !== franchiseId)) {\r\n+    return res.status(403).json({ error: 'Access denied. Not authorized for this club.' });\r\n+  }\r\n+\r\n+  try {\r\n+    const trainers = await prisma.trainer.findMany({\r\n+      where: { clubId: franchiseId },\r\n+      select: { id: true, name: true }, // Only need ID and name for dropdown\r\n+      orderBy: { name: 'asc' }\r\n+    });\r\n+    res.json(trainers);\r\n+  } catch (error) {\r\n+    console.error('Error fetching trainers:', error);\r\n+    res.status(500).json({ error: 'Failed to fetch trainers.' });\r\n+  }\r\n+};\r\n+\r\n+\r\n+// export const createTrainer = async (req: Request, res: Response) => {\r\n+//   const { name, email, phone, specialization, clubId } = req.body;\r\n+\r\n+//   // Basic validation\r\n+//   if (!name || !email || !clubId) {\r\n+//     return res.status(400).json({ error: 'Name, email, and clubId are required.' });\r\n+//   }\r\n+\r\n+//   try {\r\n+//     const newTrainer = await prisma.trainer.create({\r\n+//       data: {\r\n+//         name,\r\n+//         email,\r\n+//         phone, // Optional, so no strong validation here\r\n+//         specialization, // Optional\r\n+//         club: {\r\n+//           connect: { id: clubId }, // Connect the trainer to the specified club\r\n+//         },\r\n+//       },\r\n+//     });\r\n+//     res.status(201).json(newTrainer); // 201 Created status\r\n+//   } catch (error) {\r\n+//     console.error('Error creating trainer:', error);\r\n+//     // Handle specific Prisma errors, e.g., unique constraint violation for email\r\n+//     if (error.code === 'P2002' && error.meta?.target?.includes('email')) {\r\n+//       return res.status(409).json({ error: 'A trainer with this email already exists.' });\r\n+//     }\r\n+//     res.status(500).json({ error: 'Failed to create trainer.' });\r\n+//   }\r\n+// };\r\n+\r\n+export const createTrainer = async (req: Request, res: Response) => {\r\n+  const { name, email, phone, specialization, clubId } = req.body;\r\n+\r\n+  // Basic validation\r\n+  if (!name || !email || !clubId) {\r\n+    return res.status(400).json({ error: 'Name, email, and clubId are required.' });\r\n+  }\r\n+\r\n+  try {\r\n+    // Start a Prisma transaction for atomicity: Create User AND Trainer\r\n+    const [user, trainer] = await prisma.$transaction([\r\n+      // 1. Create a User record for the trainer\r\n+      // We don't set a password here; it will be set via the email link\r\n+      prisma.user.create({\r\n+        data: {\r\n+          email,\r\n+          // Assign a temporary dummy password or null if your schema allows null.\r\n+          // If password cannot be null, use a strong random string here,\r\n+          // then immediately send a reset link, and user will overwrite it.\r\n+          // For simplicity, we'll use a placeholder and expect it to be updated.\r\n+          // Using a secure temporary password is more robust if password field is not nullable.\r\n+          password: await hashPassword('temp-password-123!@#'), // This will be overwritten by setup link\r\n+          role: 'trainer', // Assign the 'trainer' role\r\n+          club: { connect: { id: clubId } },\r\n+          name: name, // Associate the user name\r\n+        },\r\n+      }),\r\n+      // 2. Create the Trainer record\r\n+      prisma.trainer.create({\r\n+        data: {\r\n+          name,\r\n+          email,\r\n+          phone,\r\n+          specialization,\r\n+          club: { connect: { id: clubId } },\r\n+        },\r\n+      }),\r\n+    ]);\r\n+\r\n+    // 3. Generate a password setup token and send email\r\n+    const passwordSetupToken = generatePasswordSetupToken(user.id, user.email);\r\n+    await sendPasswordSetupEmail(user.email, user.name || 'Trainer', passwordSetupToken);\r\n+\r\n+    res.status(201).json({\r\n+      message: 'Trainer created successfully. An email has been sent to set their password.',\r\n+      trainer: {\r\n+        id: trainer.id,\r\n+        name: trainer.name,\r\n+        email: trainer.email,\r\n+        phone: trainer.phone,\r\n+        specialization: trainer.specialization,\r\n+      },\r\n+      userId: user.id // Return the user ID for reference\r\n+    });\r\n+\r\n+  } catch (error) {\r\n+    console.error('Error creating trainer and user:', error);\r\n+    // Handle specific Prisma errors, e.g., unique constraint violation for email\r\n+    if (error.code === 'P2002' && error.meta?.target?.includes('email')) {\r\n+      // If trainer or user email already exists, it will throw this error\r\n+      return res.status(409).json({ error: 'A trainer or user with this email already exists.' });\r\n+    }\r\n+    res.status(500).json({ error: 'Failed to create trainer and user.' });\r\n+  }\r\n+};\n\\ No newline at end of file\n"
                },
                {
                    "date": 1752810852014,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -124,187 +124,42 @@\n     return res.status(400).json({ error: 'Name, email, and clubId are required.' });\r\n   }\r\n \r\n   try {\r\n-    // Start a Prisma transaction for atomicity: Create User AND Trainer\r\n-    const [user, trainer] = await prisma.$transaction([\r\n-      // 1. Create a User record for the trainer\r\n-      // We don't set a password here; it will be set via the email link\r\n-      prisma.user.create({\r\n+    // --- START: Corrected Prisma Transaction for linking User and Trainer ---\r\n+    const result = await prisma.$transaction(async (tx) => {\r\n+      // 1. Create the User record first\r\n+      const user = await tx.user.create({\r\n         data: {\r\n           email,\r\n-          // Assign a temporary dummy password or null if your schema allows null.\r\n-          // If password cannot be null, use a strong random string here,\r\n-          // then immediately send a reset link, and user will overwrite it.\r\n-          // For simplicity, we'll use a placeholder and expect it to be updated.\r\n-          // Using a secure temporary password is more robust if password field is not nullable.\r\n-          password: await hashPassword('temp-password-123!@#'), // This will be overwritten by setup link\r\n+          // Assign a temporary dummy password. It will be overwritten by the setup link.\r\n+          // Ensure your User.password field is not nullable, or handle null passwords if it is.\r\n+          password: await hashPassword('temp-password-123!@#'), // Hash a temporary password\r\n           role: 'trainer', // Assign the 'trainer' role\r\n           club: { connect: { id: clubId } },\r\n           name: name, // Associate the user name\r\n         },\r\n-      }),\r\n-      // 2. Create the Trainer record\r\n-      prisma.trainer.create({\r\n+      });\r\n+\r\n+      // 2. Now, create the Trainer record and link it to the newly created User\r\n+      const trainer = await tx.trainer.create({\r\n         data: {\r\n           name,\r\n           email,\r\n           phone,\r\n           specialization,\r\n           club: { connect: { id: clubId } },\r\n+          userId: user.id, // <-- CRUCIAL: Link the Trainer to the User's ID\r\n+          user: { connect: { id: user.id } } // Explicitly connect the user relation\r\n         },\r\n-      }),\r\n-    ]);\r\n+      });\r\n \r\n-    // 3. Generate a password setup token and send email\r\n-    const passwordSetupToken = generatePasswordSetupToken(user.id, user.email);\r\n-    await sendPasswordSetupEmail(user.email, user.name || 'Trainer', passwordSetupToken);\r\n-\r\n-    res.status(201).json({\r\n-      message: 'Trainer created successfully. An email has been sent to set their password.',\r\n-      trainer: {\r\n-        id: trainer.id,\r\n-        name: trainer.name,\r\n-        email: trainer.email,\r\n-        phone: trainer.phone,\r\n-        specialization: trainer.specialization,\r\n-      },\r\n-      userId: user.id // Return the user ID for reference\r\n+      return { user, trainer }; // Return both created records\r\n     });\r\n+    // --- END: Corrected Prisma Transaction ---\r\n \r\n-  } catch (error) {\r\n-    console.error('Error creating trainer and user:', error);\r\n-    // Handle specific Prisma errors, e.g., unique constraint violation for email\r\n-    if (error.code === 'P2002' && error.meta?.target?.includes('email')) {\r\n-      // If trainer or user email already exists, it will throw this error\r\n-      return res.status(409).json({ error: 'A trainer or user with this email already exists.' });\r\n-    }\r\n-    res.status(500).json({ error: 'Failed to create trainer and user.' });\r\n-  }\r\n-};\n-// src/controllers/trainer.controller.ts\r\n-import { Request, Response } from 'express';\r\n-import { PrismaClient } from '@prisma/client';\r\n-import { hashPassword, generatePasswordSetupToken } from '../utils/authUtils'; // Import auth utilities\r\n-import { sendPasswordSetupEmail } from '../services/email.service'; \r\n+    const { user, trainer } = result; // Destructure the results from the transaction\r\n \r\n-const prisma = new PrismaClient();\r\n-\r\n-// export const getTrainersByFranchise = async (req: Request, res: Response) => {\r\n-//   const { franchiseId } = req.params;\r\n-\r\n-//   try {\r\n-//     const trainers = await prisma.trainer.findMany({\r\n-//       where: {\r\n-//         clubId: franchiseId, // ✅ This matches your schema\r\n-//       },\r\n-//       select: {\r\n-//         id: true,\r\n-//         name: true,\r\n-//         email: true,\r\n-//       },\r\n-//     });\r\n-\r\n-//     res.json(trainers);\r\n-//   } catch (error) {\r\n-//     console.error('Error fetching trainers:', error);\r\n-//     res.status(500).json({ error: 'Error fetching trainers' });\r\n-//   }\r\n-// };\r\n-\r\n-export const getTrainersByFranchise = async (req: Request, res: Response) => {\r\n-  const { clubId } = req.params; // Changed to clubId to match common naming\r\n-\r\n-  try {\r\n-    const trainers = await prisma.trainer.findMany({\r\n-      where: {\r\n-        clubId: clubId,\r\n-      },\r\n-      select: {\r\n-        id: true,\r\n-        name: true,\r\n-        email: true,\r\n-        phone: true,\r\n-        specialization: true\r\n-      },\r\n-    });\r\n-    res.json(trainers);\r\n-  } catch (error) {\r\n-    console.error('Error fetching trainers:', error);\r\n-    res.status(500).json({ error: 'Error fetching trainers' });\r\n-  }\r\n-};\r\n-\r\n-// export const createTrainer = async (req: Request, res: Response) => {\r\n-//   const { name, email, phone, specialization, clubId } = req.body;\r\n-\r\n-//   // Basic validation\r\n-//   if (!name || !email || !clubId) {\r\n-//     return res.status(400).json({ error: 'Name, email, and clubId are required.' });\r\n-//   }\r\n-\r\n-//   try {\r\n-//     const newTrainer = await prisma.trainer.create({\r\n-//       data: {\r\n-//         name,\r\n-//         email,\r\n-//         phone, // Optional, so no strong validation here\r\n-//         specialization, // Optional\r\n-//         club: {\r\n-//           connect: { id: clubId }, // Connect the trainer to the specified club\r\n-//         },\r\n-//       },\r\n-//     });\r\n-//     res.status(201).json(newTrainer); // 201 Created status\r\n-//   } catch (error) {\r\n-//     console.error('Error creating trainer:', error);\r\n-//     // Handle specific Prisma errors, e.g., unique constraint violation for email\r\n-//     if (error.code === 'P2002' && error.meta?.target?.includes('email')) {\r\n-//       return res.status(409).json({ error: 'A trainer with this email already exists.' });\r\n-//     }\r\n-//     res.status(500).json({ error: 'Failed to create trainer.' });\r\n-//   }\r\n-// };\r\n-\r\n-export const createTrainer = async (req: Request, res: Response) => {\r\n-  const { name, email, phone, specialization, clubId } = req.body;\r\n-\r\n-  // Basic validation\r\n-  if (!name || !email || !clubId) {\r\n-    return res.status(400).json({ error: 'Name, email, and clubId are required.' });\r\n-  }\r\n-\r\n-  try {\r\n-    // Start a Prisma transaction for atomicity: Create User AND Trainer\r\n-    const [user, trainer] = await prisma.$transaction([\r\n-      // 1. Create a User record for the trainer\r\n-      // We don't set a password here; it will be set via the email link\r\n-      prisma.user.create({\r\n-        data: {\r\n-          email,\r\n-          // Assign a temporary dummy password or null if your schema allows null.\r\n-          // If password cannot be null, use a strong random string here,\r\n-          // then immediately send a reset link, and user will overwrite it.\r\n-          // For simplicity, we'll use a placeholder and expect it to be updated.\r\n-          // Using a secure temporary password is more robust if password field is not nullable.\r\n-          password: await hashPassword('temp-password-123!@#'), // This will be overwritten by setup link\r\n-          role: 'trainer', // Assign the 'trainer' role\r\n-          club: { connect: { id: clubId } },\r\n-          name: name, // Associate the user name\r\n-        },\r\n-      }),\r\n-      // 2. Create the Trainer record\r\n-      prisma.trainer.create({\r\n-        data: {\r\n-          name,\r\n-          email,\r\n-          phone,\r\n-          specialization,\r\n-          club: { connect: { id: clubId } },\r\n-        },\r\n-      }),\r\n-    ]);\r\n-\r\n     // 3. Generate a password setup token and send email\r\n     const passwordSetupToken = generatePasswordSetupToken(user.id, user.email);\r\n     await sendPasswordSetupEmail(user.email, user.name || 'Trainer', passwordSetupToken);\r\n \r\n@@ -319,9 +174,9 @@\n       },\r\n       userId: user.id // Return the user ID for reference\r\n     });\r\n \r\n-  } catch (error) {\r\n+  } catch (error: any) { // Catch as 'any' for broader error handling\r\n     console.error('Error creating trainer and user:', error);\r\n     // Handle specific Prisma errors, e.g., unique constraint violation for email\r\n     if (error.code === 'P2002' && error.meta?.target?.includes('email')) {\r\n       // If trainer or user email already exists, it will throw this error\r\n"
                },
                {
                    "date": 1752811150740,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -147,9 +147,9 @@\n           email,\r\n           phone,\r\n           specialization,\r\n           club: { connect: { id: clubId } },\r\n-          userId: user.id, // <-- CRUCIAL: Link the Trainer to the User's ID\r\n+          \r\n           user: { connect: { id: user.id } } // Explicitly connect the user relation\r\n         },\r\n       });\r\n \r\n"
                },
                {
                    "date": 1752900423043,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -14,54 +14,9 @@\n     clubId?: string;\r\n     role: string;\r\n   };\r\n }\r\n-// export const getTrainersByFranchise = async (req: Request, res: Response) => {\r\n-//   const { franchiseId } = req.params;\r\n \r\n-//   try {\r\n-//     const trainers = await prisma.trainer.findMany({\r\n-//       where: {\r\n-//         clubId: franchiseId, // ✅ This matches your schema\r\n-//       },\r\n-//       select: {\r\n-//         id: true,\r\n-//         name: true,\r\n-//         email: true,\r\n-//       },\r\n-//     });\r\n-\r\n-//     res.json(trainers);\r\n-//   } catch (error) {\r\n-//     console.error('Error fetching trainers:', error);\r\n-//     res.status(500).json({ error: 'Error fetching trainers' });\r\n-//   }\r\n-// };\r\n-\r\n-// export const getTrainersByFranchise = async (req: Request, res: Response) => {\r\n-//   const { clubId } = req.params; // Changed to clubId to match common naming\r\n-\r\n-//   try {\r\n-//     const trainers = await prisma.trainer.findMany({\r\n-//       where: {\r\n-//         clubId: clubId,\r\n-//       },\r\n-//       select: {\r\n-//         id: true,\r\n-//         name: true,\r\n-//         email: true,\r\n-//         phone: true,\r\n-//         specialization: true\r\n-//       },\r\n-//     });\r\n-//     res.json(trainers);\r\n-//   } catch (error) {\r\n-//     console.error('Error fetching trainers:', error);\r\n-//     res.status(500).json({ error: 'Error fetching trainers' });\r\n-//   }\r\n-// };\r\n-\r\n-\r\n export const getTrainersByFranchise = async (req: AuthenticatedRequest, res: Response) => {\r\n   const { franchiseId } = req.params; // This is the clubId\r\n   const userClubId = req.user?.clubId;\r\n   const userRole = req.user?.role;\r\n"
                },
                {
                    "date": 1753182044225,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -79,8 +79,10 @@\n     return res.status(400).json({ error: 'Name, email, and clubId are required.' });\r\n   }\r\n \r\n   try {\r\n+     let createdUser; // Declare user variable outside the transaction for broader scope\r\n+    let createdTrainer; \r\n     // --- START: Corrected Prisma Transaction for linking User and Trainer ---\r\n     const result = await prisma.$transaction(async (tx) => {\r\n       // 1. Create the User record first\r\n       const user = await tx.user.create({\r\n@@ -90,9 +92,11 @@\n           // Ensure your User.password field is not nullable, or handle null passwords if it is.\r\n           password: await hashPassword('temp-password-123!@#'), // Hash a temporary password\r\n           role: 'trainer', // Assign the 'trainer' role\r\n           club: { connect: { id: clubId } },\r\n+\r\n           name: name, // Associate the user name\r\n+          status: 'PENDING',\r\n         },\r\n       });\r\n \r\n       // 2. Now, create the Trainer record and link it to the newly created User\r\n"
                },
                {
                    "date": 1753182188150,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -70,8 +70,96 @@\n //     res.status(500).json({ error: 'Failed to create trainer.' });\r\n //   }\r\n // };\r\n \r\n+// export const createTrainer = async (req: Request, res: Response) => {\r\n+//   const { name, email, phone, specialization, clubId } = req.body;\r\n+\r\n+//   // Basic validation\r\n+//   if (!name || !email || !clubId) {\r\n+//     return res.status(400).json({ error: 'Name, email, and clubId are required.' });\r\n+//   }\r\n+\r\n+//   try {\r\n+//      let createdUser; // Declare user variable outside the transaction for broader scope\r\n+//     let createdTrainer; \r\n+//     // --- START: Corrected Prisma Transaction for linking User and Trainer ---\r\n+//     const result = await prisma.$transaction(async (tx) => {\r\n+//       // 1. Create the User record first\r\n+//       const user = await tx.user.create({\r\n+//         data: {\r\n+//           email,\r\n+//           // Assign a temporary dummy password. It will be overwritten by the setup link.\r\n+//           // Ensure your User.password field is not nullable, or handle null passwords if it is.\r\n+//           password: await hashPassword('temp-password-123!@#'), // Hash a temporary password\r\n+//           role: 'trainer', // Assign the 'trainer' role\r\n+//           club: { connect: { id: clubId } },\r\n+\r\n+//           name: name, // Associate the user name\r\n+//           status: 'PENDING',\r\n+//         },\r\n+//       });\r\n+\r\n+//       // 2. Now, create the Trainer record and link it to the newly created User\r\n+//       const trainer = await tx.trainer.create({\r\n+//         data: {\r\n+//           name,\r\n+//           email,\r\n+//           phone,\r\n+//           specialization,\r\n+//           club: { connect: { id: clubId } },\r\n+          \r\n+//           user: { connect: { id: user.id } } // Explicitly connect the user relation\r\n+//         },\r\n+//       });\r\n+\r\n+//        // 3. Generate password setup token and update the user record within the transaction\r\n+//       const passwordSetupToken = generatePasswordSetupToken(user.id, user.email);\r\n+//       const setupPasswordExpires = new Date(Date.now() + 24 * 60 * 60 * 1000); // 24 hours from now\r\n+\r\n+//       const updatedUser = await tx.user.update({\r\n+//         where: { id: user.id },\r\n+//         data: {\r\n+//           setupPasswordToken: passwordSetupToken,\r\n+//           setupPasswordExpires: setupPasswordExpires,\r\n+//         },\r\n+//       });\r\n+\r\n+//        createdUser = updatedUser;\r\n+//       createdTrainer = trainer;\r\n+//       return { user: updatedUser, trainer }; // Return both created records\r\n+//     });\r\n+//     // --- END: Corrected Prisma Transaction ---\r\n+\r\n+//     await sendPasswordSetupEmail(createdUser.email, createdUser.name || 'Trainer', createdUser.setupPasswordToken!); // Destructure the results from the transaction\r\n+\r\n+//     // 3. Generate a password setup token and send email\r\n+//     const passwordSetupToken = generatePasswordSetupToken(user.id, user.email);\r\n+//     await sendPasswordSetupEmail(user.email, user.name || 'Trainer', passwordSetupToken);\r\n+\r\n+//     res.status(201).json({\r\n+//       message: 'Trainer created successfully. An email has been sent to set their password.',\r\n+//       trainer: {\r\n+//         id: trainer.id,\r\n+//         name: trainer.name,\r\n+//         email: trainer.email,\r\n+//         phone: trainer.phone,\r\n+//         specialization: trainer.specialization,\r\n+//       },\r\n+//       userId: user.id // Return the user ID for reference\r\n+//     });\r\n+\r\n+//   } catch (error: any) { // Catch as 'any' for broader error handling\r\n+//     console.error('Error creating trainer and user:', error);\r\n+//     // Handle specific Prisma errors, e.g., unique constraint violation for email\r\n+//     if (error.code === 'P2002' && error.meta?.target?.includes('email')) {\r\n+//       // If trainer or user email already exists, it will throw this error\r\n+//       return res.status(409).json({ error: 'A trainer or user with this email already exists.' });\r\n+//     }\r\n+//     res.status(500).json({ error: 'Failed to create trainer and user.' });\r\n+//   }\r\n+// };\r\n+\r\n export const createTrainer = async (req: Request, res: Response) => {\r\n   const { name, email, phone, specialization, clubId } = req.body;\r\n \r\n   // Basic validation\r\n@@ -79,24 +167,21 @@\n     return res.status(400).json({ error: 'Name, email, and clubId are required.' });\r\n   }\r\n \r\n   try {\r\n-     let createdUser; // Declare user variable outside the transaction for broader scope\r\n-    let createdTrainer; \r\n-    // --- START: Corrected Prisma Transaction for linking User and Trainer ---\r\n+    let createdUser; // Declare user variable outside the transaction for broader scope\r\n+    let createdTrainer; // Declare trainer variable outside the transaction for broader scope\r\n+\r\n     const result = await prisma.$transaction(async (tx) => {\r\n       // 1. Create the User record first\r\n       const user = await tx.user.create({\r\n         data: {\r\n           email,\r\n-          // Assign a temporary dummy password. It will be overwritten by the setup link.\r\n-          // Ensure your User.password field is not nullable, or handle null passwords if it is.\r\n           password: await hashPassword('temp-password-123!@#'), // Hash a temporary password\r\n           role: 'trainer', // Assign the 'trainer' role\r\n           club: { connect: { id: clubId } },\r\n-\r\n           name: name, // Associate the user name\r\n-          status: 'PENDING',\r\n+          status: 'PENDING', // Set status to PENDING initially\r\n         },\r\n       });\r\n \r\n       // 2. Now, create the Trainer record and link it to the newly created User\r\n@@ -106,40 +191,50 @@\n           email,\r\n           phone,\r\n           specialization,\r\n           club: { connect: { id: clubId } },\r\n-          \r\n           user: { connect: { id: user.id } } // Explicitly connect the user relation\r\n         },\r\n       });\r\n \r\n-      return { user, trainer }; // Return both created records\r\n+      // 3. Generate password setup token and update the user record within the transaction\r\n+      const passwordSetupToken = generatePasswordSetupToken(user.id, user.email);\r\n+      const setupPasswordExpires = new Date(Date.now() + 24 * 60 * 60 * 1000); // 24 hours from now\r\n+\r\n+      // Update the user with the generated token and expiry\r\n+      const updatedUser = await tx.user.update({\r\n+        where: { id: user.id },\r\n+        data: {\r\n+          setupPasswordToken: passwordSetupToken,\r\n+          setupPasswordExpires: setupPasswordExpires,\r\n+        },\r\n+      });\r\n+\r\n+      // Assign to outer scope variables\r\n+      createdUser = updatedUser;\r\n+      createdTrainer = trainer;\r\n+\r\n+      return { user: updatedUser, trainer }; // Return both updated records\r\n     });\r\n-    // --- END: Corrected Prisma Transaction ---\r\n \r\n-    const { user, trainer } = result; // Destructure the results from the transaction\r\n+    // Send email with the generated token\r\n+    await sendPasswordSetupEmail(createdUser.email, createdUser.name || 'Trainer', createdUser.setupPasswordToken!); // Use the token from the updated user\r\n \r\n-    // 3. Generate a password setup token and send email\r\n-    const passwordSetupToken = generatePasswordSetupToken(user.id, user.email);\r\n-    await sendPasswordSetupEmail(user.email, user.name || 'Trainer', passwordSetupToken);\r\n-\r\n     res.status(201).json({\r\n       message: 'Trainer created successfully. An email has been sent to set their password.',\r\n       trainer: {\r\n-        id: trainer.id,\r\n-        name: trainer.name,\r\n-        email: trainer.email,\r\n-        phone: trainer.phone,\r\n-        specialization: trainer.specialization,\r\n+        id: createdTrainer.id,\r\n+        name: createdTrainer.name,\r\n+        email: createdTrainer.email,\r\n+        phone: createdTrainer.phone,\r\n+        specialization: createdTrainer.specialization,\r\n       },\r\n-      userId: user.id // Return the user ID for reference\r\n+      userId: createdUser.id // Return the user ID for reference\r\n     });\r\n \r\n-  } catch (error: any) { // Catch as 'any' for broader error handling\r\n+  } catch (error: any) {\r\n     console.error('Error creating trainer and user:', error);\r\n-    // Handle specific Prisma errors, e.g., unique constraint violation for email\r\n     if (error.code === 'P2002' && error.meta?.target?.includes('email')) {\r\n-      // If trainer or user email already exists, it will throw this error\r\n       return res.status(409).json({ error: 'A trainer or user with this email already exists.' });\r\n     }\r\n     res.status(500).json({ error: 'Failed to create trainer and user.' });\r\n   }\r\n"
                },
                {
                    "date": 1753182244430,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,241 @@\n+// src/controllers/trainer.controller.ts\r\n+import { Request, Response } from 'express';\r\n+import { PrismaClient } from '@prisma/client';\r\n+import { hashPassword, generatePasswordSetupToken } from '../utils/authUtils'; // Import auth utilities\r\n+import { sendPasswordSetupEmail } from '../services/email.service'; \r\n+\r\n+\r\n+const prisma = new PrismaClient();\r\n+\r\n+\r\n+interface AuthenticatedRequest extends Request {\r\n+  user?: {\r\n+    id: string;\r\n+    clubId?: string;\r\n+    role: string;\r\n+  };\r\n+}\r\n+\r\n+export const getTrainersByFranchise = async (req: AuthenticatedRequest, res: Response) => {\r\n+  const { franchiseId } = req.params; // This is the clubId\r\n+  const userClubId = req.user?.clubId;\r\n+  const userRole = req.user?.role;\r\n+\r\n+  // Ensure the requesting user is an admin for that club, or a super_admin\r\n+  if (!userClubId || (userRole !== 'super_admin' && userClubId !== franchiseId)) {\r\n+    return res.status(403).json({ error: 'Access denied. Not authorized for this club.' });\r\n+  }\r\n+\r\n+  try {\r\n+    const trainers = await prisma.trainer.findMany({\r\n+      where: { clubId: franchiseId },\r\n+      select: { id: true, name: true }, // Only need ID and name for dropdown\r\n+      orderBy: { name: 'asc' }\r\n+    });\r\n+    res.json(trainers);\r\n+  } catch (error) {\r\n+    console.error('Error fetching trainers:', error);\r\n+    res.status(500).json({ error: 'Failed to fetch trainers.' });\r\n+  }\r\n+};\r\n+\r\n+\r\n+// export const createTrainer = async (req: Request, res: Response) => {\r\n+//   const { name, email, phone, specialization, clubId } = req.body;\r\n+\r\n+//   // Basic validation\r\n+//   if (!name || !email || !clubId) {\r\n+//     return res.status(400).json({ error: 'Name, email, and clubId are required.' });\r\n+//   }\r\n+\r\n+//   try {\r\n+//     const newTrainer = await prisma.trainer.create({\r\n+//       data: {\r\n+//         name,\r\n+//         email,\r\n+//         phone, // Optional, so no strong validation here\r\n+//         specialization, // Optional\r\n+//         club: {\r\n+//           connect: { id: clubId }, // Connect the trainer to the specified club\r\n+//         },\r\n+//       },\r\n+//     });\r\n+//     res.status(201).json(newTrainer); // 201 Created status\r\n+//   } catch (error) {\r\n+//     console.error('Error creating trainer:', error);\r\n+//     // Handle specific Prisma errors, e.g., unique constraint violation for email\r\n+//     if (error.code === 'P2002' && error.meta?.target?.includes('email')) {\r\n+//       return res.status(409).json({ error: 'A trainer with this email already exists.' });\r\n+//     }\r\n+//     res.status(500).json({ error: 'Failed to create trainer.' });\r\n+//   }\r\n+// };\r\n+\r\n+// export const createTrainer = async (req: Request, res: Response) => {\r\n+//   const { name, email, phone, specialization, clubId } = req.body;\r\n+\r\n+//   // Basic validation\r\n+//   if (!name || !email || !clubId) {\r\n+//     return res.status(400).json({ error: 'Name, email, and clubId are required.' });\r\n+//   }\r\n+\r\n+//   try {\r\n+//      let createdUser; // Declare user variable outside the transaction for broader scope\r\n+//     let createdTrainer; \r\n+//     // --- START: Corrected Prisma Transaction for linking User and Trainer ---\r\n+//     const result = await prisma.$transaction(async (tx) => {\r\n+//       // 1. Create the User record first\r\n+//       const user = await tx.user.create({\r\n+//         data: {\r\n+//           email,\r\n+//           // Assign a temporary dummy password. It will be overwritten by the setup link.\r\n+//           // Ensure your User.password field is not nullable, or handle null passwords if it is.\r\n+//           password: await hashPassword('temp-password-123!@#'), // Hash a temporary password\r\n+//           role: 'trainer', // Assign the 'trainer' role\r\n+//           club: { connect: { id: clubId } },\r\n+\r\n+//           name: name, // Associate the user name\r\n+//           status: 'PENDING',\r\n+//         },\r\n+//       });\r\n+\r\n+//       // 2. Now, create the Trainer record and link it to the newly created User\r\n+//       const trainer = await tx.trainer.create({\r\n+//         data: {\r\n+//           name,\r\n+//           email,\r\n+//           phone,\r\n+//           specialization,\r\n+//           club: { connect: { id: clubId } },\r\n+          \r\n+//           user: { connect: { id: user.id } } // Explicitly connect the user relation\r\n+//         },\r\n+//       });\r\n+\r\n+//        // 3. Generate password setup token and update the user record within the transaction\r\n+//       const passwordSetupToken = generatePasswordSetupToken(user.id, user.email);\r\n+//       const setupPasswordExpires = new Date(Date.now() + 24 * 60 * 60 * 1000); // 24 hours from now\r\n+\r\n+//       const updatedUser = await tx.user.update({\r\n+//         where: { id: user.id },\r\n+//         data: {\r\n+//           setupPasswordToken: passwordSetupToken,\r\n+//           setupPasswordExpires: setupPasswordExpires,\r\n+//         },\r\n+//       });\r\n+\r\n+//        createdUser = updatedUser;\r\n+//       createdTrainer = trainer;\r\n+//       return { user: updatedUser, trainer }; // Return both created records\r\n+//     });\r\n+//     // --- END: Corrected Prisma Transaction ---\r\n+\r\n+//     await sendPasswordSetupEmail(createdUser.email, createdUser.name || 'Trainer', createdUser.setupPasswordToken!); // Destructure the results from the transaction\r\n+\r\n+//     // 3. Generate a password setup token and send email\r\n+//     const passwordSetupToken = generatePasswordSetupToken(user.id, user.email);\r\n+//     await sendPasswordSetupEmail(user.email, user.name || 'Trainer', passwordSetupToken);\r\n+\r\n+//     res.status(201).json({\r\n+//       message: 'Trainer created successfully. An email has been sent to set their password.',\r\n+//       trainer: {\r\n+//         id: trainer.id,\r\n+//         name: trainer.name,\r\n+//         email: trainer.email,\r\n+//         phone: trainer.phone,\r\n+//         specialization: trainer.specialization,\r\n+//       },\r\n+//       userId: user.id // Return the user ID for reference\r\n+//     });\r\n+\r\n+//   } catch (error: any) { // Catch as 'any' for broader error handling\r\n+//     console.error('Error creating trainer and user:', error);\r\n+//     // Handle specific Prisma errors, e.g., unique constraint violation for email\r\n+//     if (error.code === 'P2002' && error.meta?.target?.includes('email')) {\r\n+//       // If trainer or user email already exists, it will throw this error\r\n+//       return res.status(409).json({ error: 'A trainer or user with this email already exists.' });\r\n+//     }\r\n+//     res.status(500).json({ error: 'Failed to create trainer and user.' });\r\n+//   }\r\n+// };\r\n+\r\n+export const createTrainer = async (req: Request, res: Response) => {\r\n+  const { name, email, phone, specialization, clubId } = req.body;\r\n+\r\n+  // Basic validation\r\n+  if (!name || !email || !clubId) {\r\n+    return res.status(400).json({ error: 'Name, email, and clubId are required.' });\r\n+  }\r\n+\r\n+  try {\r\n+    let createdUser; // Declare user variable outside the transaction for broader scope\r\n+    let createdTrainer; // Declare trainer variable outside the transaction for broader scope\r\n+\r\n+    const result = await prisma.$transaction(async (tx) => {\r\n+      // 1. Create the User record first\r\n+      const user = await tx.user.create({\r\n+        data: {\r\n+          email,\r\n+          password: await hashPassword('temp-password-123!@#'), // Hash a temporary password\r\n+          role: 'trainer', // Assign the 'trainer' role\r\n+          club: { connect: { id: clubId } },\r\n+          name: name, // Associate the user name\r\n+          status: 'PENDING', // Set status to PENDING initially\r\n+        },\r\n+      });\r\n+\r\n+      // 2. Now, create the Trainer record and link it to the newly created User\r\n+      const trainer = await tx.trainer.create({\r\n+        data: {\r\n+          name,\r\n+          email,\r\n+          phone,\r\n+          specialization,\r\n+          club: { connect: { id: clubId } },\r\n+          user: { connect: { id: user.id } } // Explicitly connect the user relation\r\n+        },\r\n+      });\r\n+\r\n+      // 3. Generate password setup token and update the user record within the transaction\r\n+      const passwordSetupToken = generatePasswordSetupToken(user.id, user.email);\r\n+      const setupPasswordExpires = new Date(Date.now() + 24 * 60 * 60 * 1000); // 24 hours from now\r\n+\r\n+      // Update the user with the generated token and expiry\r\n+      const updatedUser = await tx.user.update({\r\n+        where: { id: user.id },\r\n+        data: {\r\n+          setupPasswordToken: passwordSetupToken,\r\n+          setupPasswordExpires: setupPasswordExpires,\r\n+        },\r\n+      });\r\n+\r\n+      // Assign to outer scope variables\r\n+      createdUser = updatedUser;\r\n+      createdTrainer = trainer;\r\n+\r\n+      return { user: updatedUser, trainer }; // Return both updated records\r\n+    });\r\n+\r\n+    // Send email with the generated token\r\n+    await sendPasswordSetupEmail(createdUser.email, createdUser.name || 'Trainer', createdUser.setupPasswordToken!); // Use the token from the updated user\r\n+\r\n+    res.status(201).json({\r\n+      message: 'Trainer created successfully. An email has been sent to set their password.',\r\n+      trainer: {\r\n+        id: createdTrainer.id,\r\n+        name: createdTrainer.name,\r\n+        email: createdTrainer.email,\r\n+        phone: createdTrainer.phone,\r\n+        specialization: createdTrainer.specialization,\r\n+      },\r\n+      userId: createdUser.id // Return the user ID for reference\r\n+    });\r\n+\r\n+  } catch (error: any) {\r\n+    console.error('Error creating trainer and user:', error);\r\n+    if (error.code === 'P2002' && error.meta?.target?.includes('email')) {\r\n+      return res.status(409).json({ error: 'A trainer or user with this email already exists.' });\r\n+    }\r\n+    res.status(500).json({ error: 'Failed to create trainer and user.' });\r\n+  }\r\n+};\n\\ No newline at end of file\n"
                },
                {
                    "date": 1753182386393,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -70,96 +70,8 @@\n //     res.status(500).json({ error: 'Failed to create trainer.' });\r\n //   }\r\n // };\r\n \r\n-// export const createTrainer = async (req: Request, res: Response) => {\r\n-//   const { name, email, phone, specialization, clubId } = req.body;\r\n-\r\n-//   // Basic validation\r\n-//   if (!name || !email || !clubId) {\r\n-//     return res.status(400).json({ error: 'Name, email, and clubId are required.' });\r\n-//   }\r\n-\r\n-//   try {\r\n-//      let createdUser; // Declare user variable outside the transaction for broader scope\r\n-//     let createdTrainer; \r\n-//     // --- START: Corrected Prisma Transaction for linking User and Trainer ---\r\n-//     const result = await prisma.$transaction(async (tx) => {\r\n-//       // 1. Create the User record first\r\n-//       const user = await tx.user.create({\r\n-//         data: {\r\n-//           email,\r\n-//           // Assign a temporary dummy password. It will be overwritten by the setup link.\r\n-//           // Ensure your User.password field is not nullable, or handle null passwords if it is.\r\n-//           password: await hashPassword('temp-password-123!@#'), // Hash a temporary password\r\n-//           role: 'trainer', // Assign the 'trainer' role\r\n-//           club: { connect: { id: clubId } },\r\n-\r\n-//           name: name, // Associate the user name\r\n-//           status: 'PENDING',\r\n-//         },\r\n-//       });\r\n-\r\n-//       // 2. Now, create the Trainer record and link it to the newly created User\r\n-//       const trainer = await tx.trainer.create({\r\n-//         data: {\r\n-//           name,\r\n-//           email,\r\n-//           phone,\r\n-//           specialization,\r\n-//           club: { connect: { id: clubId } },\r\n-          \r\n-//           user: { connect: { id: user.id } } // Explicitly connect the user relation\r\n-//         },\r\n-//       });\r\n-\r\n-//        // 3. Generate password setup token and update the user record within the transaction\r\n-//       const passwordSetupToken = generatePasswordSetupToken(user.id, user.email);\r\n-//       const setupPasswordExpires = new Date(Date.now() + 24 * 60 * 60 * 1000); // 24 hours from now\r\n-\r\n-//       const updatedUser = await tx.user.update({\r\n-//         where: { id: user.id },\r\n-//         data: {\r\n-//           setupPasswordToken: passwordSetupToken,\r\n-//           setupPasswordExpires: setupPasswordExpires,\r\n-//         },\r\n-//       });\r\n-\r\n-//        createdUser = updatedUser;\r\n-//       createdTrainer = trainer;\r\n-//       return { user: updatedUser, trainer }; // Return both created records\r\n-//     });\r\n-//     // --- END: Corrected Prisma Transaction ---\r\n-\r\n-//     await sendPasswordSetupEmail(createdUser.email, createdUser.name || 'Trainer', createdUser.setupPasswordToken!); // Destructure the results from the transaction\r\n-\r\n-//     // 3. Generate a password setup token and send email\r\n-//     const passwordSetupToken = generatePasswordSetupToken(user.id, user.email);\r\n-//     await sendPasswordSetupEmail(user.email, user.name || 'Trainer', passwordSetupToken);\r\n-\r\n-//     res.status(201).json({\r\n-//       message: 'Trainer created successfully. An email has been sent to set their password.',\r\n-//       trainer: {\r\n-//         id: trainer.id,\r\n-//         name: trainer.name,\r\n-//         email: trainer.email,\r\n-//         phone: trainer.phone,\r\n-//         specialization: trainer.specialization,\r\n-//       },\r\n-//       userId: user.id // Return the user ID for reference\r\n-//     });\r\n-\r\n-//   } catch (error: any) { // Catch as 'any' for broader error handling\r\n-//     console.error('Error creating trainer and user:', error);\r\n-//     // Handle specific Prisma errors, e.g., unique constraint violation for email\r\n-//     if (error.code === 'P2002' && error.meta?.target?.includes('email')) {\r\n-//       // If trainer or user email already exists, it will throw this error\r\n-//       return res.status(409).json({ error: 'A trainer or user with this email already exists.' });\r\n-//     }\r\n-//     res.status(500).json({ error: 'Failed to create trainer and user.' });\r\n-//   }\r\n-// };\r\n-\r\n export const createTrainer = async (req: Request, res: Response) => {\r\n   const { name, email, phone, specialization, clubId } = req.body;\r\n \r\n   // Basic validation\r\n@@ -167,21 +79,20 @@\n     return res.status(400).json({ error: 'Name, email, and clubId are required.' });\r\n   }\r\n \r\n   try {\r\n-    let createdUser; // Declare user variable outside the transaction for broader scope\r\n-    let createdTrainer; // Declare trainer variable outside the transaction for broader scope\r\n-\r\n+    // --- START: Corrected Prisma Transaction for linking User and Trainer ---\r\n     const result = await prisma.$transaction(async (tx) => {\r\n       // 1. Create the User record first\r\n       const user = await tx.user.create({\r\n         data: {\r\n           email,\r\n+          // Assign a temporary dummy password. It will be overwritten by the setup link.\r\n+          // Ensure your User.password field is not nullable, or handle null passwords if it is.\r\n           password: await hashPassword('temp-password-123!@#'), // Hash a temporary password\r\n           role: 'trainer', // Assign the 'trainer' role\r\n           club: { connect: { id: clubId } },\r\n           name: name, // Associate the user name\r\n-          status: 'PENDING', // Set status to PENDING initially\r\n         },\r\n       });\r\n \r\n       // 2. Now, create the Trainer record and link it to the newly created User\r\n@@ -191,50 +102,40 @@\n           email,\r\n           phone,\r\n           specialization,\r\n           club: { connect: { id: clubId } },\r\n+          \r\n           user: { connect: { id: user.id } } // Explicitly connect the user relation\r\n         },\r\n       });\r\n \r\n-      // 3. Generate password setup token and update the user record within the transaction\r\n-      const passwordSetupToken = generatePasswordSetupToken(user.id, user.email);\r\n-      const setupPasswordExpires = new Date(Date.now() + 24 * 60 * 60 * 1000); // 24 hours from now\r\n+      return { user, trainer }; // Return both created records\r\n+    });\r\n+    // --- END: Corrected Prisma Transaction ---\r\n \r\n-      // Update the user with the generated token and expiry\r\n-      const updatedUser = await tx.user.update({\r\n-        where: { id: user.id },\r\n-        data: {\r\n-          setupPasswordToken: passwordSetupToken,\r\n-          setupPasswordExpires: setupPasswordExpires,\r\n-        },\r\n-      });\r\n+    const { user, trainer } = result; // Destructure the results from the transaction\r\n \r\n-      // Assign to outer scope variables\r\n-      createdUser = updatedUser;\r\n-      createdTrainer = trainer;\r\n+    // 3. Generate a password setup token and send email\r\n+    const passwordSetupToken = generatePasswordSetupToken(user.id, user.email);\r\n+    await sendPasswordSetupEmail(user.email, user.name || 'Trainer', passwordSetupToken);\r\n \r\n-      return { user: updatedUser, trainer }; // Return both updated records\r\n-    });\r\n-\r\n-    // Send email with the generated token\r\n-    await sendPasswordSetupEmail(createdUser.email, createdUser.name || 'Trainer', createdUser.setupPasswordToken!); // Use the token from the updated user\r\n-\r\n     res.status(201).json({\r\n       message: 'Trainer created successfully. An email has been sent to set their password.',\r\n       trainer: {\r\n-        id: createdTrainer.id,\r\n-        name: createdTrainer.name,\r\n-        email: createdTrainer.email,\r\n-        phone: createdTrainer.phone,\r\n-        specialization: createdTrainer.specialization,\r\n+        id: trainer.id,\r\n+        name: trainer.name,\r\n+        email: trainer.email,\r\n+        phone: trainer.phone,\r\n+        specialization: trainer.specialization,\r\n       },\r\n-      userId: createdUser.id // Return the user ID for reference\r\n+      userId: user.id // Return the user ID for reference\r\n     });\r\n \r\n-  } catch (error: any) {\r\n+  } catch (error: any) { // Catch as 'any' for broader error handling\r\n     console.error('Error creating trainer and user:', error);\r\n+    // Handle specific Prisma errors, e.g., unique constraint violation for email\r\n     if (error.code === 'P2002' && error.meta?.target?.includes('email')) {\r\n+      // If trainer or user email already exists, it will throw this error\r\n       return res.status(409).json({ error: 'A trainer or user with this email already exists.' });\r\n     }\r\n     res.status(500).json({ error: 'Failed to create trainer and user.' });\r\n   }\r\n"
                }
            ],
            "date": 1752451240563,
            "name": "Commit-0",
            "content": "export const getTrainersByFranchise = async (req: Request, res: Response) => {\r\n  const { franchiseId } = req.params;\r\n\r\n  try {\r\n    const trainers = await prisma.user.findMany({\r\n      where: {\r\n        role: 'trainer',\r\n        franchiseId,\r\n      },\r\n      select: { id: true, firstName: true, lastName: true },\r\n    });\r\n\r\n    res.json(trainers);\r\n  } catch (error) {\r\n    res.status(500).json({ error: 'Error fetching trainers' });\r\n  }\r\n};\r\n"
        }
    ]
}