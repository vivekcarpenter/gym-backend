{
    "sourceFile": "src/controllers/auth.controller.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 8,
            "patches": [
                {
                    "date": 1752123806367,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1752733335811,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,8 +1,9 @@\n import { Request, Response } from 'express';\r\n import jwt from 'jsonwebtoken';\r\n import bcrypt from 'bcryptjs';\r\n import prisma from '../lib/prisma';\r\n+import { verifyPasswordSetupToken, hashPassword } from '../utils/authUtils';\r\n \r\n export const loginController = async (req: Request, res: Response) => {\r\n   const { email, password } = req.body;\r\n \r\n@@ -39,4 +40,50 @@\n     console.error(err);\r\n     res.status(500).json({ error: 'Internal server error' });\r\n   }\r\n };\r\n+\r\n+export const setupPassword = async (req: Request, res: Response) => {\r\n+  const { token, newPassword } = req.body;\r\n+\r\n+  if (!token || !newPassword) {\r\n+    return res.status(400).json({ error: 'Token and new password are required.' });\r\n+  }\r\n+\r\n+  try {\r\n+    // 1. Verify the token\r\n+    const decodedToken = verifyPasswordSetupToken(token);\r\n+\r\n+    if (!decodedToken) {\r\n+      return res.status(401).json({ error: 'Invalid or expired password setup token.' });\r\n+    }\r\n+\r\n+    // 2. Find the user\r\n+    const user = await prisma.user.findUnique({\r\n+      where: { id: decodedToken.userId },\r\n+    });\r\n+\r\n+    if (!user) {\r\n+      return res.status(404).json({ error: 'User not found.' });\r\n+    }\r\n+\r\n+    // Ensure the email in the token matches the user's email\r\n+    if (user.email !== decodedToken.email) {\r\n+        return res.status(403).json({ error: 'Token mismatch.' });\r\n+    }\r\n+\r\n+    // 3. Hash the new password\r\n+    const hashedPassword = await hashPassword(newPassword);\r\n+\r\n+    // 4. Update the user's password\r\n+    await prisma.user.update({\r\n+      where: { id: user.id },\r\n+      data: { password: hashedPassword },\r\n+    });\r\n+\r\n+    res.status(200).json({ message: 'Password set successfully. You can now log in.' });\r\n+\r\n+  } catch (error) {\r\n+    console.error('Error setting up password:', error);\r\n+    res.status(500).json({ error: 'Failed to set password.' });\r\n+  }\r\n+};\r\n"
                },
                {
                    "date": 1752750136177,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -9,32 +9,45 @@\n \r\n   try {\r\n     const user = await prisma.user.findUnique({\r\n       where: { email },\r\n+       include: {\r\n+        trainerProfile: true,\r\n+        memberProfile: true,\r\n+  }\r\n     });\r\n \r\n     if (!user) return res.status(401).json({ error: 'Invalid credentials' });\r\n \r\n     const valid = await bcrypt.compare(password, user.password);\r\n     if (!valid) return res.status(401).json({ error: 'Invalid credentials' });\r\n \r\n+    const tokenPayload: Record<string, any> = {\r\n+      id: user.id,\r\n+      email: user.email, // Include email in token for convenience\r\n+      role: user.role,\r\n+      clubId: user.clubId,\r\n+    };\r\n+\r\n+    // Conditionally add profile-specific IDs and permissions\r\n+    if (user.role === 'trainer' && user.trainerProfile) {\r\n+      tokenPayload.profileType = 'trainer'; // Indicate which profile type this ID belongs to\r\n+      tokenPayload.profileId = user.trainerProfile.id;\r\n+      tokenPayload.canCreateClasses = user.trainerProfile.canCreateClasses;\r\n+    } else if (user.role === 'member' && user.memberProfile) {\r\n+      tokenPayload.profileType = 'member'; // Indicate which profile type this ID belongs to\r\n+      tokenPayload.profileId = user.memberProfile.id;\r\n+    }\r\n+\r\n+\r\n     const token = jwt.sign(\r\n-      {\r\n-        id: user.id,\r\n-        role: user.role,\r\n-        clubId: user.clubId,\r\n-      },\r\n+      tokenPayload,\r\n       process.env.JWT_SECRET!,\r\n       { expiresIn: '7d' }\r\n     );\r\n \r\n     res.json({\r\n-      user: {\r\n-        id: user.id,\r\n-        email: user.email,\r\n-        role: user.role,\r\n-        clubId: user.clubId,\r\n-      },\r\n+      user: tokenPayload, // Send the same enriched payload back to the frontend\r\n       token,\r\n     });\r\n   } catch (err) {\r\n     console.error(err);\r\n"
                },
                {
                    "date": 1752751729418,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -32,9 +32,10 @@\n     if (user.role === 'trainer' && user.trainerProfile) {\r\n       tokenPayload.profileType = 'trainer'; // Indicate which profile type this ID belongs to\r\n       tokenPayload.profileId = user.trainerProfile.id;\r\n       tokenPayload.canCreateClasses = user.trainerProfile.canCreateClasses;\r\n-    } else if (user.role === 'member' && user.memberProfile) {\r\n+    } \r\n+    else if (user.role === 'member' && user.memberProfile) {\r\n       tokenPayload.profileType = 'member'; // Indicate which profile type this ID belongs to\r\n       tokenPayload.profileId = user.memberProfile.id;\r\n     }\r\n \r\n"
                },
                {
                    "date": 1752752262002,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,103 @@\n+import { Request, Response } from 'express';\r\n+import jwt from 'jsonwebtoken';\r\n+import bcrypt from 'bcryptjs';\r\n+import prisma from '../lib/prisma';\r\n+import { verifyPasswordSetupToken, hashPassword } from '../utils/authUtils';\r\n+\r\n+export const loginController = async (req: Request, res: Response) => {\r\n+  const { email, password } = req.body;\r\n+\r\n+  try {\r\n+    const user = await prisma.user.findUnique({\r\n+      where: { email },\r\n+       include: {\r\n+        trainerProfile: true,\r\n+        memberProfile: true,\r\n+  }\r\n+    });\r\n+\r\n+    if (!user) return res.status(401).json({ error: 'Invalid credentials' });\r\n+\r\n+    const valid = await bcrypt.compare(password, user.password);\r\n+    if (!valid) return res.status(401).json({ error: 'Invalid credentials' });\r\n+\r\n+    const tokenPayload: Record<string, any> = {\r\n+      id: user.id,\r\n+      email: user.email, // Include email in token for convenience\r\n+      role: user.role,\r\n+      clubId: user.clubId,\r\n+    };\r\n+\r\n+    // Conditionally add profile-specific IDs and permissions\r\n+    if (user.role === 'trainer' && user.trainerProfile) {\r\n+      tokenPayload.profileType = 'trainer'; // Indicate which profile type this ID belongs to\r\n+      tokenPayload.profileId = user.trainerProfile.id;\r\n+      tokenPayload.canCreateClasses = user.trainerProfile.canCreateClasses;\r\n+    } \r\n+    else if (user.role === 'member' && user.memberProfile) {\r\n+      tokenPayload.profileType = 'member'; // Indicate which profile type this ID belongs to\r\n+      tokenPayload.profileId = user.memberProfile.id;\r\n+    }\r\n+\r\n+\r\n+    const token = jwt.sign(\r\n+      tokenPayload,\r\n+      process.env.JWT_SECRET!,\r\n+      { expiresIn: '7d' }\r\n+    );\r\n+\r\n+    res.json({\r\n+      user: tokenPayload, // Send the same enriched payload back to the frontend\r\n+      token,\r\n+    });\r\n+  } catch (err) {\r\n+    console.error(err);\r\n+    res.status(500).json({ error: 'Internal server error' });\r\n+  }\r\n+};\r\n+\r\n+export const setupPassword = async (req: Request, res: Response) => {\r\n+  const { token, newPassword } = req.body;\r\n+\r\n+  if (!token || !newPassword) {\r\n+    return res.status(400).json({ error: 'Token and new password are required.' });\r\n+  }\r\n+\r\n+  try {\r\n+    // 1. Verify the token\r\n+    const decodedToken = verifyPasswordSetupToken(token);\r\n+\r\n+    if (!decodedToken) {\r\n+      return res.status(401).json({ error: 'Invalid or expired password setup token.' });\r\n+    }\r\n+\r\n+    // 2. Find the user\r\n+    const user = await prisma.user.findUnique({\r\n+      where: { id: decodedToken.userId },\r\n+    });\r\n+\r\n+    if (!user) {\r\n+      return res.status(404).json({ error: 'User not found.' });\r\n+    }\r\n+\r\n+    // Ensure the email in the token matches the user's email\r\n+    if (user.email !== decodedToken.email) {\r\n+        return res.status(403).json({ error: 'Token mismatch.' });\r\n+    }\r\n+\r\n+    // 3. Hash the new password\r\n+    const hashedPassword = await hashPassword(newPassword);\r\n+\r\n+    // 4. Update the user's password\r\n+    await prisma.user.update({\r\n+      where: { id: user.id },\r\n+      data: { password: hashedPassword },\r\n+    });\r\n+\r\n+    res.status(200).json({ message: 'Password set successfully. You can now log in.' });\r\n+\r\n+  } catch (error) {\r\n+    console.error('Error setting up password:', error);\r\n+    res.status(500).json({ error: 'Failed to set password.' });\r\n+  }\r\n+};\r\n"
                },
                {
                    "date": 1752809643086,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -17,8 +17,15 @@\n     });\r\n \r\n     if (!user) return res.status(401).json({ error: 'Invalid credentials' });\r\n \r\n+    console.log('Login Controller Debug: User found:', user.email, 'with role:', user.role);\r\n+    console.log('Login Controller Debug: Has trainerProfile:', !!user.trainerProfile);\r\n+    if (user.trainerProfile) {\r\n+        console.log('Login Controller Debug: trainerProfile ID:', user.trainerProfile.id);\r\n+    }\r\n+    // --- END \r\n+\r\n     const valid = await bcrypt.compare(password, user.password);\r\n     if (!valid) return res.status(401).json({ error: 'Invalid credentials' });\r\n \r\n     const tokenPayload: Record<string, any> = {\r\n@@ -38,8 +45,9 @@\n       tokenPayload.profileType = 'member'; // Indicate which profile type this ID belongs to\r\n       tokenPayload.profileId = user.memberProfile.id;\r\n     }\r\n \r\n+    console.log('Login Controller Debug: Final tokenPayload before signing:', tokenPayload);\r\n \r\n     const token = jwt.sign(\r\n       tokenPayload,\r\n       process.env.JWT_SECRET!,\r\n@@ -51,8 +59,9 @@\n       token,\r\n     });\r\n   } catch (err) {\r\n     console.error(err);\r\n+    console.error('Login Controller Error:', err); \r\n     res.status(500).json({ error: 'Internal server error' });\r\n   }\r\n };\r\n \r\n"
                },
                {
                    "date": 1752904359415,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,4 +1,5 @@\n+// src/controllers/auth.controller.ts\r\n import { Request, Response } from 'express';\r\n import jwt from 'jsonwebtoken';\r\n import bcrypt from 'bcryptjs';\r\n import prisma from '../lib/prisma';\r\n@@ -22,28 +23,27 @@\n     console.log('Login Controller Debug: Has trainerProfile:', !!user.trainerProfile);\r\n     if (user.trainerProfile) {\r\n         console.log('Login Controller Debug: trainerProfile ID:', user.trainerProfile.id);\r\n     }\r\n-    // --- END \r\n \r\n     const valid = await bcrypt.compare(password, user.password);\r\n     if (!valid) return res.status(401).json({ error: 'Invalid credentials' });\r\n \r\n     const tokenPayload: Record<string, any> = {\r\n       id: user.id,\r\n-      email: user.email, // Include email in token for convenience\r\n+      email: user.email,\r\n       role: user.role,\r\n       clubId: user.clubId,\r\n     };\r\n \r\n     // Conditionally add profile-specific IDs and permissions\r\n     if (user.role === 'trainer' && user.trainerProfile) {\r\n-      tokenPayload.profileType = 'trainer'; // Indicate which profile type this ID belongs to\r\n+      tokenPayload.profileType = 'trainer';\r\n       tokenPayload.profileId = user.trainerProfile.id;\r\n       tokenPayload.canCreateClasses = user.trainerProfile.canCreateClasses;\r\n     } \r\n     else if (user.role === 'member' && user.memberProfile) {\r\n-      tokenPayload.profileType = 'member'; // Indicate which profile type this ID belongs to\r\n+      tokenPayload.profileType = 'member';\r\n       tokenPayload.profileId = user.memberProfile.id;\r\n     }\r\n \r\n     console.log('Login Controller Debug: Final tokenPayload before signing:', tokenPayload);\r\n@@ -54,59 +54,89 @@\n       { expiresIn: '7d' }\r\n     );\r\n \r\n     res.json({\r\n-      user: tokenPayload, // Send the same enriched payload back to the frontend\r\n+      user: tokenPayload,\r\n       token,\r\n     });\r\n   } catch (err) {\r\n-    console.error(err);\r\n     console.error('Login Controller Error:', err); \r\n     res.status(500).json({ error: 'Internal server error' });\r\n   }\r\n };\r\n \r\n export const setupPassword = async (req: Request, res: Response) => {\r\n   const { token, newPassword } = req.body;\r\n \r\n+  // Add debug logging\r\n+  console.log('Setup Password Debug: Received request');\r\n+  console.log('Setup Password Debug: Token present:', !!token);\r\n+  console.log('Setup Password Debug: New password present:', !!newPassword);\r\n+\r\n   if (!token || !newPassword) {\r\n     return res.status(400).json({ error: 'Token and new password are required.' });\r\n   }\r\n \r\n   try {\r\n     // 1. Verify the token\r\n+    console.log('Setup Password Debug: Attempting to verify token...');\r\n     const decodedToken = verifyPasswordSetupToken(token);\r\n \r\n+    console.log('Setup Password Debug: Token verification result:', decodedToken);\r\n+\r\n     if (!decodedToken) {\r\n       return res.status(401).json({ error: 'Invalid or expired password setup token.' });\r\n     }\r\n \r\n+    // Add validation for userId\r\n+    if (!decodedToken.userId) {\r\n+      console.error('Setup Password Error: Token does not contain userId');\r\n+      return res.status(401).json({ error: 'Invalid token: missing user ID.' });\r\n+    }\r\n+\r\n+    console.log('Setup Password Debug: Looking for user with ID:', decodedToken.userId);\r\n+\r\n     // 2. Find the user\r\n     const user = await prisma.user.findUnique({\r\n       where: { id: decodedToken.userId },\r\n     });\r\n \r\n+    console.log('Setup Password Debug: User found:', !!user);\r\n+\r\n     if (!user) {\r\n       return res.status(404).json({ error: 'User not found.' });\r\n     }\r\n \r\n     // Ensure the email in the token matches the user's email\r\n     if (user.email !== decodedToken.email) {\r\n+        console.error('Setup Password Error: Email mismatch. Token email:', decodedToken.email, 'User email:', user.email);\r\n         return res.status(403).json({ error: 'Token mismatch.' });\r\n     }\r\n \r\n+    // Check if user is still in PENDING status (optional but good practice)\r\n+    if (user.status !== 'PENDING') {\r\n+        console.log('Setup Password Warning: User status is not PENDING, current status:', user.status);\r\n+    }\r\n+\r\n     // 3. Hash the new password\r\n     const hashedPassword = await hashPassword(newPassword);\r\n \r\n-    // 4. Update the user's password\r\n+    // 4. Update the user's password and status\r\n     await prisma.user.update({\r\n       where: { id: user.id },\r\n-      data: { password: hashedPassword },\r\n+      data: { \r\n+        password: hashedPassword,\r\n+        status: 'ACTIVE', // Set status to ACTIVE after password is set\r\n+        setupPasswordToken: null, // Clear the setup token\r\n+        setupPasswordExpires: null, // Clear the expiry\r\n+      },\r\n     });\r\n \r\n+    console.log('Setup Password Success: Password updated for user:', user.email);\r\n+\r\n     res.status(200).json({ message: 'Password set successfully. You can now log in.' });\r\n \r\n   } catch (error) {\r\n-    console.error('Error setting up password:', error);\r\n+    console.error('Setup Password Error:', error);\r\n     res.status(500).json({ error: 'Failed to set password.' });\r\n   }\r\n-};\r\n+};\n\\ No newline at end of file\n"
                },
                {
                    "date": 1752904770441,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -69,17 +69,31 @@\n \r\n   // Add debug logging\r\n   console.log('Setup Password Debug: Received request');\r\n   console.log('Setup Password Debug: Token present:', !!token);\r\n+  console.log('Setup Password Debug: Token length:', token?.length);\r\n   console.log('Setup Password Debug: New password present:', !!newPassword);\r\n \r\n   if (!token || !newPassword) {\r\n     return res.status(400).json({ error: 'Token and new password are required.' });\r\n   }\r\n \r\n   try {\r\n+    // First, let's see if we can find a user by this exact token in the database\r\n+    console.log('Setup Password Debug: Searching for user with this setup token...');\r\n+    const userWithToken = await prisma.user.findFirst({\r\n+      where: { setupPasswordToken: token }\r\n+    });\r\n+    \r\n+    if (userWithToken) {\r\n+      console.log('Setup Password Debug: Found user with matching token:', userWithToken.id);\r\n+      console.log('Setup Password Debug: Token expiry:', userWithToken.setupPasswordExpires);\r\n+    } else {\r\n+      console.log('Setup Password Debug: No user found with this exact token in database');\r\n+    }\r\n+\r\n     // 1. Verify the token\r\n-    console.log('Setup Password Debug: Attempting to verify token...');\r\n+    console.log('Setup Password Debug: Attempting to verify JWT token...');\r\n     const decodedToken = verifyPasswordSetupToken(token);\r\n \r\n     console.log('Setup Password Debug: Token verification result:', decodedToken);\r\n \r\n@@ -99,9 +113,9 @@\n     const user = await prisma.user.findUnique({\r\n       where: { id: decodedToken.userId },\r\n     });\r\n \r\n-    console.log('Setup Password Debug: User found:', !!user);\r\n+    console.log('Setup Password Debug: User found by ID:', !!user);\r\n \r\n     if (!user) {\r\n       return res.status(404).json({ error: 'User not found.' });\r\n     }\r\n@@ -111,8 +125,20 @@\n         console.error('Setup Password Error: Email mismatch. Token email:', decodedToken.email, 'User email:', user.email);\r\n         return res.status(403).json({ error: 'Token mismatch.' });\r\n     }\r\n \r\n+    // Check if the token in the database matches (additional security)\r\n+    if (user.setupPasswordToken !== token) {\r\n+        console.error('Setup Password Error: Database token mismatch');\r\n+        return res.status(401).json({ error: 'Invalid token.' });\r\n+    }\r\n+\r\n+    // Check if token has expired\r\n+    if (user.setupPasswordExpires && user.setupPasswordExpires < new Date()) {\r\n+        console.error('Setup Password Error: Token has expired');\r\n+        return res.status(401).json({ error: 'Token has expired.' });\r\n+    }\r\n+\r\n     // Check if user is still in PENDING status (optional but good practice)\r\n     if (user.status !== 'PENDING') {\r\n         console.log('Setup Password Warning: User status is not PENDING, current status:', user.status);\r\n     }\r\n"
                },
                {
                    "date": 1753166590723,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -35,18 +35,37 @@\n       clubId: user.clubId,\r\n     };\r\n \r\n     // Conditionally add profile-specific IDs and permissions\r\n-    if (user.role === 'trainer' && user.trainerProfile) {\r\n-      tokenPayload.profileType = 'trainer';\r\n-      tokenPayload.profileId = user.trainerProfile.id;\r\n-      tokenPayload.canCreateClasses = user.trainerProfile.canCreateClasses;\r\n-    } \r\n-    else if (user.role === 'member' && user.memberProfile) {\r\n-      tokenPayload.profileType = 'member';\r\n-      tokenPayload.profileId = user.memberProfile.id;\r\n-    }\r\n+    // if (user.role === 'trainer' && user.trainerProfile) {\r\n+    //   tokenPayload.profileType = 'trainer';\r\n+    //   tokenPayload.profileId = user.trainerProfile.id;\r\n+    //   tokenPayload.canCreateClasses = user.trainerProfile.canCreateClasses;\r\n+    // } \r\n+    // else if (user.role === 'member' && user.memberProfile) {\r\n+    //   tokenPayload.profileType = 'member';\r\n+    //   tokenPayload.profileId = user.memberProfile.id;\r\n+    // }\r\n \r\n+\r\n+    // Block login ONLY if trainer/member profile is missing\r\n+if (\r\n+  (user.role === 'trainer' && !user.trainerProfile) ||\r\n+  (user.role === 'member' && !user.memberProfile)\r\n+) {\r\n+  return res.status(403).json({ error: 'Profile not configured for this role yet.' });\r\n+}\r\n+\r\n+// Add optional profile data to tokenPayload\r\n+if (user.role === 'trainer') {\r\n+  tokenPayload.profileType = 'trainer';\r\n+  tokenPayload.profileId = user.trainerProfile?.id || null;\r\n+  tokenPayload.canCreateClasses = user.trainerProfile?.canCreateClasses || false;\r\n+} else if (user.role === 'member') {\r\n+  tokenPayload.profileType = 'member';\r\n+  tokenPayload.profileId = user.memberProfile?.id || null;\r\n+}\r\n+\r\n     console.log('Login Controller Debug: Final tokenPayload before signing:', tokenPayload);\r\n \r\n     const token = jwt.sign(\r\n       tokenPayload,\r\n@@ -164,108 +183,5 @@\n   } catch (error) {\r\n     console.error('Setup Password Error:', error);\r\n     res.status(500).json({ error: 'Failed to set password.' });\r\n   }\r\n-};\n-import { Request, Response } from 'express';\r\n-import jwt from 'jsonwebtoken';\r\n-import bcrypt from 'bcryptjs';\r\n-import prisma from '../lib/prisma';\r\n-import { verifyPasswordSetupToken, hashPassword } from '../utils/authUtils';\r\n-\r\n-export const loginController = async (req: Request, res: Response) => {\r\n-  const { email, password } = req.body;\r\n-\r\n-  try {\r\n-    const user = await prisma.user.findUnique({\r\n-      where: { email },\r\n-       include: {\r\n-        trainerProfile: true,\r\n-        memberProfile: true,\r\n-  }\r\n-    });\r\n-\r\n-    if (!user) return res.status(401).json({ error: 'Invalid credentials' });\r\n-\r\n-    const valid = await bcrypt.compare(password, user.password);\r\n-    if (!valid) return res.status(401).json({ error: 'Invalid credentials' });\r\n-\r\n-    const tokenPayload: Record<string, any> = {\r\n-      id: user.id,\r\n-      email: user.email, // Include email in token for convenience\r\n-      role: user.role,\r\n-      clubId: user.clubId,\r\n-    };\r\n-\r\n-    // Conditionally add profile-specific IDs and permissions\r\n-    if (user.role === 'trainer' && user.trainerProfile) {\r\n-      tokenPayload.profileType = 'trainer'; // Indicate which profile type this ID belongs to\r\n-      tokenPayload.profileId = user.trainerProfile.id;\r\n-      tokenPayload.canCreateClasses = user.trainerProfile.canCreateClasses;\r\n-    } \r\n-    else if (user.role === 'member' && user.memberProfile) {\r\n-      tokenPayload.profileType = 'member'; // Indicate which profile type this ID belongs to\r\n-      tokenPayload.profileId = user.memberProfile.id;\r\n-    }\r\n-\r\n-\r\n-    const token = jwt.sign(\r\n-      tokenPayload,\r\n-      process.env.JWT_SECRET!,\r\n-      { expiresIn: '7d' }\r\n-    );\r\n-\r\n-    res.json({\r\n-      user: tokenPayload, // Send the same enriched payload back to the frontend\r\n-      token,\r\n-    });\r\n-  } catch (err) {\r\n-    console.error(err);\r\n-    res.status(500).json({ error: 'Internal server error' });\r\n-  }\r\n-};\r\n-\r\n-export const setupPassword = async (req: Request, res: Response) => {\r\n-  const { token, newPassword } = req.body;\r\n-\r\n-  if (!token || !newPassword) {\r\n-    return res.status(400).json({ error: 'Token and new password are required.' });\r\n-  }\r\n-\r\n-  try {\r\n-    // 1. Verify the token\r\n-    const decodedToken = verifyPasswordSetupToken(token);\r\n-\r\n-    if (!decodedToken) {\r\n-      return res.status(401).json({ error: 'Invalid or expired password setup token.' });\r\n-    }\r\n-\r\n-    // 2. Find the user\r\n-    const user = await prisma.user.findUnique({\r\n-      where: { id: decodedToken.userId },\r\n-    });\r\n-\r\n-    if (!user) {\r\n-      return res.status(404).json({ error: 'User not found.' });\r\n-    }\r\n-\r\n-    // Ensure the email in the token matches the user's email\r\n-    if (user.email !== decodedToken.email) {\r\n-        return res.status(403).json({ error: 'Token mismatch.' });\r\n-    }\r\n-\r\n-    // 3. Hash the new password\r\n-    const hashedPassword = await hashPassword(newPassword);\r\n-\r\n-    // 4. Update the user's password\r\n-    await prisma.user.update({\r\n-      where: { id: user.id },\r\n-      data: { password: hashedPassword },\r\n-    });\r\n-\r\n-    res.status(200).json({ message: 'Password set successfully. You can now log in.' });\r\n-\r\n-  } catch (error) {\r\n-    console.error('Error setting up password:', error);\r\n-    res.status(500).json({ error: 'Failed to set password.' });\r\n-  }\r\n };\n\\ No newline at end of file\n"
                }
            ],
            "date": 1752123806367,
            "name": "Commit-0",
            "content": "import { Request, Response } from 'express';\r\nimport jwt from 'jsonwebtoken';\r\nimport bcrypt from 'bcryptjs';\r\nimport prisma from '../lib/prisma';\r\n\r\nexport const loginController = async (req: Request, res: Response) => {\r\n  const { email, password } = req.body;\r\n\r\n  try {\r\n    const user = await prisma.user.findUnique({\r\n      where: { email },\r\n    });\r\n\r\n    if (!user) return res.status(401).json({ error: 'Invalid credentials' });\r\n\r\n    const valid = await bcrypt.compare(password, user.password);\r\n    if (!valid) return res.status(401).json({ error: 'Invalid credentials' });\r\n\r\n    const token = jwt.sign(\r\n      {\r\n        id: user.id,\r\n        role: user.role,\r\n        clubId: user.clubId,\r\n      },\r\n      process.env.JWT_SECRET!,\r\n      { expiresIn: '7d' }\r\n    );\r\n\r\n    res.json({\r\n      user: {\r\n        id: user.id,\r\n        email: user.email,\r\n        role: user.role,\r\n        clubId: user.clubId,\r\n      },\r\n      token,\r\n    });\r\n  } catch (err) {\r\n    console.error(err);\r\n    res.status(500).json({ error: 'Internal server error' });\r\n  }\r\n};\r\n"
        }
    ]
}