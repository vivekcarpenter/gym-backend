{
    "sourceFile": "src/controllers/member.controller.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 22,
            "patches": [
                {
                    "date": 1752208689032,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1752213496534,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,8 +5,12 @@\n   try {\r\n     const member = await createNewMember(req.body);\r\n     res.status(201).json(member);\r\n   } catch (err) {\r\n-    console.error(err);\r\n-    res.status(500).json({ error: 'Failed to create member' });\r\n+  console.error('[CREATE_MEMBER_ERROR]', err);\r\n+  if (err.code === 'P2002') {\r\n+    return res.status(400).json({ error: 'Email already exists' });\r\n   }\r\n+\r\n+  res.status(500).json({ error: 'Failed to create member' });\r\n+}\r\n };\r\n"
                },
                {
                    "date": 1752213526093,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,16 @@\n+import { Request, Response } from 'express';\r\n+import { createNewMember } from '../services/member.service';\r\n+\r\n+export const createMember = async (req: Request, res: Response) => {\r\n+  try {\r\n+    const member = await createNewMember(req.body);\r\n+    res.status(201).json(member);\r\n+  } catch (err) {\r\n+  console.error('[CREATE_MEMBER_ERROR]', err);\r\n+  if (err.code === 'P2002') {\r\n+    return res.status(400).json({ error: 'Email already exists' });\r\n+  }\r\n+\r\n+  res.status(500).json({ error: 'Failed to create member' });\r\n+}\r\n+};\r\n"
                },
                {
                    "date": 1752215409328,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,53 @@\n+import { Request, Response } from 'express';\r\n+import { createNewMember } from '../services/member.service';\r\n+\r\n+export const createMember = async (req: Request, res: Response) => {\r\n+  try {\r\n+    const member = await createNewMember(req.body);\r\n+    res.status(201).json(member);\r\n+  } catch (err) {\r\n+  console.error('[CREATE_MEMBER_ERROR]', err);\r\n+  if (err.code === 'P2002') {\r\n+    return res.status(400).json({ error: 'Email already exists' });\r\n+  }\r\n+\r\n+  res.status(500).json({ error: 'Failed to create member' });\r\n+}\r\n+};\r\n+export const getMembers = async (req: Request, res: Response) => {\r\n+  const { page = 1, limit = 10, tab = 'all', search = '' } = req.query;\r\n+\r\n+  const skip = (Number(page) - 1) * Number(limit);\r\n+\r\n+  const filters: any = {\r\n+    OR: [\r\n+      { firstName: { contains: String(search), mode: 'insensitive' } },\r\n+      { lastName: { contains: String(search), mode: 'insensitive' } },\r\n+      { email: { contains: String(search), mode: 'insensitive' } },\r\n+    ],\r\n+  };\r\n+\r\n+  if (tab === 'active') filters.memberType = 'member';\r\n+  if (tab === 'prospect') filters.memberType = 'prospect';\r\n+  // Add others like `expired`, `recent` etc., later.\r\n+\r\n+  try {\r\n+    const members = await prisma.member.findMany({\r\n+      where: filters,\r\n+      skip,\r\n+      take: Number(limit),\r\n+      orderBy: { createdAt: 'desc' }\r\n+    });\r\n+\r\n+    const total = await prisma.member.count({ where: filters });\r\n+\r\n+    res.json({\r\n+      members,\r\n+      hasMore: skip + members.length < total\r\n+    });\r\n+  } catch (err) {\r\n+    console.error(err);\r\n+    res.status(500).json({ error: 'Failed to fetch members' });\r\n+  }\r\n+};\r\n+\r\n"
                },
                {
                    "date": 1752215505670,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,54 @@\n+import { Request, Response } from 'express';\r\n+import { createNewMember } from '../services/member.service';\r\n+import prisma from '../lib/prisma';\r\n+\r\n+export const createMember = async (req: Request, res: Response) => {\r\n+  try {\r\n+    const member = await createNewMember(req.body);\r\n+    res.status(201).json(member);\r\n+  } catch (err) {\r\n+  console.error('[CREATE_MEMBER_ERROR]', err);\r\n+  if (err.code === 'P2002') {\r\n+    return res.status(400).json({ error: 'Email already exists' });\r\n+  }\r\n+\r\n+  res.status(500).json({ error: 'Failed to create member' });\r\n+}\r\n+};\r\n+export const getMembers = async (req: Request, res: Response) => {\r\n+  const { page = 1, limit = 10, tab = 'all', search = '' } = req.query;\r\n+\r\n+  const skip = (Number(page) - 1) * Number(limit);\r\n+\r\n+  const filters: any = {\r\n+    OR: [\r\n+      { firstName: { contains: String(search), mode: 'insensitive' } },\r\n+      { lastName: { contains: String(search), mode: 'insensitive' } },\r\n+      { email: { contains: String(search), mode: 'insensitive' } },\r\n+    ],\r\n+  };\r\n+\r\n+  if (tab === 'active') filters.memberType = 'member';\r\n+  if (tab === 'prospect') filters.memberType = 'prospect';\r\n+  // Add others like `expired`, `recent` etc., later.\r\n+\r\n+  try {\r\n+    const members = await prisma.member.findMany({\r\n+      where: filters,\r\n+      skip,\r\n+      take: Number(limit),\r\n+      orderBy: { createdAt: 'desc' }\r\n+    });\r\n+\r\n+    const total = await prisma.member.count({ where: filters });\r\n+\r\n+    res.json({\r\n+      members,\r\n+      hasMore: skip + members.length < total\r\n+    });\r\n+  } catch (err) {\r\n+    console.error(err);\r\n+    res.status(500).json({ error: 'Failed to fetch members' });\r\n+  }\r\n+};\r\n+\r\n"
                },
                {
                    "date": 1752215741333,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -15,8 +15,12 @@\n   res.status(500).json({ error: 'Failed to create member' });\r\n }\r\n };\r\n export const getMembers = async (req: Request, res: Response) => {\r\n+\r\n+    console.log('[GET_MEMBERS] Controller hit'); \r\n+\r\n+\r\n   const { page = 1, limit = 10, tab = 'all', search = '' } = req.query;\r\n \r\n   const skip = (Number(page) - 1) * Number(limit);\r\n \r\n"
                },
                {
                    "date": 1752294820755,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,59 @@\n+//src>controllers>member.controller.ts\r\n+import { Request, Response } from 'express';\r\n+import { createNewMember } from '../services/member.service';\r\n+import prisma from '../lib/prisma';\r\n+\r\n+export const createMember = async (req: Request, res: Response) => {\r\n+  try {\r\n+    const member = await createNewMember(req.body);\r\n+    res.status(201).json(member);\r\n+  } catch (err) {\r\n+  console.error('[CREATE_MEMBER_ERROR]', err);\r\n+  if (err.code === 'P2002') {\r\n+    return res.status(400).json({ error: 'Email already exists' });\r\n+  }\r\n+\r\n+  res.status(500).json({ error: 'Failed to create member' });\r\n+}\r\n+};\r\n+export const getMembers = async (req: Request, res: Response) => {\r\n+\r\n+    console.log('[GET_MEMBERS] Controller hit'); \r\n+\r\n+\r\n+  const { page = 1, limit = 10, tab = 'all', search = '' } = req.query;\r\n+\r\n+  const skip = (Number(page) - 1) * Number(limit);\r\n+\r\n+  const filters: any = {\r\n+    OR: [\r\n+      { firstName: { contains: String(search), mode: 'insensitive' } },\r\n+      { lastName: { contains: String(search), mode: 'insensitive' } },\r\n+      { email: { contains: String(search), mode: 'insensitive' } },\r\n+    ],\r\n+  };\r\n+\r\n+  if (tab === 'active') filters.memberType = 'member';\r\n+  if (tab === 'prospect') filters.memberType = 'prospect';\r\n+  // Add others like `expired`, `recent` etc., later.\r\n+\r\n+  try {\r\n+    const members = await prisma.member.findMany({\r\n+      where: filters,\r\n+      skip,\r\n+      take: Number(limit),\r\n+      orderBy: { createdAt: 'desc' }\r\n+    });\r\n+\r\n+    const total = await prisma.member.count({ where: filters });\r\n+\r\n+    res.json({\r\n+      members,\r\n+      hasMore: skip + members.length < total\r\n+    });\r\n+  } catch (err) {\r\n+    console.error(err);\r\n+    res.status(500).json({ error: 'Failed to fetch members' });\r\n+  }\r\n+};\r\n+\r\n"
                },
                {
                    "date": 1752819354959,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -56,147 +56,4 @@\n     res.status(500).json({ error: 'Failed to fetch members' });\r\n   }\r\n };\r\n \r\n-import { Request, Response } from 'express';\r\n-import { createNewMember } from '../services/member.service';\r\n-import prisma from '../lib/prisma';\r\n-\r\n-export const createMember = async (req: Request, res: Response) => {\r\n-  try {\r\n-    const member = await createNewMember(req.body);\r\n-    res.status(201).json(member);\r\n-  } catch (err) {\r\n-  console.error('[CREATE_MEMBER_ERROR]', err);\r\n-  if (err.code === 'P2002') {\r\n-    return res.status(400).json({ error: 'Email already exists' });\r\n-  }\r\n-\r\n-  res.status(500).json({ error: 'Failed to create member' });\r\n-}\r\n-};\r\n-export const getMembers = async (req: Request, res: Response) => {\r\n-\r\n-    console.log('[GET_MEMBERS] Controller hit'); \r\n-\r\n-\r\n-  const { page = 1, limit = 10, tab = 'all', search = '' } = req.query;\r\n-\r\n-  const skip = (Number(page) - 1) * Number(limit);\r\n-\r\n-  const filters: any = {\r\n-    OR: [\r\n-      { firstName: { contains: String(search), mode: 'insensitive' } },\r\n-      { lastName: { contains: String(search), mode: 'insensitive' } },\r\n-      { email: { contains: String(search), mode: 'insensitive' } },\r\n-    ],\r\n-  };\r\n-\r\n-  if (tab === 'active') filters.memberType = 'member';\r\n-  if (tab === 'prospect') filters.memberType = 'prospect';\r\n-  // Add others like `expired`, `recent` etc., later.\r\n-\r\n-  try {\r\n-    const members = await prisma.member.findMany({\r\n-      where: filters,\r\n-      skip,\r\n-      take: Number(limit),\r\n-      orderBy: { createdAt: 'desc' }\r\n-    });\r\n-\r\n-    const total = await prisma.member.count({ where: filters });\r\n-\r\n-    res.json({\r\n-      members,\r\n-      hasMore: skip + members.length < total\r\n-    });\r\n-  } catch (err) {\r\n-    console.error(err);\r\n-    res.status(500).json({ error: 'Failed to fetch members' });\r\n-  }\r\n-};\r\n-\r\n-import { Request, Response } from 'express';\r\n-import { createNewMember } from '../services/member.service';\r\n-\r\n-export const createMember = async (req: Request, res: Response) => {\r\n-  try {\r\n-    const member = await createNewMember(req.body);\r\n-    res.status(201).json(member);\r\n-  } catch (err) {\r\n-  console.error('[CREATE_MEMBER_ERROR]', err);\r\n-  if (err.code === 'P2002') {\r\n-    return res.status(400).json({ error: 'Email already exists' });\r\n-  }\r\n-\r\n-  res.status(500).json({ error: 'Failed to create member' });\r\n-}\r\n-};\r\n-export const getMembers = async (req: Request, res: Response) => {\r\n-  const { page = 1, limit = 10, tab = 'all', search = '' } = req.query;\r\n-\r\n-  const skip = (Number(page) - 1) * Number(limit);\r\n-\r\n-  const filters: any = {\r\n-    OR: [\r\n-      { firstName: { contains: String(search), mode: 'insensitive' } },\r\n-      { lastName: { contains: String(search), mode: 'insensitive' } },\r\n-      { email: { contains: String(search), mode: 'insensitive' } },\r\n-    ],\r\n-  };\r\n-\r\n-  if (tab === 'active') filters.memberType = 'member';\r\n-  if (tab === 'prospect') filters.memberType = 'prospect';\r\n-  // Add others like `expired`, `recent` etc., later.\r\n-\r\n-  try {\r\n-    const members = await prisma.member.findMany({\r\n-      where: filters,\r\n-      skip,\r\n-      take: Number(limit),\r\n-      orderBy: { createdAt: 'desc' }\r\n-    });\r\n-\r\n-    const total = await prisma.member.count({ where: filters });\r\n-\r\n-    res.json({\r\n-      members,\r\n-      hasMore: skip + members.length < total\r\n-    });\r\n-  } catch (err) {\r\n-    console.error(err);\r\n-    res.status(500).json({ error: 'Failed to fetch members' });\r\n-  }\r\n-};\r\n-\r\n-import { Request, Response } from 'express';\r\n-import { createNewMember } from '../services/member.service';\r\n-\r\n-export const createMember = async (req: Request, res: Response) => {\r\n-  try {\r\n-    const member = await createNewMember(req.body);\r\n-    res.status(201).json(member);\r\n-  } catch (err) {\r\n-  console.error('[CREATE_MEMBER_ERROR]', err);\r\n-  if (err.code === 'P2002') {\r\n-    return res.status(400).json({ error: 'Email already exists' });\r\n-  }\r\n-\r\n-  res.status(500).json({ error: 'Failed to create member' });\r\n-}\r\n-};\r\n-import { Request, Response } from 'express';\r\n-import { createNewMember } from '../services/member.service';\r\n-\r\n-export const createMember = async (req: Request, res: Response) => {\r\n-  try {\r\n-    const member = await createNewMember(req.body);\r\n-    res.status(201).json(member);\r\n-  } catch (err) {\r\n-  console.error('[CREATE_MEMBER_ERROR]', err);\r\n-  if (err.code === 'P2002') {\r\n-    return res.status(400).json({ error: 'Email already exists' });\r\n-  }\r\n-\r\n-  res.status(500).json({ error: 'Failed to create member' });\r\n-}\r\n-};\r\n"
                },
                {
                    "date": 1752819400590,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,8 +4,14 @@\n import prisma from '../lib/prisma';\r\n \r\n export const createMember = async (req: Request, res: Response) => {\r\n   try {\r\n+const club = await prisma.club.findUnique({ where: { id: req.body.club } });\r\n+if (!club) {\r\n+  return res.status(400).json({ error: \"Invalid club ID provided\" });\r\n+}\r\n+\r\n+\r\n     const member = await createNewMember(req.body);\r\n     res.status(201).json(member);\r\n   } catch (err) {\r\n   console.error('[CREATE_MEMBER_ERROR]', err);\r\n"
                },
                {
                    "date": 1752859760157,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -62,4 +62,30 @@\n     res.status(500).json({ error: 'Failed to fetch members' });\r\n   }\r\n };\r\n \r\n+export const getMembersByTrainer = async (req: Request, res: Response) => {\r\n+  const { trainerId } = req.query;\r\n+\r\n+  if (!trainerId) {\r\n+    return res.status(400).json({ error: 'Missing trainerId' });\r\n+  }\r\n+\r\n+  try {\r\n+    const members = await prisma.member.findMany({\r\n+      where: {\r\n+        trainerId: trainerId as string,\r\n+        memberType: 'member', // only show real members, not prospects\r\n+      },\r\n+      select: {\r\n+        id: true,\r\n+        firstName: true,\r\n+        lastName: true,\r\n+      },\r\n+    });\r\n+\r\n+    res.json(members);\r\n+  } catch (err) {\r\n+    console.error('Error fetching trainer members:', err);\r\n+    res.status(500).json({ error: 'Internal server error' });\r\n+  }\r\n+};\n\\ No newline at end of file\n"
                },
                {
                    "date": 1752895367436,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,8 +1,9 @@\n //src>controllers>member.controller.ts\r\n import { Request, Response } from 'express';\r\n import { createNewMember } from '../services/member.service';\r\n import prisma from '../lib/prisma';\r\n+import { email } from 'zod';\r\n \r\n export const createMember = async (req: Request, res: Response) => {\r\n   try {\r\n const club = await prisma.club.findUnique({ where: { id: req.body.club } });\r\n@@ -73,14 +74,15 @@\n   try {\r\n     const members = await prisma.member.findMany({\r\n       where: {\r\n         trainerId: trainerId as string,\r\n-        memberType: 'member', // only show real members, not prospects\r\n+        memberType: 'member', \r\n       },\r\n       select: {\r\n         id: true,\r\n         firstName: true,\r\n         lastName: true,\r\n+        email : true,\r\n       },\r\n     });\r\n \r\n     res.json(members);\r\n"
                },
                {
                    "date": 1752895800408,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -74,9 +74,9 @@\n   try {\r\n     const members = await prisma.member.findMany({\r\n       where: {\r\n         trainerId: trainerId as string,\r\n-        memberType: 'member', \r\n+        \r\n       },\r\n       select: {\r\n         id: true,\r\n         firstName: true,\r\n"
                },
                {
                    "date": 1752895812835,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -74,9 +74,9 @@\n   try {\r\n     const members = await prisma.member.findMany({\r\n       where: {\r\n         trainerId: trainerId as string,\r\n-        \r\n+        memberType: 'member', \r\n       },\r\n       select: {\r\n         id: true,\r\n         firstName: true,\r\n"
                },
                {
                    "date": 1752895926253,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -73,9 +73,9 @@\n \r\n   try {\r\n     const members = await prisma.member.findMany({\r\n       where: {\r\n-        trainerId: trainerId as string,\r\n+        \r\n         memberType: 'member', \r\n       },\r\n       select: {\r\n         id: true,\r\n"
                },
                {
                    "date": 1752896120674,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -73,9 +73,9 @@\n \r\n   try {\r\n     const members = await prisma.member.findMany({\r\n       where: {\r\n-        \r\n+        trainerId: trainerId as string,\r\n         memberType: 'member', \r\n       },\r\n       select: {\r\n         id: true,\r\n"
                },
                {
                    "date": 1752896137006,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -63,30 +63,79 @@\n     res.status(500).json({ error: 'Failed to fetch members' });\r\n   }\r\n };\r\n \r\n+// export const getMembersByTrainer = async (req: Request, res: Response) => {\r\n+\r\n+//   const { trainerId } = req.query;\r\n+\r\n+//   if (!trainerId) {\r\n+//     return res.status(400).json({ error: 'Missing trainerId' });\r\n+//   }\r\n+\r\n+//   try {\r\n+//     const members = await prisma.member.findMany({\r\n+//       where: {\r\n+//         trainerId: trainerId as string,\r\n+//         memberType: 'member', \r\n+//       },\r\n+//       select: {\r\n+//         id: true,\r\n+//         firstName: true,\r\n+//         lastName: true,\r\n+//         email : true,\r\n+//       },\r\n+//     });\r\n+\r\n+//     res.json(members);\r\n+//   } catch (err) {\r\n+//     console.error('Error fetching trainer members:', err);\r\n+//     res.status(500).json({ error: 'Internal server error' });\r\n+//   }\r\n+// };\r\n+\r\n export const getMembersByTrainer = async (req: Request, res: Response) => {\r\n   const { trainerId } = req.query;\r\n \r\n   if (!trainerId) {\r\n     return res.status(400).json({ error: 'Missing trainerId' });\r\n   }\r\n \r\n   try {\r\n-    const members = await prisma.member.findMany({\r\n+    // Find the trainer (could be by userId or direct trainer ID)\r\n+    const trainer = await prisma.trainer.findFirst({\r\n       where: {\r\n-        trainerId: trainerId as string,\r\n-        memberType: 'member', \r\n+        OR: [\r\n+          { userId: trainerId as string }, // If trainerId is actually a User.id\r\n+          { id: trainerId as string },     // If trainerId is the actual Trainer.id\r\n+        ],\r\n       },\r\n-      select: {\r\n-        id: true,\r\n-        firstName: true,\r\n-        lastName: true,\r\n-        email : true,\r\n+      include: {\r\n+        members: {\r\n+          where: {\r\n+            memberType: 'member', // Only active members\r\n+          },\r\n+          select: {\r\n+            id: true,\r\n+            firstName: true,\r\n+            lastName: true,\r\n+            email: true,\r\n+          },\r\n+          orderBy: {\r\n+            firstName: 'asc',\r\n+          },\r\n+        },\r\n       },\r\n     });\r\n \r\n-    res.json(members);\r\n+    if (!trainer) {\r\n+      console.log(`No trainer found for ID: ${trainerId}`);\r\n+      return res.status(404).json({ error: 'Trainer not found' });\r\n+    }\r\n+\r\n+    console.log(`Found trainer: ${trainer.name} with ${trainer.members.length} members`);\r\n+\r\n+    res.json(trainer.members);\r\n   } catch (err) {\r\n     console.error('Error fetching trainer members:', err);\r\n     res.status(500).json({ error: 'Internal server error' });\r\n   }\r\n"
                },
                {
                    "date": 1752896473220,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -63,37 +63,9 @@\n     res.status(500).json({ error: 'Failed to fetch members' });\r\n   }\r\n };\r\n \r\n-// export const getMembersByTrainer = async (req: Request, res: Response) => {\r\n \r\n-//   const { trainerId } = req.query;\r\n-\r\n-//   if (!trainerId) {\r\n-//     return res.status(400).json({ error: 'Missing trainerId' });\r\n-//   }\r\n-\r\n-//   try {\r\n-//     const members = await prisma.member.findMany({\r\n-//       where: {\r\n-//         trainerId: trainerId as string,\r\n-//         memberType: 'member', \r\n-//       },\r\n-//       select: {\r\n-//         id: true,\r\n-//         firstName: true,\r\n-//         lastName: true,\r\n-//         email : true,\r\n-//       },\r\n-//     });\r\n-\r\n-//     res.json(members);\r\n-//   } catch (err) {\r\n-//     console.error('Error fetching trainer members:', err);\r\n-//     res.status(500).json({ error: 'Internal server error' });\r\n-//   }\r\n-// };\r\n-\r\n export const getMembersByTrainer = async (req: Request, res: Response) => {\r\n   const { trainerId } = req.query;\r\n \r\n   if (!trainerId) {\r\n"
                },
                {
                    "date": 1753045366053,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -110,5 +110,54 @@\n   } catch (err) {\r\n     console.error('Error fetching trainer members:', err);\r\n     res.status(500).json({ error: 'Internal server error' });\r\n   }\r\n-};\n\\ No newline at end of file\n+};\r\n+\r\n+// GET /api/members/join-trend?clubId=...&range=30\r\n+export const getMemberJoinTrend = async (req: Request, res: Response) => {\r\n+  const { clubId, range } = req.query;\r\n+  const days = parseInt(range as string) || 30;\r\n+\r\n+  if (!clubId) {\r\n+    return res.status(400).json({ error: 'Missing clubId' });\r\n+  }\r\n+\r\n+  const end = new Date();\r\n+  const start = new Date();\r\n+  start.setDate(end.getDate() - days);\r\n+\r\n+  try {\r\n+    const members = await prisma.member.findMany({\r\n+      where: {\r\n+        clubId: String(clubId),\r\n+        createdAt: {\r\n+          gte: start,\r\n+          lte: end,\r\n+        },\r\n+      },\r\n+      select: { createdAt: true },\r\n+    });\r\n+\r\n+    // Bucket by date\r\n+    const countByDate: Record<string, number> = {};\r\n+    for (let d = new Date(start); d <= end; d.setDate(d.getDate() + 1)) {\r\n+      const key = d.toISOString().split('T')[0];\r\n+      countByDate[key] = 0;\r\n+    }\r\n+\r\n+    members.forEach((m) => {\r\n+      const key = m.createdAt.toISOString().split('T')[0];\r\n+      if (countByDate[key] !== undefined) countByDate[key]++;\r\n+    });\r\n+\r\n+    const result = Object.entries(countByDate).map(([date, count]) => ({\r\n+      date,\r\n+      count,\r\n+    }));\r\n+\r\n+    res.json(result);\r\n+  } catch (err) {\r\n+    console.error('Join trend error:', err);\r\n+    res.status(500).json({ error: 'Failed to fetch join trend' });\r\n+  }\r\n+};\r\n"
                },
                {
                    "date": 1753070603123,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -115,49 +115,63 @@\n \r\n // GET /api/members/join-trend?clubId=...&range=30\r\n export const getMemberJoinTrend = async (req: Request, res: Response) => {\r\n   const { clubId, range } = req.query;\r\n-  const days = parseInt(range as string) || 30;\r\n+  const days = parseInt(range as string) || 30; // Default to 30 days\r\n \r\n   if (!clubId) {\r\n     return res.status(400).json({ error: 'Missing clubId' });\r\n   }\r\n \r\n   const end = new Date();\r\n-  const start = new Date();\r\n-  start.setDate(end.getDate() - days);\r\n+  end.setHours(23, 59, 59, 999); // Set to end of the day to include members created throughout today\r\n \r\n+  const start = new Date(end); // Start with a copy of end date\r\n+  start.setDate(end.getDate() - (days - 1)); // Go back 'days-1' days to include the full 'days' duration\r\n+  start.setHours(0, 0, 0, 0); // Set to start of the day\r\n+\r\n+  console.log(`Fetching join trend for clubId: ${clubId} from ${start.toISOString()} to ${end.toISOString()}`);\r\n+\r\n   try {\r\n     const members = await prisma.member.findMany({\r\n       where: {\r\n         clubId: String(clubId),\r\n-        createdAt: {\r\n+        memberType: 'member', // Assuming the graph is for actual 'members' and not 'prospects'\r\n+        createdAt: { // Using 'createdAt' as confirmed\r\n           gte: start,\r\n           lte: end,\r\n         },\r\n       },\r\n-      select: { createdAt: true },\r\n+      select: { createdAt: true }, // Select 'createdAt'\r\n     });\r\n \r\n-    // Bucket by date\r\n+    console.log(`Found ${members.length} members within the date range.`);\r\n+\r\n+    // Initialize counts for all dates in the range to 0\r\n     const countByDate: Record<string, number> = {};\r\n     for (let d = new Date(start); d <= end; d.setDate(d.getDate() + 1)) {\r\n-      const key = d.toISOString().split('T')[0];\r\n+      const key = d.toISOString().split('T')[0]; // Format as YYYY-MM-DD\r\n       countByDate[key] = 0;\r\n     }\r\n \r\n+    // Populate counts based on fetched members' createdAt\r\n     members.forEach((m) => {\r\n       const key = m.createdAt.toISOString().split('T')[0];\r\n-      if (countByDate[key] !== undefined) countByDate[key]++;\r\n+      if (countByDate[key] !== undefined) { // Only increment if the date is within our calculated range\r\n+        countByDate[key]++;\r\n+      }\r\n     });\r\n \r\n-    const result = Object.entries(countByDate).map(([date, count]) => ({\r\n-      date,\r\n-      count,\r\n-    }));\r\n+    // Convert to array format for Recharts and ensure chronological order\r\n+    const result = Object.entries(countByDate)\r\n+      .sort(([dateA], [dateB]) => new Date(dateA).getTime() - new Date(dateB).getTime())\r\n+      .map(([date, count]) => ({\r\n+        date,\r\n+        count,\r\n+      }));\r\n \r\n     res.json(result);\r\n   } catch (err) {\r\n     console.error('Join trend error:', err);\r\n     res.status(500).json({ error: 'Failed to fetch join trend' });\r\n   }\r\n-};\r\n+};\n\\ No newline at end of file\n"
                },
                {
                    "date": 1753071545857,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,183 @@\n+//src>controllers>member.controller.ts\r\n+import { Request, Response } from 'express';\r\n+import { createNewMember } from '../services/member.service';\r\n+import prisma from '../lib/prisma';\r\n+import { email } from 'zod';\r\n+\r\n+export const createMember = async (req: Request, res: Response) => {\r\n+  try {\r\n+const club = await prisma.club.findUnique({ where: { id: req.body.club } });\r\n+if (!club) {\r\n+  return res.status(400).json({ error: \"Invalid club ID provided\" });\r\n+}\r\n+\r\n+\r\n+    const member = await createNewMember(req.body);\r\n+    res.status(201).json(member);\r\n+  } catch (err) {\r\n+  console.error('[CREATE_MEMBER_ERROR]', err);\r\n+  if (err.code === 'P2002') {\r\n+    return res.status(400).json({ error: 'Email already exists' });\r\n+  }\r\n+\r\n+  res.status(500).json({ error: 'Failed to create member' });\r\n+}\r\n+};\r\n+export const getMembers = async (req: Request, res: Response) => {\r\n+\r\n+    console.log('[GET_MEMBERS] Controller hit'); \r\n+\r\n+\r\n+  const { page = 1, limit = 10, tab = 'all', search = '' } = req.query;\r\n+\r\n+  const skip = (Number(page) - 1) * Number(limit);\r\n+\r\n+  const filters: any = {\r\n+    OR: [\r\n+      { firstName: { contains: String(search), mode: 'insensitive' } },\r\n+      { lastName: { contains: String(search), mode: 'insensitive' } },\r\n+      { email: { contains: String(search), mode: 'insensitive' } },\r\n+    ],\r\n+  };\r\n+\r\n+  if (tab === 'active') filters.memberType = 'member';\r\n+  if (tab === 'prospect') filters.memberType = 'prospect';\r\n+  // Add others like `expired`, `recent` etc., later.\r\n+\r\n+  try {\r\n+    const members = await prisma.member.findMany({\r\n+      where: filters,\r\n+      skip,\r\n+      take: Number(limit),\r\n+      orderBy: { createdAt: 'desc' }\r\n+    });\r\n+\r\n+    const total = await prisma.member.count({ where: filters });\r\n+\r\n+    res.json({\r\n+      members,\r\n+      hasMore: skip + members.length < total\r\n+    });\r\n+  } catch (err) {\r\n+    console.error(err);\r\n+    res.status(500).json({ error: 'Failed to fetch members' });\r\n+  }\r\n+};\r\n+\r\n+\r\n+export const getMembersByTrainer = async (req: Request, res: Response) => {\r\n+  const { trainerId } = req.query;\r\n+\r\n+  if (!trainerId) {\r\n+    return res.status(400).json({ error: 'Missing trainerId' });\r\n+  }\r\n+\r\n+  try {\r\n+    // Find the trainer (could be by userId or direct trainer ID)\r\n+    const trainer = await prisma.trainer.findFirst({\r\n+      where: {\r\n+        OR: [\r\n+          { userId: trainerId as string }, // If trainerId is actually a User.id\r\n+          { id: trainerId as string },     // If trainerId is the actual Trainer.id\r\n+        ],\r\n+      },\r\n+      include: {\r\n+        members: {\r\n+          where: {\r\n+            memberType: 'member', // Only active members\r\n+          },\r\n+          select: {\r\n+            id: true,\r\n+            firstName: true,\r\n+            lastName: true,\r\n+            email: true,\r\n+          },\r\n+          orderBy: {\r\n+            firstName: 'asc',\r\n+          },\r\n+        },\r\n+      },\r\n+    });\r\n+\r\n+    if (!trainer) {\r\n+      console.log(`No trainer found for ID: ${trainerId}`);\r\n+      return res.status(404).json({ error: 'Trainer not found' });\r\n+    }\r\n+\r\n+    console.log(`Found trainer: ${trainer.name} with ${trainer.members.length} members`);\r\n+\r\n+    res.json(trainer.members);\r\n+  } catch (err) {\r\n+    console.error('Error fetching trainer members:', err);\r\n+    res.status(500).json({ error: 'Internal server error' });\r\n+  }\r\n+};\r\n+\r\n+// GET /api/members/join-trend?clubId=...&range=30\r\n+export const getMemberJoinTrend = async (req: Request, res: Response) => {\r\n+  const { clubId, range } = req.query; // clubId will be undefined here for super_admin\r\n+  const days = parseInt(range as string) || 30;\r\n+\r\n+  // IMPORTANT: The check for `!clubId` is GONE from here, as we want to allow optional clubId.\r\n+  // We don't want to return 400 if clubId is missing for a global trend.\r\n+\r\n+  const end = new Date();\r\n+  end.setHours(23, 59, 59, 999);\r\n+\r\n+  const start = new Date(end);\r\n+  start.setDate(end.getDate() - (days - 1));\r\n+  start.setHours(0, 0, 0, 0);\r\n+\r\n+  let whereClause: any = {\r\n+    memberType: 'member',\r\n+    createdAt: {\r\n+      gte: start,\r\n+      lte: end,\r\n+    },\r\n+  };\r\n+\r\n+  // This `if (clubId)` block is key. If clubId is undefined (from frontend not sending it),\r\n+  // this block is skipped, and the query runs globally.\r\n+  if (clubId) { \r\n+    whereClause.clubId = String(clubId);\r\n+    console.log(`Backend: clubId provided (${clubId}), fetching club-specific member join trend.`);\r\n+  } else {\r\n+    console.log('Backend: No clubId provided, fetching GLOBAL member join trend.');\r\n+  }\r\n+\r\n+  console.log(`Backend: Fetching join trend with filters:`, whereClause);\r\n+\r\n+  try {\r\n+    const members = await prisma.member.findMany({\r\n+      where: whereClause,\r\n+      select: { createdAt: true },\r\n+    });\r\n+\r\n+    console.log(`Backend: Found ${members.length} members within the date range.`);\r\n+\r\n+    const countByDate: Record<string, number> = {};\r\n+    for (let d = new Date(start); d <= end; d.setDate(d.getDate() + 1)) {\r\n+      const key = d.toISOString().split('T')[0];\r\n+      countByDate[key] = 0;\r\n+    }\r\n+\r\n+    members.forEach((m) => {\r\n+      const key = m.createdAt.toISOString().split('T')[0];\r\n+      if (countByDate[key] !== undefined) {\r\n+        countByDate[key]++;\r\n+      }\r\n+    });\r\n+\r\n+    const result = Object.entries(countByDate)\r\n+      .sort(([dateA], [dateB]) => new Date(dateA).getTime() - new Date(dateB).getTime())\r\n+      .map(([date, count]) => ({\r\n+        date,\r\n+        count,\r\n+      }));\r\n+\r\n+    res.json(result);\r\n+  } catch (err) {\r\n+    console.error('Join trend error:', err);\r\n+    res.status(500).json({ error: 'Failed to fetch join trend' });\r\n+  }\r\n+};\n\\ No newline at end of file\n"
                },
                {
                    "date": 1753071546074,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -179,182 +179,5 @@\n   } catch (err) {\r\n     console.error('Join trend error:', err);\r\n     res.status(500).json({ error: 'Failed to fetch join trend' });\r\n   }\r\n-};\n-//src>controllers>member.controller.ts\r\n-import { Request, Response } from 'express';\r\n-import { createNewMember } from '../services/member.service';\r\n-import prisma from '../lib/prisma';\r\n-import { email } from 'zod';\r\n-\r\n-export const createMember = async (req: Request, res: Response) => {\r\n-  try {\r\n-const club = await prisma.club.findUnique({ where: { id: req.body.club } });\r\n-if (!club) {\r\n-  return res.status(400).json({ error: \"Invalid club ID provided\" });\r\n-}\r\n-\r\n-\r\n-    const member = await createNewMember(req.body);\r\n-    res.status(201).json(member);\r\n-  } catch (err) {\r\n-  console.error('[CREATE_MEMBER_ERROR]', err);\r\n-  if (err.code === 'P2002') {\r\n-    return res.status(400).json({ error: 'Email already exists' });\r\n-  }\r\n-\r\n-  res.status(500).json({ error: 'Failed to create member' });\r\n-}\r\n-};\r\n-export const getMembers = async (req: Request, res: Response) => {\r\n-\r\n-    console.log('[GET_MEMBERS] Controller hit'); \r\n-\r\n-\r\n-  const { page = 1, limit = 10, tab = 'all', search = '' } = req.query;\r\n-\r\n-  const skip = (Number(page) - 1) * Number(limit);\r\n-\r\n-  const filters: any = {\r\n-    OR: [\r\n-      { firstName: { contains: String(search), mode: 'insensitive' } },\r\n-      { lastName: { contains: String(search), mode: 'insensitive' } },\r\n-      { email: { contains: String(search), mode: 'insensitive' } },\r\n-    ],\r\n-  };\r\n-\r\n-  if (tab === 'active') filters.memberType = 'member';\r\n-  if (tab === 'prospect') filters.memberType = 'prospect';\r\n-  // Add others like `expired`, `recent` etc., later.\r\n-\r\n-  try {\r\n-    const members = await prisma.member.findMany({\r\n-      where: filters,\r\n-      skip,\r\n-      take: Number(limit),\r\n-      orderBy: { createdAt: 'desc' }\r\n-    });\r\n-\r\n-    const total = await prisma.member.count({ where: filters });\r\n-\r\n-    res.json({\r\n-      members,\r\n-      hasMore: skip + members.length < total\r\n-    });\r\n-  } catch (err) {\r\n-    console.error(err);\r\n-    res.status(500).json({ error: 'Failed to fetch members' });\r\n-  }\r\n-};\r\n-\r\n-\r\n-export const getMembersByTrainer = async (req: Request, res: Response) => {\r\n-  const { trainerId } = req.query;\r\n-\r\n-  if (!trainerId) {\r\n-    return res.status(400).json({ error: 'Missing trainerId' });\r\n-  }\r\n-\r\n-  try {\r\n-    // Find the trainer (could be by userId or direct trainer ID)\r\n-    const trainer = await prisma.trainer.findFirst({\r\n-      where: {\r\n-        OR: [\r\n-          { userId: trainerId as string }, // If trainerId is actually a User.id\r\n-          { id: trainerId as string },     // If trainerId is the actual Trainer.id\r\n-        ],\r\n-      },\r\n-      include: {\r\n-        members: {\r\n-          where: {\r\n-            memberType: 'member', // Only active members\r\n-          },\r\n-          select: {\r\n-            id: true,\r\n-            firstName: true,\r\n-            lastName: true,\r\n-            email: true,\r\n-          },\r\n-          orderBy: {\r\n-            firstName: 'asc',\r\n-          },\r\n-        },\r\n-      },\r\n-    });\r\n-\r\n-    if (!trainer) {\r\n-      console.log(`No trainer found for ID: ${trainerId}`);\r\n-      return res.status(404).json({ error: 'Trainer not found' });\r\n-    }\r\n-\r\n-    console.log(`Found trainer: ${trainer.name} with ${trainer.members.length} members`);\r\n-\r\n-    res.json(trainer.members);\r\n-  } catch (err) {\r\n-    console.error('Error fetching trainer members:', err);\r\n-    res.status(500).json({ error: 'Internal server error' });\r\n-  }\r\n-};\r\n-\r\n-// GET /api/members/join-trend?clubId=...&range=30\r\n-export const getMemberJoinTrend = async (req: Request, res: Response) => {\r\n-  const { clubId, range } = req.query;\r\n-  const days = parseInt(range as string) || 30; // Default to 30 days\r\n-\r\n-  if (!clubId) {\r\n-    return res.status(400).json({ error: 'Missing clubId' });\r\n-  }\r\n-\r\n-  const end = new Date();\r\n-  end.setHours(23, 59, 59, 999); // Set to end of the day to include members created throughout today\r\n-\r\n-  const start = new Date(end); // Start with a copy of end date\r\n-  start.setDate(end.getDate() - (days - 1)); // Go back 'days-1' days to include the full 'days' duration\r\n-  start.setHours(0, 0, 0, 0); // Set to start of the day\r\n-\r\n-  console.log(`Fetching join trend for clubId: ${clubId} from ${start.toISOString()} to ${end.toISOString()}`);\r\n-\r\n-  try {\r\n-    const members = await prisma.member.findMany({\r\n-      where: {\r\n-        clubId: String(clubId),\r\n-        memberType: 'member', // Assuming the graph is for actual 'members' and not 'prospects'\r\n-        createdAt: { // Using 'createdAt' as confirmed\r\n-          gte: start,\r\n-          lte: end,\r\n-        },\r\n-      },\r\n-      select: { createdAt: true }, // Select 'createdAt'\r\n-    });\r\n-\r\n-    console.log(`Found ${members.length} members within the date range.`);\r\n-\r\n-    // Initialize counts for all dates in the range to 0\r\n-    const countByDate: Record<string, number> = {};\r\n-    for (let d = new Date(start); d <= end; d.setDate(d.getDate() + 1)) {\r\n-      const key = d.toISOString().split('T')[0]; // Format as YYYY-MM-DD\r\n-      countByDate[key] = 0;\r\n-    }\r\n-\r\n-    // Populate counts based on fetched members' createdAt\r\n-    members.forEach((m) => {\r\n-      const key = m.createdAt.toISOString().split('T')[0];\r\n-      if (countByDate[key] !== undefined) { // Only increment if the date is within our calculated range\r\n-        countByDate[key]++;\r\n-      }\r\n-    });\r\n-\r\n-    // Convert to array format for Recharts and ensure chronological order\r\n-    const result = Object.entries(countByDate)\r\n-      .sort(([dateA], [dateB]) => new Date(dateA).getTime() - new Date(dateB).getTime())\r\n-      .map(([date, count]) => ({\r\n-        date,\r\n-        count,\r\n-      }));\r\n-\r\n-    res.json(result);\r\n-  } catch (err) {\r\n-    console.error('Join trend error:', err);\r\n-    res.status(500).json({ error: 'Failed to fetch join trend' });\r\n-  }\r\n };\n\\ No newline at end of file\n"
                },
                {
                    "date": 1753178220194,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -113,33 +113,98 @@\n   }\r\n };\r\n \r\n // GET /api/members/join-trend?clubId=...&range=30\r\n+// export const getMemberJoinTrend = async (req: Request, res: Response) => {\r\n+//   const { clubId, range } = req.query; // clubId will be undefined here for super_admin\r\n+//   const days = parseInt(range as string) || 30;\r\n+\r\n+//   // IMPORTANT: The check for `!clubId` is GONE from here, as we want to allow optional clubId.\r\n+//   // We don't want to return 400 if clubId is missing for a global trend.\r\n+\r\n+//   const end = new Date();\r\n+//   end.setHours(23, 59, 59, 999);\r\n+\r\n+//   const start = new Date(end);\r\n+//   start.setDate(end.getDate() - (days - 1));\r\n+//   start.setHours(0, 0, 0, 0);\r\n+\r\n+//   let whereClause: any = {\r\n+//     memberType: 'member',\r\n+//     createdAt: {\r\n+//       gte: start,\r\n+//       lte: end,\r\n+//     },\r\n+//   };\r\n+\r\n+//   // This `if (clubId)` block is key. If clubId is undefined (from frontend not sending it),\r\n+//   // this block is skipped, and the query runs globally.\r\n+//   if (clubId) { \r\n+//     whereClause.clubId = String(clubId);\r\n+//     console.log(`Backend: clubId provided (${clubId}), fetching club-specific member join trend.`);\r\n+//   } else {\r\n+//     console.log('Backend: No clubId provided, fetching GLOBAL member join trend.');\r\n+//   }\r\n+\r\n+//   console.log(`Backend: Fetching join trend with filters:`, whereClause);\r\n+\r\n+//   try {\r\n+//     const members = await prisma.member.findMany({\r\n+//       where: whereClause,\r\n+//       select: { createdAt: true },\r\n+//     });\r\n+\r\n+//     console.log(`Backend: Found ${members.length} members within the date range.`);\r\n+\r\n+//     const countByDate: Record<string, number> = {};\r\n+//     for (let d = new Date(start); \r\n+//     d <= end; \r\n+//     d.setDate(d.getDate() + 1)) {\r\n+//       const key = d.toISOString().split('T')[0];\r\n+//       countByDate[key] = 0;\r\n+//     }\r\n+\r\n+//     members.forEach((m) => {\r\n+//       const key = m.createdAt.toISOString().split('T')[0];\r\n+//       if (countByDate[key] !== undefined) {\r\n+//         countByDate[key]++;\r\n+//       }\r\n+//     });\r\n+\r\n+//     const result = Object.entries(countByDate)\r\n+//       .sort(([dateA], [dateB]) => new Date(dateA).getTime() - new Date(dateB).getTime())\r\n+//       .map(([date, count]) => ({\r\n+//         date,\r\n+//         count,\r\n+//       }));\r\n+\r\n+//     res.json(result);\r\n+//   } catch (err) {\r\n+//     console.error('Join trend error:', err);\r\n+//     res.status(500).json({ error: 'Failed to fetch join trend' });\r\n+//   }\r\n+// };\r\n+\r\n export const getMemberJoinTrend = async (req: Request, res: Response) => {\r\n-  const { clubId, range } = req.query; // clubId will be undefined here for super_admin\r\n+  const { clubId, range } = req.query;\r\n   const days = parseInt(range as string) || 30;\r\n \r\n-  // IMPORTANT: The check for `!clubId` is GONE from here, as we want to allow optional clubId.\r\n-  // We don't want to return 400 if clubId is missing for a global trend.\r\n-\r\n   const end = new Date();\r\n   end.setHours(23, 59, 59, 999);\r\n \r\n   const start = new Date(end);\r\n   start.setDate(end.getDate() - (days - 1));\r\n   start.setHours(0, 0, 0, 0);\r\n \r\n-  let whereClause: any = {\r\n+  const whereClause: any = {\r\n     memberType: 'member',\r\n     createdAt: {\r\n       gte: start,\r\n       lte: end,\r\n     },\r\n   };\r\n \r\n-  // This `if (clubId)` block is key. If clubId is undefined (from frontend not sending it),\r\n-  // this block is skipped, and the query runs globally.\r\n-  if (clubId) { \r\n+  if (clubId) {\r\n     whereClause.clubId = String(clubId);\r\n     console.log(`Backend: clubId provided (${clubId}), fetching club-specific member join trend.`);\r\n   } else {\r\n     console.log('Backend: No clubId provided, fetching GLOBAL member join trend.');\r\n@@ -155,13 +220,18 @@\n \r\n     console.log(`Backend: Found ${members.length} members within the date range.`);\r\n \r\n     const countByDate: Record<string, number> = {};\r\n-    for (let d = new Date(start); d <= end; d.setDate(d.getDate() + 1)) {\r\n-      const key = d.toISOString().split('T')[0];\r\n+\r\n+    // ✅ SAFELY generate all date keys without mutation bugs\r\n+    let current = new Date(start);\r\n+    while (current <= end) {\r\n+      const key = current.toISOString().split('T')[0];\r\n       countByDate[key] = 0;\r\n+      current = new Date(current.getTime() + 86400000); // add 1 day\r\n     }\r\n \r\n+    // ✅ Group each member by date\r\n     members.forEach((m) => {\r\n       const key = m.createdAt.toISOString().split('T')[0];\r\n       if (countByDate[key] !== undefined) {\r\n         countByDate[key]++;\r\n@@ -169,15 +239,12 @@\n     });\r\n \r\n     const result = Object.entries(countByDate)\r\n       .sort(([dateA], [dateB]) => new Date(dateA).getTime() - new Date(dateB).getTime())\r\n-      .map(([date, count]) => ({\r\n-        date,\r\n-        count,\r\n-      }));\r\n+      .map(([date, count]) => ({ date, count }));\r\n \r\n     res.json(result);\r\n   } catch (err) {\r\n     console.error('Join trend error:', err);\r\n     res.status(500).json({ error: 'Failed to fetch join trend' });\r\n   }\r\n\\ No newline at end of file\n-};\n+};\r\n"
                },
                {
                    "date": 1753178241846,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -113,98 +113,33 @@\n   }\r\n };\r\n \r\n // GET /api/members/join-trend?clubId=...&range=30\r\n-// export const getMemberJoinTrend = async (req: Request, res: Response) => {\r\n-//   const { clubId, range } = req.query; // clubId will be undefined here for super_admin\r\n-//   const days = parseInt(range as string) || 30;\r\n-\r\n-//   // IMPORTANT: The check for `!clubId` is GONE from here, as we want to allow optional clubId.\r\n-//   // We don't want to return 400 if clubId is missing for a global trend.\r\n-\r\n-//   const end = new Date();\r\n-//   end.setHours(23, 59, 59, 999);\r\n-\r\n-//   const start = new Date(end);\r\n-//   start.setDate(end.getDate() - (days - 1));\r\n-//   start.setHours(0, 0, 0, 0);\r\n-\r\n-//   let whereClause: any = {\r\n-//     memberType: 'member',\r\n-//     createdAt: {\r\n-//       gte: start,\r\n-//       lte: end,\r\n-//     },\r\n-//   };\r\n-\r\n-//   // This `if (clubId)` block is key. If clubId is undefined (from frontend not sending it),\r\n-//   // this block is skipped, and the query runs globally.\r\n-//   if (clubId) { \r\n-//     whereClause.clubId = String(clubId);\r\n-//     console.log(`Backend: clubId provided (${clubId}), fetching club-specific member join trend.`);\r\n-//   } else {\r\n-//     console.log('Backend: No clubId provided, fetching GLOBAL member join trend.');\r\n-//   }\r\n-\r\n-//   console.log(`Backend: Fetching join trend with filters:`, whereClause);\r\n-\r\n-//   try {\r\n-//     const members = await prisma.member.findMany({\r\n-//       where: whereClause,\r\n-//       select: { createdAt: true },\r\n-//     });\r\n-\r\n-//     console.log(`Backend: Found ${members.length} members within the date range.`);\r\n-\r\n-//     const countByDate: Record<string, number> = {};\r\n-//     for (let d = new Date(start); \r\n-//     d <= end; \r\n-//     d.setDate(d.getDate() + 1)) {\r\n-//       const key = d.toISOString().split('T')[0];\r\n-//       countByDate[key] = 0;\r\n-//     }\r\n-\r\n-//     members.forEach((m) => {\r\n-//       const key = m.createdAt.toISOString().split('T')[0];\r\n-//       if (countByDate[key] !== undefined) {\r\n-//         countByDate[key]++;\r\n-//       }\r\n-//     });\r\n-\r\n-//     const result = Object.entries(countByDate)\r\n-//       .sort(([dateA], [dateB]) => new Date(dateA).getTime() - new Date(dateB).getTime())\r\n-//       .map(([date, count]) => ({\r\n-//         date,\r\n-//         count,\r\n-//       }));\r\n-\r\n-//     res.json(result);\r\n-//   } catch (err) {\r\n-//     console.error('Join trend error:', err);\r\n-//     res.status(500).json({ error: 'Failed to fetch join trend' });\r\n-//   }\r\n-// };\r\n-\r\n export const getMemberJoinTrend = async (req: Request, res: Response) => {\r\n-  const { clubId, range } = req.query;\r\n+  const { clubId, range } = req.query; // clubId will be undefined here for super_admin\r\n   const days = parseInt(range as string) || 30;\r\n \r\n+  // IMPORTANT: The check for `!clubId` is GONE from here, as we want to allow optional clubId.\r\n+  // We don't want to return 400 if clubId is missing for a global trend.\r\n+\r\n   const end = new Date();\r\n   end.setHours(23, 59, 59, 999);\r\n \r\n   const start = new Date(end);\r\n   start.setDate(end.getDate() - (days - 1));\r\n   start.setHours(0, 0, 0, 0);\r\n \r\n-  const whereClause: any = {\r\n+  let whereClause: any = {\r\n     memberType: 'member',\r\n     createdAt: {\r\n       gte: start,\r\n       lte: end,\r\n     },\r\n   };\r\n \r\n-  if (clubId) {\r\n+  // This `if (clubId)` block is key. If clubId is undefined (from frontend not sending it),\r\n+  // this block is skipped, and the query runs globally.\r\n+  if (clubId) { \r\n     whereClause.clubId = String(clubId);\r\n     console.log(`Backend: clubId provided (${clubId}), fetching club-specific member join trend.`);\r\n   } else {\r\n     console.log('Backend: No clubId provided, fetching GLOBAL member join trend.');\r\n@@ -220,18 +155,14 @@\n \r\n     console.log(`Backend: Found ${members.length} members within the date range.`);\r\n \r\n     const countByDate: Record<string, number> = {};\r\n-\r\n-    // ✅ SAFELY generate all date keys without mutation bugs\r\n-    let current = new Date(start);\r\n-    while (current <= end) {\r\n-      const key = current.toISOString().split('T')[0];\r\n+    for (let d = new Date(start); \r\n+    d <= end; d.setDate(d.getDate() + 1)) {\r\n+      const key = d.toISOString().split('T')[0];\r\n       countByDate[key] = 0;\r\n-      current = new Date(current.getTime() + 86400000); // add 1 day\r\n     }\r\n \r\n-    // ✅ Group each member by date\r\n     members.forEach((m) => {\r\n       const key = m.createdAt.toISOString().split('T')[0];\r\n       if (countByDate[key] !== undefined) {\r\n         countByDate[key]++;\r\n@@ -239,12 +170,15 @@\n     });\r\n \r\n     const result = Object.entries(countByDate)\r\n       .sort(([dateA], [dateB]) => new Date(dateA).getTime() - new Date(dateB).getTime())\r\n-      .map(([date, count]) => ({ date, count }));\r\n+      .map(([date, count]) => ({\r\n+        date,\r\n+        count,\r\n+      }));\r\n \r\n     res.json(result);\r\n   } catch (err) {\r\n     console.error('Join trend error:', err);\r\n     res.status(500).json({ error: 'Failed to fetch join trend' });\r\n   }\r\n-};\r\n+};\n\\ No newline at end of file\n"
                }
            ],
            "date": 1752208689032,
            "name": "Commit-0",
            "content": "import { Request, Response } from 'express';\r\nimport { createNewMember } from '../services/member.service';\r\n\r\nexport const createMember = async (req: Request, res: Response) => {\r\n  try {\r\n    const member = await createNewMember(req.body);\r\n    res.status(201).json(member);\r\n  } catch (err) {\r\n    console.error(err);\r\n    res.status(500).json({ error: 'Failed to create member' });\r\n  }\r\n};\r\n"
        }
    ]
}